{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 Licence Taipy is a free software under MIT Licence TODO: fix PYPI package or version link Overview \u00b6 What is Taipy \u00b6 Taipy is a framework for creating AI Business Applications. What it does \u00b6 Taipy allows you to automatize machine learning pipelines by running them onto scenarios. For who \u00b6 Taipy is mostly used by data scientists. Features \u00b6 TODO: Detail features Directory Structure \u00b6 The files needed to build Taipy are located in sub-directories that store files as follows: taipy : Python source files gui : Graphical user interface related files docs : The current documentation TODO: complete the directory structure","title":"Home"},{"location":"#home","text":"Licence Taipy is a free software under MIT Licence TODO: fix PYPI package or version link","title":"Home"},{"location":"#overview","text":"","title":"Overview"},{"location":"#what-is-taipy","text":"Taipy is a framework for creating AI Business Applications.","title":"What is Taipy"},{"location":"#what-it-does","text":"Taipy allows you to automatize machine learning pipelines by running them onto scenarios.","title":"What it does"},{"location":"#for-who","text":"Taipy is mostly used by data scientists.","title":"For who"},{"location":"#features","text":"TODO: Detail features","title":"Features"},{"location":"#directory-structure","text":"The files needed to build Taipy are located in sub-directories that store files as follows: taipy : Python source files gui : Graphical user interface related files docs : The current documentation TODO: complete the directory structure","title":"Directory Structure"},{"location":"authors/","text":"Development lead \u00b6 Taipy is developped and maintained by Avaiga. Visit our website Contact us by email Contributors \u00b6 None yet. Why not be the first? Check out the contributing section !","title":"Development lead"},{"location":"authors/#development-lead","text":"Taipy is developped and maintained by Avaiga. Visit our website Contact us by email","title":"Development lead"},{"location":"authors/#contributors","text":"None yet. Why not be the first? Check out the contributing section !","title":"Contributors"},{"location":"history/","text":"History \u00b6 0.1.0 (2021-08-30) \u00b6 First release on PyPI.","title":"History"},{"location":"history/#history","text":"","title":"History"},{"location":"history/#010-2021-08-30","text":"First release on PyPI.","title":"0.1.0 (2021-08-30)"},{"location":"contributing/about_contributing/","text":"About contributions \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.","title":"About contributions"},{"location":"contributing/about_contributing/#about-contributions","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.","title":"About contributions"},{"location":"contributing/get-started/","text":"Get started for local development \u00b6 How to set up Taipy for local development. \u00b6 Fork the Taipy repository on GitHub. Clone your fork locally $ git clone git@github.com:your_name_here/taipy.git Ensure pipenv is installed. Install dependencies: $ pipenv install --dev Create a branch for local development: $ git checkout -b name-of-your-bugfix-or-feature Make your changes locally and submit them. \u00b6 When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox : $ tox Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Before you submit a pull request, check that it meets the following guidelines. The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.8, 3.9 and for PyPy. Check https://github.com/avaiga/taipy/actions and make sure that the tests pass for all supported Python versions. Testing \u00b6 Use the follonwing command to run a subset of tests. $ pytest tests.test_taipys","title":"Get started for local development"},{"location":"contributing/get-started/#get-started-for-local-development","text":"","title":"Get started for local development"},{"location":"contributing/get-started/#how-to-set-up-taipy-for-local-development","text":"Fork the Taipy repository on GitHub. Clone your fork locally $ git clone git@github.com:your_name_here/taipy.git Ensure pipenv is installed. Install dependencies: $ pipenv install --dev Create a branch for local development: $ git checkout -b name-of-your-bugfix-or-feature","title":"How to set up Taipy for local development."},{"location":"contributing/get-started/#make-your-changes-locally-and-submit-them","text":"When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox : $ tox Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Before you submit a pull request, check that it meets the following guidelines. The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.8, 3.9 and for PyPy. Check https://github.com/avaiga/taipy/actions and make sure that the tests pass for all supported Python versions.","title":"Make your changes locally and submit them."},{"location":"contributing/get-started/#testing","text":"Use the follonwing command to run a subset of tests. $ pytest tests.test_taipys","title":"Testing"},{"location":"contributing/how-to-contribute/","text":"How you can contribute \u00b6 You can contribute in many ways. Report Bugs \u00b6 Report bugs at https://github.com/avaiga/taipy/issues . If you are reporting a bug, please include the following elements. Your operating system name and version . Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs \u00b6 Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features \u00b6 Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation \u00b6 Taipy could always use more documentation, whether as part of the official Taipy docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback \u00b6 The best way to send feedback is to file an issue at https://github.com/avaiga/taipy/issues . If you are proposing a feature, please apply the following recomandations. Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"How you can contribute"},{"location":"contributing/how-to-contribute/#how-you-can-contribute","text":"You can contribute in many ways.","title":"How you can contribute"},{"location":"contributing/how-to-contribute/#report-bugs","text":"Report bugs at https://github.com/avaiga/taipy/issues . If you are reporting a bug, please include the following elements. Your operating system name and version . Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing/how-to-contribute/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/how-to-contribute/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/how-to-contribute/#write-documentation","text":"Taipy could always use more documentation, whether as part of the official Taipy docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing/how-to-contribute/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/avaiga/taipy/issues . If you are proposing a feature, please apply the following recomandations. Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"credits/contributors/","text":"Contributors \u00b6 None yet. Why not be the first? Check out the contributing section !","title":"Contributors"},{"location":"credits/contributors/#contributors","text":"None yet. Why not be the first? Check out the contributing section !","title":"Contributors"},{"location":"credits/development_lead/","text":"Development lead \u00b6 Taipy is developped and maintained by Avaiga. Visit our website Contact us by email","title":"Development lead"},{"location":"credits/development_lead/#development-lead","text":"Taipy is developped and maintained by Avaiga. Visit our website Contact us by email","title":"Development lead"},{"location":"examples/","text":"taipy \u00b6","title":"taipy"},{"location":"examples/#taipy","text":"","title":"taipy"},{"location":"getting_started/creating_a_taipy_application/","text":"Creating a Taipy application \u00b6 TODO: Detail the steps and commands sections of this documentation The general steps to take to create a Taipy application are the following. Create the application setup Create the application scenarios Run the scenarios Connect a user interface Interact with the user interface import taipy","title":"Creating a Taipy application"},{"location":"getting_started/creating_a_taipy_application/#creating-a-taipy-application","text":"TODO: Detail the steps and commands sections of this documentation The general steps to take to create a Taipy application are the following. Create the application setup Create the application scenarios Run the scenarios Connect a user interface Interact with the user interface import taipy","title":"Creating a Taipy application"},{"location":"getting_started/installation/","text":"Installation \u00b6 Stable release \u00b6 To install Taipy, run this command in your terminal: $ pip install taipy This is the preferred method to install Taipy, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process. From source \u00b6 The source for Taipy can be downloaded from the Github repo . You can either clone the public repository: $ git clone git://github.com/avaiga/taipy Or download the tarball : $ curl -OJL https://github.com/avaiga/taipy/tarball/main Once you have a copy of the source, you can install it with: $ pip install .","title":"Installation"},{"location":"getting_started/installation/#installation","text":"","title":"Installation"},{"location":"getting_started/installation/#stable-release","text":"To install Taipy, run this command in your terminal: $ pip install taipy This is the preferred method to install Taipy, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process.","title":"Stable release"},{"location":"getting_started/installation/#from-source","text":"The source for Taipy can be downloaded from the Github repo . You can either clone the public repository: $ git clone git://github.com/avaiga/taipy Or download the tarball : $ curl -OJL https://github.com/avaiga/taipy/tarball/main Once you have a copy of the source, you can install it with: $ pip install .","title":"From source"},{"location":"manuals/about/","text":"About Taipy's User Manual \u00b6 This User Manual covers all the topics and concepts that you can find in Taipy. For each topic, we are trying to provide as many examples as possible so that you as a Taipy user can perform a specific task. If you are just starting with Taipy, you may want to look at the Getting Started document in order to see a complete example of a complete Taipy application, described step-by-step. Taipy Core \u00b6 The Taipy core package is a python library made to create complete back-end applications around decision-making algorithms. It provides back-end capabilities to help data scientists transform their algorithms into a back-end application, so they can quickly and easily put them into their end user's hands. Thanks to Taipy core, data scientists are more autonomous. They can focus on their core skills: building the best algorithms to solve their business problems. Once data scientist developers have implemented suitable algorithms, they can easily configure their Taipy application to use core features, including: work cycle and scenario management, scheduling, job monitoring, performance analysis. On this documentation, you will find the definitions of the core concepts , a description of the core features , and the documentation of the core configuration Taipy core concepts Taipy core features Configuring an application Graphical User Interface \u00b6 Taipy comes with a package ( taipy.gui ) that allows for building user interfaces. The Graphical User Interface (GUI) section will provide you with all the information you need to create pages that you can display and interact with. GUI user manual Deployment \u00b6 Heroku Deployment manual","title":"About Taipy's User Manual"},{"location":"manuals/about/#about-taipys-user-manual","text":"This User Manual covers all the topics and concepts that you can find in Taipy. For each topic, we are trying to provide as many examples as possible so that you as a Taipy user can perform a specific task. If you are just starting with Taipy, you may want to look at the Getting Started document in order to see a complete example of a complete Taipy application, described step-by-step.","title":"About Taipy's User Manual"},{"location":"manuals/about/#taipy-core","text":"The Taipy core package is a python library made to create complete back-end applications around decision-making algorithms. It provides back-end capabilities to help data scientists transform their algorithms into a back-end application, so they can quickly and easily put them into their end user's hands. Thanks to Taipy core, data scientists are more autonomous. They can focus on their core skills: building the best algorithms to solve their business problems. Once data scientist developers have implemented suitable algorithms, they can easily configure their Taipy application to use core features, including: work cycle and scenario management, scheduling, job monitoring, performance analysis. On this documentation, you will find the definitions of the core concepts , a description of the core features , and the documentation of the core configuration Taipy core concepts Taipy core features Configuring an application","title":"Taipy Core"},{"location":"manuals/about/#graphical-user-interface","text":"Taipy comes with a package ( taipy.gui ) that allows for building user interfaces. The Graphical User Interface (GUI) section will provide you with all the information you need to create pages that you can display and interact with. GUI user manual","title":"Graphical User Interface"},{"location":"manuals/about/#deployment","text":"Heroku Deployment manual","title":"Deployment"},{"location":"manuals/reference/","text":"Taipy packages and classes \u00b6 Top-level package for Taipy. common special \u00b6 frequency \u00b6 Frequency ( ReprEnum ) \u00b6 Enumeration representing the recurrence of a Scenario, and so the duration of its work cycle. The possible values are DAILY, WEEKLY, MONTHLY, QUARTERLY, YEARLY repr_enum \u00b6 ReprEnum ( Enum ) \u00b6 An enumeration. config special \u00b6 checker special \u00b6 checker \u00b6 Checker \u00b6 holds the various checks to perform on the config. issue \u00b6 Issue dataclass \u00b6 Dataclass representing an issue detected in the compiled configuration. Attributes: Name Type Description level str Level of the issue among ERROR, WARNING, INFO. field str Config field on which the issue has been detected. value Any Value of the field on which the issue has been detected. message str Readable message to help the user fix the issue. tag Optional[str] Optional tag to be used to filter issues. issue_collector \u00b6 IssueCollector \u00b6 Dataclass representing an issue detected in the compiled configuration. Attributes: Name Type Description errors List[Issue] List of error issues collected. warnings List[Issue] List warning issues collected. infos List[Issue] List info issues collected. all List[Issue] List of all issues collected ordered by decreasing level (Error, warning and info). add_error ( self , field , value , message , checker_name ) \u00b6 Adds an issue with error level. add_info ( self , field , value , message , checker_name ) \u00b6 Adds an issue with info level. add_warning ( self , field , value , message , checker_name ) \u00b6 Adds an issue with warning level. config \u00b6 Config \u00b6 Singleton entry point to configure Taipy application and retrieve the configuration values. add_data_node ( name , storage_type = 'pickle' , scope =< Scope . PIPELINE : 1 > , ** properties ) classmethod \u00b6 Adds a new data node configuration. add_default_data_node ( storage_type , scope =< Scope . PIPELINE : 1 > , ** properties ) classmethod \u00b6 Configures the default data node configuration. add_default_pipeline ( task_configs , ** properties ) classmethod \u00b6 Configures the default pipeline configuration. add_default_scenario ( pipelines , frequency = None , comparators = None , ** properties ) classmethod \u00b6 Configures the default scenario configuration. add_default_task ( input , function , output , ** properties ) classmethod \u00b6 Configures the default task configuration. add_pipeline ( name , task_configs , ** properties ) classmethod \u00b6 Adds a new pipeline configuration. add_scenario ( name , pipelines , frequency = None , comparators = None , ** properties ) classmethod \u00b6 Adds a new scenario configuration. add_task ( name , input , function , output , ** properties ) classmethod \u00b6 Adds a new task configuration. data_nodes () classmethod \u00b6 Returns data node configs by config name. export ( filename ) classmethod \u00b6 Exports the configuration to a toml file. The configuration exported is the configuration applied. It is compiled from the three possible methods to configure the application: The python code configuration, the file configuration and the environment configuration. Parameters: Name Type Description Default filename str or Path File to export. required Note Overwrite the file if it already exists. export_code_config ( filename ) classmethod \u00b6 Exports the python code configuration as a toml file. Parameters: Name Type Description Default filename str File to export. required Note Overwrite the file if it already exists. global_config () classmethod \u00b6 Returns configuration values related to the global application. job_config () classmethod \u00b6 Returns configuration values related to the job executions. load ( filename ) classmethod \u00b6 Loads configuration from file located at the filename given as parameter. Parameters: Name Type Description Default filename str or Path File to load. required pipelines () classmethod \u00b6 Returns pipeline configs by config name. scenarios () classmethod \u00b6 Returns scenario configs by config name. set_global_config ( notification = None , broker_endpoint = None , root_folder = None , storage_folder = None , clean_entities_enabled = None , ** properties ) classmethod \u00b6 Configures fields related to global application. set_job_config ( mode = None , nb_of_workers = None , hostname = None , airflow_dags_folder = None , airflow_folder = None , start_airflow = None , airflow_api_retry = None , airflow_user = None , airflow_password = None , ** properties ) classmethod \u00b6 Configures fields related to job execution. tasks () classmethod \u00b6 Returns task configs by config name. config_template_handler \u00b6 ConfigTemplateHandler \u00b6 Factory to handle actions related to config value templating. data_node_config \u00b6 DataNodeConfig \u00b6 Holds all the configuration fields needed to create actual data nodes from the DataNodeConfig. A Data Node config is made to be used as a generator for actual data nodes. It holds configuration information needed to create an actual data node. Attributes: Name Type Description name str Unique name as an identifier of the data node config. We strongly recommend to use lowercase alphanumeric characters, dash character '-', or underscore character ' '. Note that other characters are replaced according the following rules : - Space characters are replaced by underscore characters (' '). - Unicode characters are replaced by a corresponding alphanumeric character using the Unicode library. - Other characters are replaced by dash characters ('-'). storage_type str Storage type of the data nodes created from the data node config. The possible values are : \"csv\", \"excel\", \"pickle\", \"sql\" and \"In_memory\". Default value is \"pickle\". Note that the \"in_memory\" value can only be used when JobConfig.mode is \"standalone\". scope Scope The usage scope of the data nodes created from the data node config. Default value is Pipeline. properties dict Dictionary of additional properties. global_app_config \u00b6 GlobalAppConfig \u00b6 Holds configuration fields related to the global application. Parameters: Name Type Description Default notification bool Boolean field to activate/deactivate the notification. Default value : false. None broker_endpoint str broker endpoint used for notification. Must be populated if notification is true. Default value is None. None root_folder str Path of the base folder for the taipy application. Default value is \"./taipy/\" None storage_folder str Folder name used to store Taipy data. Default value is \".data/\". It is used in conjunction with the root_folder field. That means the storage path is (Default path : \"./taipy/.data/\") None clean_entities_enabled bool Boolean field to activate/deactivate the clean entities feature. Default: false None properties dict Dictionary of additional properties. {} job_config \u00b6 JobConfig \u00b6 Holds configuration fields related to the job executions. Parameters: Name Type Description Default mode str Field representing the Taipy operating mode. Possible values are \"standalone\", \"airflow\". Default value: \"standalone\". None nb_of_workers int Maximum number of running workers to execute jobs. Must be a positive integer. Default value : 1 None hostname str Hostname. Default value is \"localhost\". None airflow_dags_folder str Folder name used to store the dags to be read by airflow if airflow mode is activated. Default value is \".dag/\". It is used in conjunction with the GlobalAppConfig.root_folder field. That means the path for the airflow dag folder is (Default path : \"./taipy/.dag/\"). None airflow_folder str Folder name used by airflow if airflow mode is activated. Default value is \".airflow/\". It is used in conjunction with the GlobalAppConfig.root_folder field. That means the path for the airflow dag folder is (Default path : \"./taipy/.airflow/\"). None start_airflow bool Allow Taipy to start Airflow if not alreay started. None airflow_api_retry int Retry pattern on Airflow APIs. None airflow_user str User name used with the REST API. Default value is \"admin\". None airflow_password str Password used with the REST API. Default value is get from standalone_admin_password.txt file created by Airflow on standalone mode. None properties dict Dictionary of additional properties. {} is_standalone ( self ) \u00b6 True if the config is set to standalone execution pipeline_config \u00b6 PipelineConfig \u00b6 Holds all the configuration fields needed to create actual pipelines from the PipelineConfig. Attributes: Name Type Description name str Unique name as an identifier of the pipeline config. We strongly recommend to use lowercase alphanumeric characters, dash character '-', or underscore character ' '. Note that other characters are replaced according the following rules : - Space characters are replaced by underscore characters (' '). - Unicode characters are replaced by a corresponding alphanumeric character using the Unicode library. - Other characters are replaced by dash characters ('-'). tasks list List of task configs. Default value: []. properties dict Dictionary of additional properties. scenario_config \u00b6 ScenarioConfig \u00b6 Holds all the configuration fields needed to create actual scenarios from the ScenarioConfig. Attributes: Name Type Description name str Unique name as an identifier of the scenario config. We strongly recommend to use lowercase alphanumeric characters, dash character '-', or underscore character ' '. Note that other characters are replaced according the following rules : - Space characters are replaced by underscore characters (' '). - Unicode characters are replaced by a corresponding alphanumeric character using the Unicode library. - Other characters are replaced by dash characters ('-'). pipelines list List of pipeline configs. Default value: []. properties dict Dictionary of additional properties. task_config \u00b6 TaskConfig \u00b6 Holds all the configuration fields needed to create actual tasks from the TaskConfig. Attributes: Name Type Description name str Unique name as an identifier of the task config. We strongly recommend to use lowercase alphanumeric characters, dash character '-', or underscore character ' '. Note that other characters are replaced according the following rules : - Space characters are replaced by underscore characters (' '). - Unicode characters are replaced by a corresponding alphanumeric character using the Unicode library. - Other characters are replaced by dash characters ('-'). inputs list List of data node config inputs. Default value: []. outputs list List of data node config outputs. Default value: []. function Callable User function taking as inputs some parameters compatible with the exposed types (exposed_type field) of the inputs data nodes and returning results compatible with the exposed types (exposed_type field) of the outputs list. Default value: None. properties dict Dictionary of additional properties. toml_serializer \u00b6 TomlSerializer \u00b6 Convert configuration from TOML representation to Python Dict and reciprocally. cycle special \u00b6 cycle \u00b6 Cycle \u00b6 A Cycle object holds the frequency representing a work cycle. Attributes: Name Type Description frequency Frequency The frequency of the cycle properties dict[str, str] List of additional arguments. name str Name that identifies the cycle. creation_date datetime Date and time of the creation of the cycle start_date datetime Date and time of the start of the cycle end_date datetime Date and time of the end of the cycle id str Unique identifier of the cycle cycle_manager \u00b6 CycleManager \u00b6 The Cycle Manager is responsible for managing all the cycle-related capabilities. This class provides methods for creating, storing, updating, retrieving and deleting cycles. create ( frequency , name = None , creation_date = None , display_name = None , ** properties ) classmethod \u00b6 Creates a new cycle. Parameters: Name Type Description Default frequency Frequency The frequency of the new cycle. required name str The name of the new cycle. Default: None . None creation_date datetime The date and time when the cycle is created. Default: None . None display_name Optional[str] The display name of the cycle. None properties dict[str, str] other properties. Default: None . {} delete ( cycle_id ) classmethod \u00b6 Deletes a cycle. Parameters: Name Type Description Default cycle_id str The identifier of the cycle to be deleted. required Exceptions: Type Description ModelNotFound if no cycle corresponds to cycle_id . delete_all () classmethod \u00b6 Deletes all cycles. get ( cycle_id ) classmethod \u00b6 Gets the cycle corresponding to the identifier given as parameter. Parameters: Name Type Description Default cycle_id CycleId The identifier of the cycle to retrieve. required Exceptions: Type Description ModelNotFound if no cycle corresponds to cycle_id . get_all () classmethod \u00b6 Returns all the existing cycles. get_or_create ( frequency , creation_date = None , display_name = None ) classmethod \u00b6 Returns a cycle with the provided parameters. If no cycle already exists with the provided parameter values, a new cycle is created and returned. Parameters: Name Type Description Default frequency Frequency The frequency of the cycle. required creation_date Optional[datetime] The creation date of the cycle. Default value : None . None display_name Optional[str] The display name of the cycle. None Returns: Type Description Cycle a cycle that has the indicated parameters. A new cycle may be created. set ( cycle ) classmethod \u00b6 Saves or updates a cycle. Parameters: Name Type Description Default cycle Cycle The cycle to save. required cycle_model \u00b6 CycleModel dataclass \u00b6 CycleModel(id: .new_type at 0x7fb9ed49fc10>, name: str, frequency: taipy.common.frequency.Frequency, properties: dict, creation_date: str, start_date: str, end_date: str) cycle_repository \u00b6 CycleRepository ( FileSystemRepository ) \u00b6 storage_folder : Path property readonly \u00b6 Base folder used by repository to store data from_model ( self , model ) \u00b6 Converts a model to its functional object. to_model ( self , cycle ) \u00b6 Converts the object to be saved to its model. data special \u00b6 csv \u00b6 CSVDataNode ( DataNode ) \u00b6 A Data Node stored as a CSV file. Attributes: Name Type Description config_name str Name that identifies the data node. We strongly recommend to use lowercase alphanumeric characters, dash character '-', or underscore character ' '. Note that other characters are replaced according the following rules : - Space characters are replaced by underscore characters (' '). - Unicode characters are replaced by a corresponding alphanumeric character using the Unicode library. - Other characters are replaced by dash characters ('-'). scope Scope The usage scope of this data node. id str Unique identifier of this data node. name str User-readable name of the data node. parent_id str Identifier of the parent (pipeline_id, scenario_id, cycle_id) or None . last_edition_date datetime Date and time of the last edition. job_ids List[str] Ordered list of jobs that have written this data node. up_to_date bool True if the data is considered as up to date. False otherwise. properties dict Dict of additional arguments. Note that the properties parameter should at least contain a value for \"path\" properties. data_manager \u00b6 DataManager \u00b6 A Data Manager is responsible for all managing data node related capabilities. In particular, it is exposing methods for creating, storing, updating, retrieving, deleting data nodes. delete ( data_node_id ) classmethod \u00b6 Deletes the data node provided as parameter. Parameters: Name Type Description Default data_node_id str) identifier of the data node to delete. required Exceptions: Type Description ModelNotFound Raised if no data node corresponds to data_node_id. delete_all () classmethod \u00b6 Deletes all data nodes. get ( data_node ) classmethod \u00b6 Gets the data node corresponding to the DataNode or the identifier given as parameter. Parameters: Name Type Description Default data_node Union[DataNode, DataNodeId]) data node to get. required Exceptions: Type Description ModelNotFound Raised if no data node corresponds to data_node_id. get_all () classmethod \u00b6 Returns the list of all existing data nodes. get_or_create ( data_node_config , scenario_id = None , pipeline_id = None ) classmethod \u00b6 Gets or creates a Data Node. Returns the data node created from the data_node_config, by (pipeline_id and scenario_id) if it already exists, or creates and returns a new data_node. Parameters: Name Type Description Default data_node_config DataNodeConfig) data node configuration object. required scenario_id Optional[ScenarioId]) id of the scenario creating the data node. None pipeline_id Optional[PipelineId]) id of the pipeline creating the data node. None Exceptions: Type Description MultipleDataNodeFromSameConfigWithSameParent Raised if more than 1 data node already exist with same config, and the same parent id (scenario_id, or pipeline_id depending on the scope of the data node). InvalidDataNodeType Raised if the type of the data node config is invalid. set ( data_node ) classmethod \u00b6 Saves or Updates the data node given as parameter. Parameters: Name Type Description Default data_node DataNode) data node to save or update. required data_model \u00b6 DataNodeModel dataclass \u00b6 The model of a DataNode. A model refers to the structure of a Data Node stored in a database. Attributes: Name Type Description id str Identifier of a DataNode. config_name int Name of the DataNodeConfig . scope taipy.data.node.scope.Scope Scope of the usage of a DataNode. type str Name of the class that represents a DataNode. name str User-readable name of the data node. parent_id str Identifier of the parent (pipeline_id, scenario_id, cycle_id) or None . last_edition_date str ISO format of the last edition date and time. job_ids List[str] List of jobs that computed the data node. edition_in_progress bool True if a task computing this data node has been submitted and not completed yet. False otherwise. data_node_properties Dict[str, Any] Additional properties of the data node. Note The tuple (config_name, parent_id) forms a unique key. data_node \u00b6 DataNode \u00b6 Data Node represents a reference to a dataset but not the data itself. A Data Node holds meta data related to the dataset it refers. In particular, a data node holds the name, the scope, the parent_id, the last edition date and additional properties of the data. A data Node is also made to contain information and methods needed to access the dataset. This information depends on the type of storage and it is hold by children classes (such as SQL Data Node, CSV Data Node, ...). It is strongly recommended to only instantiate children classes of Data Node through a Data Manager. Attributes: Name Type Description config_name str Name that identifies the data node. We strongly recommend to use lowercase alphanumeric characters, dash character '-', or underscore character ' '. Note that other characters are replaced according the following rules : - Space characters are replaced by underscore characters (' '). - Unicode characters are replaced by a corresponding alphanumeric character using the Unicode library. - Other characters are replaced by dash characters ('-'). scope Scope The usage scope of this data node. id str Unique identifier of this data node. name str User-readable name of the data node. parent_id str Identifier of the parent (pipeline_id, scenario_id, cycle_id) or None . last_edition_date datetime Date and time of the last edition. job_ids List[str] Ordered list of jobs that have written this data node. validity_days Optional[int] Number of days to be added to the data node validity duration. If validity_days, validity_hours, and validity_minutes are all set to None, The data_node is always up to date. validity_hours Optional[int] Number of hours to be added to the data node validity duration. If validity_days, validity_hours, and validity_minutes are all set to None, The data_node is always up to date. validity_minutes Optional[int] Number of minutes to be added to the data node validity duration. If validity_days, validity_hours, and validity_minutes are all set to None, The data_node is always up to date. edition_in_progress bool) True if a task computing the data node has been submitted and not completed yet. False otherwise. properties dict Dict of additional arguments. filter ( self , operators , join_operator =< JoinOperator . AND : 1 > ) \u00b6 Filter data based on the provided list of tuples (key, value, operator) If mulitple filter operators, filtered data will be joined based on the join operator (AND or OR) validity ( self ) \u00b6 Number of minutes where the Data Node is up-to-date. data_repository \u00b6 DataRepository ( FileSystemRepository ) \u00b6 storage_folder : Path property readonly \u00b6 Base folder used by repository to store data from_model ( self , model ) \u00b6 Converts a model to its functional object. to_model ( self , data_node ) \u00b6 Converts the object to be saved to its model. excel \u00b6 ExcelDataNode ( DataNode ) \u00b6 A Data Node stored as an Excel file (xlsx format). Attributes: Name Type Description config_name str Name that identifies the data node. We strongly recommend to use lowercase alphanumeric characters, dash character '-', or underscore character ' '. Note that other characters are replaced according the following rules : - Space characters are replaced by underscore characters (' '). - Unicode characters are replaced by a corresponding alphanumeric character using the Unicode library. - Other characters are replaced by dash characters ('-'). scope Scope The usage scope of this data node. id str Unique identifier of this data node. name str User-readable name of the data node. parent_id str Identifier of the parent (pipeline_id, scenario_id, cycle_id) or None . last_edition_date datetime Date and time of the last edition. job_ids List[str] Ordered list of jobs that have written this data node. up_to_date bool True if the data is considered as up to date. False otherwise. properties dict Dict of additional arguments. Note that the properties parameter should at least contain a value for \"path\" properties. in_memory \u00b6 InMemoryDataNode ( DataNode ) \u00b6 A Data Node stored in memory. This Data Node implementation is not compatible with a parallel execution of taipy tasks, but only with a Synchronous task executor. The purpose of InMemoryDataNode is to be used for development or debug. Attributes: Name Type Description config_name str Name that identifies the data node. We strongly recommend to use lowercase alphanumeric characters, dash character '-', or underscore character ' '. Note that other characters are replaced according the following rules : - Space characters are replaced by underscore characters (' '). - Unicode characters are replaced by a corresponding alphanumeric character using the Unicode library. - Other characters are replaced by dash characters ('-'). scope Scope The usage scope of this data node. id str Unique identifier of this data node. name str User-readable name of the data node. parent_id str Identifier of the parent (pipeline_id, scenario_id, cycle_id) or None . last_edition_date datetime Date and time of the last edition. job_ids List[str] Ordered list of jobs that have written this data node. up_to_date bool True if the data is considered as up to date. False otherwise. properties dict Dict of additional arguments. Note that at the creation of the In Memory data node, if the property default_data is present, the data node is automatically written with the corresponding default_data value. operator \u00b6 JoinOperator ( Enum ) \u00b6 An enumeration. Operator ( Enum ) \u00b6 The operator of filtering of a Data Node. pickle \u00b6 PickleDataNode ( DataNode ) \u00b6 A Data Node stored as a pickle file. Attributes: Name Type Description config_name str Name that identifies the data node. We strongly recommend to use lowercase alphanumeric characters, dash character '-', or underscore character ' '. Note that other characters are replaced according the following rules : - Space characters are replaced by underscore characters (' '). - Unicode characters are replaced by a corresponding alphanumeric character using the Unicode library. - Other characters are replaced by dash characters ('-'). scope Scope The usage scope of this data node. id str Unique identifier of this data node. name str User-readable name of the data node. parent_id str Identifier of the parent (pipeline_id, scenario_id, cycle_id) or None . last_edition_date datetime Date and time of the last edition. job_ids List[str] Ordered list of jobs that have written this data node. up_to_date bool True if the data is considered as up to date. False otherwise. properties dict Dict of additional arguments. Note that at the creation of the data node, if the property \"default_data\" is present, the data node is automatically written with the corresponding default_data value. If the property \"path\" is present, data will be stored using the corresponding value as the name of the file. scope \u00b6 OrderedEnum ( ReprEnum ) \u00b6 An enumeration. Scope ( OrderedEnum ) \u00b6 The scope of usage of a Data Node. sql \u00b6 SQLDataNode ( DataNode ) \u00b6 A Data Node stored as a SQL database. Attributes: Name Type Description config_name str Name that identifies the data node. We strongly recommend to use lowercase alphanumeric characters, dash character '-', or underscore character ' '. Note that other characters are replaced according the following rules : - Space characters are replaced by underscore characters (' '). - Unicode characters are replaced by a corresponding alphanumeric character using the Unicode library. - Other characters are replaced by dash characters ('-'). scope Scope The usage scope of this data node. id str Unique identifier of this data node. name str User-readable name of the data node. parent_id str Identifier of the parent (pipeline_id, scenario_id, cycle_id) or None . last_edition_date datetime Date and time of the last edition. job_ids List[str] Ordered list of jobs that have written this data node. edition_in_progress bool True if a task computing the data node has been submitted and not completed yet. False otherwise. properties dict Dict of additional arguments. Note that properties should at least contain values for \"db_username\", \"db_password\", \"db_name\", \"db_engine\" and \"query\" properties. exceptions special \u00b6 configuration \u00b6 ConfigurationIssueError ( Exception ) \u00b6 Raised if an inconsistency has been detected in the configuration. InconsistentEnvVariableError ( Exception ) \u00b6 Inconsistency value has been detected in an environment variable referenced by the configuration. LoadingError ( Exception ) \u00b6 Raised if an error occurs while loading the configuration file. MissingEnvVariableError ( Exception ) \u00b6 Environment variable referenced in configuration is missing. cycle \u00b6 CycleAlreadyExists ( Exception ) \u00b6 Exception raised if it is trying to create a Cycle that has already exists NonExistingCycle ( Exception ) \u00b6 Exception raised if we request a cycle not known by the cycle manager. data_node \u00b6 InvalidDataNodeType ( Exception ) \u00b6 Raised if a data node does not exist. MissingRequiredProperty ( Exception ) \u00b6 Raised if a required property is missing when creating a Data Node. MultipleDataNodeFromSameConfigWithSameParent ( Exception ) \u00b6 Raised if there are multiple data nodes from the same data node configuration and the same parent identifier. NoData ( Exception ) \u00b6 Raised when reading a data node before it has been written. NonExistingDataNode ( Exception ) \u00b6 Raised if a requested DataNode is not known by the DataNode Manager. NonExistingExcelSheet ( Exception ) \u00b6 Raised if a requested Sheet name does not exist in the provided Excel file. NotMatchSheetNameAndCustomObject ( Exception ) \u00b6 Raised if a provided list of sheet names does not match with the provided list of custom objects. UnknownDatabaseEngine ( Exception ) \u00b6 Exception raised when creating a connection with a SQLDataNode job \u00b6 DataNodeWritingError ( RuntimeError ) \u00b6 Raised if an error happens during the writing in a data node. InvalidSubscriber ( RuntimeError ) \u00b6 Raised if we try to load a function that is not valid. JobNotDeletedException ( RuntimeError ) \u00b6 Raised if we try to delete a job that cannot be deleted. NonExistingJob ( RuntimeError ) \u00b6 Raised if we try to get a job that does not exist. pipeline \u00b6 MultiplePipelineFromSameConfigWithSameParent ( Exception ) \u00b6 Exception raised if it exists multiple pipelines from the same pipeline config and with the same parent_id NonExistingPipeline ( Exception ) \u00b6 Raised if a requested Pipeline is not known by the Pipeline Manager. NonExistingPipelineConfig ( Exception ) \u00b6 Raised if a requested Pipeline configuration is not known by the Pipeline Manager. repository \u00b6 ModelNotFound ( Exception ) \u00b6 Raised when trying to fetch a non existent model. scenario \u00b6 DeletingMasterScenario ( Exception ) \u00b6 Raised when trying to remove a master scenario DifferentScenarioConfigs ( Exception ) \u00b6 Scenarios must contains the same config DoesNotBelongToACycle ( Exception ) \u00b6 Raised when setting a scenario to be the master scenario but it doesn't belong to any cycle InsufficientScenarioToCompare ( Exception ) \u00b6 Must provide at least 2 scenarios for scenario comparison NonExistingComparator ( Exception ) \u00b6 Must provide an existing comparator NonExistingScenario ( Exception ) \u00b6 Raised when a requested scenario is not known by the Scenario Manager. NonExistingScenarioConfig ( Exception ) \u00b6 Raised when a requested scenario configuration is not known by the Scenario Manager. task \u00b6 MultipleTaskFromSameConfigWithSameParent ( Exception ) \u00b6 Raised if there are multiple tasks from the same task configuration and the same parent identifier. NonExistingTask ( Exception ) \u00b6 Raised when a requested task is not known by the Task Manager. NonExistingTaskConfig ( Exception ) \u00b6 Raised when a requested task configuration is not known by the Task Manager. gui special \u00b6 gui package: Graphical User Interface \u00b6 The Graphical User Interface module of Taipy lets you run a Web server that a Web browser can connect to. The server generates Web pages on the fly, configured by the application developer. Each page can contain regular text and images, as well as Taipy controls that are typically linked to some value that is managed by the whole Taipy application. data special \u00b6 data_format \u00b6 DataFormat ( Enum ) \u00b6 An enumeration. gui \u00b6 Gui \u00b6 The class that handles the Graphical User Interface. Attributes: Name Type Description on_action t.FunctionType The default function that is called when a control triggers an action, as the result of an interaction with the end-user. on_change t.FunctionType The function that is called when a control modifies the variable it is bound to, as the result of an interaction with the end-user. __init__ ( self , css_file = '__main__' , page = None , pages = None , path_mapping = {}, env_filename = None , flask = None ) special \u00b6 Initializes a new Gui instance. Parameters: Name Type Description Default page t.Union[str, PageRenderer] An optional PageRenderer instance that is used when there is a single page in this interface, referenced as the root page (located at / ). If page is a raw string, a Markdown page renderer is built from that string. Note that if pages is provided, those pages are added as well. None css_file string An optional pathname to a CSS file that gets used as a style sheet in all the pages. The default value is a file that has the same base name as the Python file defining the main function, sitting next to this Python file, with the .css extension. '__main__' block_ui ( self , callback = None , message = 'Work in Progress...' ) \u00b6 Blocks the UI Parameters: Name Type Description Default action string | function The action to be carried on cancel. If empty string or None, no Cancel action will be provided to the user. required message string The message to show. Default: Work in Progress... 'Work in Progress...' navigate ( self , to = '' ) \u00b6 Navigate to a page Parameters: Name Type Description Default to t.Optional[str] page to navigate to. Should be a valid page identifier. If ommitted, navigates to the root page. '' run ( self , run_server = True , ** kwargs ) \u00b6 Starts the server that delivers pages to Web clients. Once you enter run , users can run Web browsers and point to the Web server URL that Gui serves. The default is to listen to the localhost address (127.0.0.1) on the port number 5000. However, the configuration of the Gui object may impact that (see TODO-Configuration-TODO). Parameters: Name Type Description Default run_server bool whether or not to run a Web server locally. If set to False , a Web server is not created and started. True show_notification ( self , type = 'I' , message = '' , browser_notification = None , duration = None ) \u00b6 Sends a notification to the user interface. Parameters: Name Type Description Default type string The notification type. This can be one of \"success\" , \"info\" , \"warning\" or \"error\" . To remove the last notification, set this parameter to the empty string. 'I' message string The text message to display. '' browser_notification bool If set to True , the browser will also show the notification. If not specified or set to None , this parameter will user the value of app_config[browser_notification] . None duration t.Optional[int] The time, in milliseconds, during which the notification is shown. If not specified or set to None , this parameter will user the value of app_config[notification_duration] . None Note that you can also call this function with type set to the first letter or the alert type (ie setting type to \"i\" is equivalent to setting it to \"info\" ). unblock_ui ( self ) \u00b6 Unblocks the UI page \u00b6 Page \u00b6 A page that can be served by a Gui instance. In order for Gui to serve pages to a Web browser, you must create instances of Page . Every page has a name, so it can be located in the address bar of the browser, and some content that is generated from a text template. Attributes: Name Type Description renderer PageRenderer The renderer to be used for this page. route string The name of this page. style string TBD head t.Union[str, None] TBD renderers special \u00b6 Html ( PageRenderer ) \u00b6 The page renderer for HTML text. __init__ ( self , content ) special \u00b6 Initializes a new Html page renderer. Parameters: Name Type Description Default content string The text content or the path to the file holding the HTML text to be transformed. required Markdown ( PageRenderer ) \u00b6 The page renderer for Markdown text. __init__ ( self , content ) special \u00b6 Initializes a new Markdown page renderer. Parameters: Name Type Description Default content string The text content or the path to the file holding the Markdown text to be transformed. required PageRenderer ( ABC ) \u00b6 The base class that transform template text to actual pages that can be displayed on a Web browser. When a page is requested to be displayed, it is transformed into HTML code that can be sent to the client. All control placeholders are replaced by the appropriate graphical component so you can display your application variables, and potentially interact with them. __init__ ( self , content ) special \u00b6 Initializes a new PageRenderer with the indicated content. Parameters: Name Type Description Default content string The text content or the path to the file holding the text to be transformed. required If content is a path to a readable file, the file is read entirely as the text template. jsonencoder \u00b6 TaipyJsonEncoder ( JSONEncoder ) \u00b6 default ( self , o ) \u00b6 Implement this method in a subclass such that it returns a serializable object for o , or calls the base implementation (to raise a TypeError ). For example, to support arbitrary iterators, you could implement default like this:: def default(self, o): !!! try iterable = iter(o) except TypeError: pass !!! else return list(iterable) # Let the base class default method raise the TypeError return JSONEncoder.default(self, o) types \u00b6 AttributeType ( Enum ) \u00b6 An enumeration. WsType ( Enum ) \u00b6 An enumeration. utils special \u00b6 killable_thread \u00b6 KillableThread ( Thread ) \u00b6 start ( self ) \u00b6 Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. job special \u00b6 job \u00b6 Job \u00b6 Execution of a Task. A Job is the execution wrapper around a Task. It handles the status of the execution, contains raising exceptions during the execution and notifies subscriber when the job is finished. Attributes: Name Type Description id Id of the Job. task Task that is executed by the job. force Boolean to enforce the execution whatever the cache data nodes. status Current status of the job. creation_date Date of the object creation. exceptions : List [ Exception ] property readonly \u00b6 Contains exceptions raised during the execution. Returns: Type Description List[Exception] Exceptions raised as list. __contains__ ( self , task ) special \u00b6 Returns true if the Job contains a specific task. Returns: Type Description True if the Job is based on this task. is_blocked ( self ) \u00b6 Returns true if the job is blocked. Returns: Type Description bool True if the job is blocked. is_cancelled ( self ) \u00b6 Returns true if the job is cancelled. Returns: Type Description bool True if the job is cancelled. is_completed ( self ) \u00b6 Returns true if the job is completed. Returns: Type Description bool True if the job is completed. is_failed ( self ) \u00b6 Returns true if the job failed. Returns: Type Description bool True if the job has failed. is_finished ( self ) \u00b6 Returns true if the job is finished. Returns: Type Description bool True if the job is finished. is_pending ( self ) \u00b6 Returns true if the job is pending. Returns: Type Description bool True if the job is pending. is_running ( self ) \u00b6 Returns true if the job is running. Returns: Type Description bool True if the job is running. is_skipped ( self ) \u00b6 Returns true if the job is skipped. Returns: Type Description bool True if the job is skipped. is_submitted ( self ) \u00b6 Returns true if the job is submitted. Returns: Type Description bool True if the job is submitted. on_status_change ( self , * functions ) \u00b6 Allows to be notified when the status of the job changes. Job passing through multiple statuses (Submitted, pending, etc.) before being finished. You can be triggered on each change through this function unless for the Submitted status. Parameters: Name Type Description Default functions Callables that will be called on each status change. () update_status ( self , ft ) \u00b6 Update the Job status based on if an exception was raised or not. job_manager \u00b6 JobManager \u00b6 The Job Manager is responsible for managing all the job-related capabilities. This class provides methods for creating, storing, updating, retrieving and deleting jobs. create ( task , callbacks , force = False ) classmethod \u00b6 Returns a new job representing a unique execution of the provided task. Parameters: Name Type Description Default task Task The task to execute. required callbacks Iterable[Callable] Iterable of callable to be executed on job status change. required force Boolean to enforce re execution of the task whatever the cache of the output data nodes. False Returns: Type Description Job A new job, that is created for executing given task. delete ( job , force = False ) classmethod \u00b6 Deletes the job if it is finished. Exceptions: Type Description JobNotDeletedException if the job is not finished. delete_all () classmethod \u00b6 Deletes all jobs. get ( job_id ) classmethod \u00b6 Gets the job from the job id given as parameter. Returns: Type Description Job The Job corresponding to the id. Exceptions: Type Description NonExistingJob if not found. get_all () classmethod \u00b6 Gets all the existing jobs. Returns: Type Description List[taipy.job.job.Job] List of all jobs. get_latest ( task ) classmethod \u00b6 Allows to retrieve the latest computed job of a task. Returns: Type Description Job The latest computed job of the task. set ( job ) classmethod \u00b6 Saves or updates a job. Parameters: Name Type Description Default job Job The job to save. required job_model \u00b6 JobModel dataclass \u00b6 JobModel(id: .new_type at 0x7fb9ed49f670>, task_id: str, status: taipy.job.status.Status, force: bool, creation_date: str, subscribers: List[Dict], exceptions: List[str]) job_repository \u00b6 JobRepository ( FileSystemRepository ) \u00b6 storage_folder : Path property readonly \u00b6 Base folder used by repository to store data from_model ( self , model ) \u00b6 Converts a model to its functional object. to_model ( self , job ) \u00b6 Converts the object to be saved to its model. status \u00b6 Status ( ReprEnum ) \u00b6 Enumeration representing the execution status of a Job. The possible values are SUBMITTED, BLOCKED, PENDING, RUNNING, CANCELLED, FAILED, COMPLETED, SKIPPED pipeline special \u00b6 pipeline \u00b6 Pipeline \u00b6 A Pipeline entity that holds a list of tasks and additional arguments representing a set of data processing elements connected in series. Attributes: Name Type Description config_name str Name that identifies the pipeline configuration. We strongly recommend to use lowercase alphanumeric characters, dash characters ('-'), or underscore characters (' '). Other characters are replaced according the following rules: - Space characters are replaced by underscore characters (' '). - Unicode characters are replaced by a corresponding alphanumeric character using the Unicode library. - Other characters are replaced by dash characters ('-'). properties dict List of additional arguments. tasks List[Task] List of tasks. pipeline_id str Unique identifier of this pipeline. parent_id str Identifier of the parent (pipeline_id, scenario_id, cycle_id) or None . pipeline_manager \u00b6 PipelineManager \u00b6 The Pipeline Manager is responsible for managing all pipeline-related capabilities. delete ( pipeline_id ) classmethod \u00b6 Deletes the pipeline provided as parameter. Parameters: Name Type Description Default pipeline_id str identifier of the pipeline to delete. required delete_all () classmethod \u00b6 Deletes all pipelines. get ( pipeline ) classmethod \u00b6 Gets a pipeline. Parameters: Name Type Description Default pipeline Union[Pipeline, PipelineId] pipeline identifier or the pipeline to get. required Exceptions: Type Description NonExistingPipeline if no pipeline corresponds to pipeline_id . get_all () classmethod \u00b6 Returns all existing pipelines. Returns: Type Description List[Pipeline] the list of all pipelines managed by this pipeline manager. get_or_create ( pipeline_config , scenario_id = None ) classmethod \u00b6 Returns a pipeline created from the pipeline configuration. Parameters: Name Type Description Default pipeline_config PipelineConfig The pipeline configuration object. required scenario_id Optional[ScenarioId] id of the scenario creating the pipeline. Default value : None . None Exceptions: Type Description MultiplePipelineFromSameConfigWithSameParent if more than one pipeline already exists with the same config, and the same parent id (scenario_id, or pipeline_id depending on the scope of the data nodes). hard_delete ( pipeline_id , scenario_id = None ) classmethod \u00b6 Deletes the pipeline given as parameter and the nested tasks, data nodes, and jobs. Deletes the pipeline given as parameter and propagate the hard deletion. The hard delete is propagated to a nested task if the task is not shared by another pipeline or if a scenario id is given as parameter, by another scenario. pipeline_id (PipelineId) : identifier of the pipeline to hard delete. scenario_id (ScenarioId) : identifier of the optional parent scenario. ModelNotFound error if no pipeline corresponds to pipeline_id. set ( pipeline ) classmethod \u00b6 Saves or updates a pipeline. Parameters: Name Type Description Default pipeline Pipeline the pipeline to save or update. required submit ( pipeline , callbacks = None , force = False ) classmethod \u00b6 Submits the pipeline corresponding to the pipeline or the identifier given as parameter for execution. All the tasks of pipeline will be submitted for execution. Parameters: Name Type Description Default pipeline Union[PipelineId, Pipeline] the pipeline or its id to submit. required callbacks Optional[List[Callable]] Callbacks on job status changes. None force bool Boolean to enforce re execution of the tasks whatever the cache data nodes. False subscribe ( callback , pipeline = None ) classmethod \u00b6 Subscribes a function to be called when the status of a Job changes. If pipeline is not passed, the subscription is added to all pipelines. Note Notification will be available only for jobs created after this subscription. unsubscribe ( callback , pipeline = None ) classmethod \u00b6 Unsubscribes a function that is called when the status of a Job changes. If pipeline is not passed, the subscription is removed to all pipelines. Note The function will continue to be called for ongoing jobs. pipeline_model \u00b6 PipelineModel dataclass \u00b6 Class to hold a model of a Pipeline. A model refers to the structure of a Pipeline stored in a database. Attributes: Name Type Description id PipelineId identifier of a Pipeline. parent_id str Identifier of the parent (pipeline_id, scenario_id, cycle_id) or None . name str name of the pipeline. properties(dict) List of additional arguments. pipeline_repository \u00b6 PipelineRepository ( FileSystemRepository ) \u00b6 storage_folder : Path property readonly \u00b6 Base folder used by repository to store data from_model ( self , model ) \u00b6 Converts a model to its functional object. to_model ( self , pipeline ) \u00b6 Converts the object to be saved to its model. repository special \u00b6 fs_base \u00b6 CustomEncoder ( JSONEncoder ) \u00b6 default ( self , o ) \u00b6 Implement this method in a subclass such that it returns a serializable object for o , or calls the base implementation (to raise a TypeError ). For example, to support arbitrary iterators, you could implement default like this:: def default(self, o): !!! try iterable = iter(o) except TypeError: pass !!! else return list(iterable) # Let the base class default method raise the TypeError return JSONEncoder.default(self, o) FileSystemRepository ( Generic ) \u00b6 Holds common methods to be used and extended when the need for saving dataclasses as JSON files in local storage emerges. Some lines have type: ignore because MyPy won't recognize some generic attributes. This should be revised in the future. Attributes: Name Type Description model ModelType Generic dataclass. dir_name str Folder that will hold the files for this dataclass model. storage_folder : Path property readonly \u00b6 Base folder used by repository to store data from_model ( self , model ) \u00b6 Converts a model to its functional object. to_model ( self , obj ) \u00b6 Converts the object to be saved to its model. scenario special \u00b6 scenario \u00b6 Scenario \u00b6 Represents an instance of the business case to solve. It holds a set of pipelines to submit for execution in order to solve the business case. Attributes: Name Type Description config_name str Name that identifies the scenario configuration. We strongly recommend to use lowercase alphanumeric characters, dash characters ('-'), or underscore characters (' '). Other characters are replaced according the following rules: - Space characters are replaced by underscore characters (' '). - Unicode characters are replaced by a corresponding alphanumeric character using the Unicode library. - Other characters are replaced by dash characters ('-'). pipelines List[Pipeline] List of pipelines. properties dict Dictionary of additional properties of the scenario. scenario_id str Unique identifier of this scenario. Will be generated if None value provided. creation_date datetime Date and time of the creation of the scenario. is_master bool True if the scenario is the master of its cycle. False otherwise. cycle Cycle Cycle of the scenario. add_subscriber ( self , callback ) \u00b6 Adds callback function to be called when executing the scenario each time a scenario job changes status new_id ( config_name ) staticmethod \u00b6 Generates a unique scenario identifier. remove_subscriber ( self , callback ) \u00b6 Removes callback function scenario_manager \u00b6 ScenarioManager \u00b6 Scenario Manager is responsible for all managing scenario related capabilities. In particular, it is exposing methods for creating, storing, updating, retrieving, deleting, submitting scenarios. compare ( * scenarios , * , data_node_config_name = None ) classmethod \u00b6 Compares the data nodes of given scenarios with known datanode config name. Parameters: Name Type Description Default scenarios Scenario) Scenario objects to compare () data_node_config_name Optional[str]) config name of the DataNode to compare scenarios, if no ds_config_name is None Exceptions: Type Description InsufficientScenarioToCompare Provided only one or no scenario for comparison NonExistingComparator The provided comparator does not exist DifferentScenarioConfigs The provided scenarios do not share the same scenario_config NonExistingScenarioConfig Cannot find the shared scenario config of the provided scenarios create ( config , creation_date = None , display_name = None ) classmethod \u00b6 Creates and returns a new scenario from the scenario configuration provided as parameter. If the scenario belongs to a work cycle, the cycle (corresponding to the creation_date and the configuration frequency attribute) is created if it does not exist yet. Parameters: Name Type Description Default config ScenarioConfig) Scenario configuration object. required creation_date Optional[datetime.datetime]) Creation date of the scenario. Current date time is used as default value. None display_name Optional[str]) Display name of the scenario. None delete ( scenario_id ) classmethod \u00b6 Deletes the scenario given as parameter. Parameters: Name Type Description Default scenario_id ScenarioId) identifier of the scenario to delete. required Exceptions: Type Description DeletingMasterScenario scenario_id corresponds to a master Scenario. It cannot be deleted. ModelNotFound No scenario corresponds to scenario_id. delete_all () classmethod \u00b6 Deletes all scenarios. get ( scenario ) classmethod \u00b6 Returns the scenario corresponding to the scenario or the identifier given as parameter. Parameters: Name Type Description Default scenario Union[Scenario, ScenarioId]) scenario to get. required Exceptions: Type Description NonExistingScenario No scenario corresponds to scenario_id. get_all () classmethod \u00b6 Returns the list of all existing scenarios. get_all_by_cycle ( cycle ) classmethod \u00b6 Returns the list of all existing scenarios that belong to the cycle given as parameter. Parameters: Name Type Description Default cycle Cycle) Cycle of the scenarios to return. required get_all_masters () classmethod \u00b6 Returns the list of all master scenarios. get_master ( cycle ) classmethod \u00b6 Returns the master scenario of the cycle given as parameter. None is the cycle has no master scenario. Parameters: Name Type Description Default cycle Cycle) cycle of the master scenario to return. required hard_delete ( scenario_id ) classmethod \u00b6 Deletes the scenario given as parameter and the nested pipelines, tasks, data nodes, and jobs. Deletes the scenario given as parameter and propagate the hard deletion. The hard delete is propagated to a nested pipeline if the pipeline is not shared by another scenario. scenario_id (ScenarioId) : identifier of the scenario to hard delete. ModelNotFound error if no scenario corresponds to scenario_id. set ( scenario ) classmethod \u00b6 Saves or Updates the scenario given as parameter. Parameters: Name Type Description Default scenario Scenario) Scenario to save or update. required set_master ( scenario ) classmethod \u00b6 Promotes scenario given as parameter as master scenario of its cycle. If the cycle already had a master scenario it will be demoted and it will no longer be master for the cycle. Parameters: Name Type Description Default scenario Scenario) scenario to promote as master. required submit ( scenario , force = False ) classmethod \u00b6 Submits the scenario corresponding to the scenario of the identifier given as parameter for execution. All the tasks of scenario will be submitted for execution. Parameters: Name Type Description Default scenario Union[Scenario, ScenarioId]) the scenario or its identifier to submit. required force bool Boolean to enforce re execution of the tasks whatever the cache data nodes. False subscribe ( callback , scenario = None ) classmethod \u00b6 Subscribes a function to be called each time one of the provided scenario jobs changes status. If scenario is not passed, the subscription is added to all scenarios. Note Notification will be available only for jobs created after this subscription. unsubscribe ( callback , scenario = None ) classmethod \u00b6 Unsubscribes a function that is called when the status of a Job changes. If scenario is not passed, the subscription is removed to all scenarios. Note The function will continue to be called for ongoing jobs. scenario_model \u00b6 ScenarioModel dataclass \u00b6 ScenarioModel(id: .new_type at 0x7fb9ed49f700>, name: str, pipelines: List[PipelineId], properties: dict, creation_date: str, master_scenario: bool, subscribers: List[Dict], cycle: Optional[CycleId] = None) scenario_repository \u00b6 ScenarioRepository ( FileSystemRepository ) \u00b6 storage_folder : Path property readonly \u00b6 Base folder used by repository to store data from_model ( self , model ) \u00b6 Converts a model to its functional object. to_model ( self , scenario ) \u00b6 Converts the object to be saved to its model. scheduler special \u00b6 abstract_scheduler \u00b6 AbstractScheduler \u00b6 Creates and schedules Jobs. Attributes: Name Type Description data_manager DataManager is an element that retrieves and deals with Data Node. executor special \u00b6 synchronous \u00b6 Synchronous ( Executor ) \u00b6 Equivalent to the Python standard Thread/Process Pool Executor but the function is executed directly. submit ( / , fn , * args , ** kwargs ) staticmethod \u00b6 Submits a callable to be executed with the given arguments. Schedules the callable to be executed as fn( args, *kwargs) and returns a Future instance representing the execution of the callable. Returns: Type Description A Future representing the given call. job_dispatcher \u00b6 JobDispatcher \u00b6 Wrapper around executor that will run jobs. Job can be executed on different contexts (locally, etc.). This wrapper instantiate the executor based on its args then deal with its low level interface to provide a homogeneous way to execute jobs. can_execute ( self ) \u00b6 Returns True if a worker is available for a new run. dispatch ( self , job ) \u00b6 Dispatches a Job on an available worker for execution. Parameters: Name Type Description Default job Job Element to execute. required scheduler \u00b6 Scheduler ( AbstractScheduler ) \u00b6 is_blocked ( obj ) staticmethod \u00b6 Returns True if the execution of the job or the task is blocked by the execution of another job. Parameters: Name Type Description Default obj Union[taipy.task.task.Task, taipy.job.job.Job] Task or Job. required Returns: Type Description bool True if one of its input data nodes is blocked. submit ( self , pipeline , callbacks = None , force = False ) \u00b6 Submit pipeline for execution. Parameters: Name Type Description Default pipeline Pipeline to be transformed into Job(s) for execution. required callbacks Optional[Iterable[Callable]] Optional list of functions that should be executed once the job is done. None force bool Boolean to enforce re execution of the tasks whatever the cache data nodes. False Returns: Type Description List[taipy.job.job.Job] The created Jobs. taipy \u00b6 Main module. Taipy \u00b6 Main Taipy class check_configuration () staticmethod \u00b6 Checks configuration. Returns: Type Description IssueCollector Collector containing the info, the warning and the error messages. clean_all_entities () staticmethod \u00b6 Deletes all entities from the data folder. Returns: Type Description bool True if the operation succeeded, False otherwise. compare_scenarios ( * scenarios , * , data_node_config_name = None ) classmethod \u00b6 Compares the data nodes of given scenarios with known datanode config name. Parameters: Name Type Description Default scenarios Scenario) Scenario objects to compare () data_node_config_name Optional[str]) config name of the DataNode to compare scenarios, if no datanode_config_name is provided, the scenarios will be compared based on all the previously defined comparators. None Exceptions: Type Description InsufficientScenarioToCompare Provided only one or no scenario for comparison NonExistingComparator The provided comparator does not exist DifferentScenarioConfigs The provided scenarios do not share the same scenario_config NonExistingScenarioConfig Cannot find the shared scenario config of the provided scenarios configure_data_node ( name , storage_type = 'pickle' , scope =< Scope . PIPELINE : 1 > , ** properties ) staticmethod \u00b6 Configures a new data node configuration. configure_default_data_node ( storage_type , scope =< Scope . PIPELINE : 1 > , ** properties ) staticmethod \u00b6 Configures the default behavior of a data node configuration. configure_default_pipeline ( task_configs , ** properties ) staticmethod \u00b6 Configures the default behavior of a pipeline configuration. configure_default_scenario ( pipeline_configs , frequency = None , comparators = None , ** properties ) staticmethod \u00b6 Configures the default behavior of a scenario configuration. configure_default_task ( input , function , output , ** properties ) staticmethod \u00b6 Configures the default behavior of a task configuration. configure_global_app ( notification = None , broker_endpoint = None , root_folder = None , storage_folder = None , clean_entities_enabled = None , ** properties ) staticmethod \u00b6 Configures fields related to global application. configure_job_executions ( mode = None , nb_of_workers = None , hostname = None , airflow_dags_folder = None , airflow_folder = None , start_airflow = None , airflow_api_retry = None , airflow_user = None , airflow_password = None , ** properties ) staticmethod \u00b6 Configures fields related to job execution. configure_pipeline ( name , task_configs , ** properties ) staticmethod \u00b6 Configures a new pipeline configuration. configure_scenario ( name , pipeline_configs , frequency = None , comparators = None , ** properties ) staticmethod \u00b6 Configures a new scenario configuration. configure_task ( name , input , function , output , ** properties ) staticmethod \u00b6 Configures a new task configuration. create_pipeline ( config ) classmethod \u00b6 Creates and Returns a new pipeline from the pipeline configuration given as parameter. Parameters: Name Type Description Default config PipelineConfig The pipeline configuration object. required create_scenario ( config , creation_date = None , name = None ) classmethod \u00b6 Creates and returns a new scenario from the scenario configuration provided as parameter. If the scenario belongs to a work cycle, the cycle (corresponding to the creation_date and the configuration frequency attribute) is created if it does not exist yet. Parameters: Name Type Description Default config ScenarioConfig) Scenario configuration object. required creation_date Optional[datetime.datetime]) Creation date. Current date time used as default value. None name Optional[str]) Display name of the scenario. None delete_job ( job , force = False ) classmethod \u00b6 Deletes the job if it is finished. Exceptions: Type Description JobNotDeletedException if the job is not finished. delete_jobs () classmethod \u00b6 Deletes all jobs. delete_pipeline ( pipeline_id ) classmethod \u00b6 Deletes the pipeline given as parameter and the nested tasks, data nodes, and jobs. Deletes the pipeline given as parameter and propagate the hard deletion. The hard delete is propagated to a nested task if the task is not shared by another pipeline. pipeline_id (PipelineId) : identifier of the pipeline to hard delete. ModelNotFound error if no pipeline corresponds to pipeline_id. delete_scenario ( scenario_id ) classmethod \u00b6 Deletes the scenario given as parameter and the nested pipelines, tasks, data nodes, and jobs. Deletes the scenario given as parameter and propagate the hard deletion. The hard delete is propagated to a nested pipeline if the pipeline is not shared by another scenario. scenario_id (ScenarioId) : identifier of the scenario to hard delete. ModelNotFound error if no scenario corresponds to scenario_id. export_configuration ( filename ) staticmethod \u00b6 Exports the configuration to a toml file. The configuration exported is the configuration applied. It is compiled from the three possible methods to configure the application: The python code configuration, the file configuration and the environment configuration. Parameters: Name Type Description Default filename str or Path File to export. required Note Overwrite the file if it already exists. get ( id ) classmethod \u00b6 Gets an entity given the identifier as parameter. Parameters: Name Type Description Default entity Union[TaskId, DataNodeId, PipelineId, ScenarioId] The identifier of the entity to get. required Returns: Type Description Union[taipy.task.task.Task, taipy.data.data_node.DataNode, taipy.pipeline.pipeline.Pipeline, taipy.scenario.scenario.Scenario, taipy.job.job.Job, taipy.cycle.cycle.Cycle] The entity corresponding to the provided identifier. Exceptions: Type Description ModelNotFound if no entity corresponds to entity_id . get_all_masters () classmethod \u00b6 Returns the list of all master scenarios. get_data_nodes () classmethod \u00b6 Returns the list of all existing data nodes. get_jobs () classmethod \u00b6 Gets all the existing jobs. Returns: Type Description List[taipy.job.job.Job] List of all jobs. get_latest_job ( task ) classmethod \u00b6 Gets the latest job of a task. Returns: Type Description Job The latest computed job of the task. get_master ( cycle ) classmethod \u00b6 Returns the master scenario of the cycle given as parameter. None if the cycle has no master scenario. Parameters: Name Type Description Default cycle Cycle) cycle of the master scenario to return. required get_pipelines () classmethod \u00b6 Returns all existing pipelines. Returns: Type Description List[Pipeline] the list of all pipelines managed by this pipeline manager. get_scenarios ( cycle = None ) classmethod \u00b6 Returns the list of all existing scenarios filtered by cycle if given as parameter. Parameters: Name Type Description Default cycle Optional[Cycle]) Cycle of the scenarios to return. None get_tasks () classmethod \u00b6 Returns the list of all existing tasks. Returns: Type Description List The list of tasks handled by this Task Manager. load_configuration ( filename ) staticmethod \u00b6 Loads configuration from file located at the filename given as parameter. Parameters: Name Type Description Default filename str or Path File to load. required set ( entity ) classmethod \u00b6 Saves or updates a data node, a task, a job, a pipeline, a scenario or a cycle. Parameters: Name Type Description Default entity Union[taipy.data.data_node.DataNode, taipy.task.task.Task, taipy.pipeline.pipeline.Pipeline, taipy.scenario.scenario.Scenario, taipy.cycle.cycle.Cycle] The entity to save. required set_master ( scenario ) classmethod \u00b6 Promotes scenario given as parameter as master scenario of its cycle. If the cycle already had a master scenario it will be demoted, and it will no longer be master for the cycle. Parameters: Name Type Description Default scenario Scenario) scenario to promote as master. required submit ( entity ) classmethod \u00b6 Submits the entity given as parameter for execution. All the tasks of the entity task/pipeline/scenario will be submitted for execution. Parameters: Name Type Description Default entity Union[Scenario, Pipeline]) the entity to submit. required subscribe_pipeline ( callback , pipeline = None ) classmethod \u00b6 Subscribes a function to be called when the status of a Job changes. If pipeline is not passed, the subscription is added to all pipelines. Note Notification will be available only for jobs created after this subscription. subscribe_scenario ( callback , scenario = None ) classmethod \u00b6 Subscribes a function to be called each time one of the provided scenario jobs changes status. If scenario is not passed, the subscription is added to all scenarios. Note Notification will be available only for jobs created after this subscription. unsubscribe_pipeline ( callback , pipeline = None ) classmethod \u00b6 Unsubscribes a function that is called when the status of a Job changes. If pipeline is not passed, the subscription is removed to all pipelines. Note The function will continue to be called for ongoing jobs. unsubscribe_scenario ( callback , scenario = None ) classmethod \u00b6 Unsubscribes a function that is called when the status of a Job changes. If scenario is not passed, the subscription is removed to all scenarios. Note The function will continue to be called for ongoing jobs. task special \u00b6 task \u00b6 Task \u00b6 Holds user function that will be executed, its parameters qs data nodes and outputs as data nodes. This element bring together the user code as function, parameters and outputs. Attributes: Name Type Description config_name Name that identifies the task config. We strongly recommend to use lowercase alphanumeric characters, dash character '-', or underscore character ' '. Note that other characters are replaced according the following rules : - Space character ' ' is replaced by ' '. - Unicode characters are replaced by a corresponding alphanumeric character using unicode library. - Other characters are replaced by dash character '-'. input Data node input as list. function Taking data from input data node and return data that should go inside of the output data node. output Data node output result of the function as optional list. id Unique identifier of this task. Generated if None . parent_id Identifier of the parent (pipeline_id, scenario_id, cycle_id) or None . scope : Scope property readonly \u00b6 Retrieve the lowest scope of the task based on its data node. Returns: Type Description Scope Lowest scope present in input and output data node or GLOBAL if there are no neither input or output. task_manager \u00b6 TaskManager \u00b6 The Task Manager saves and retrieves Tasks. Attributes: Name Type Description tasks Dict[(TaskId, Task)] A dictionary that associates every task with its identifier. scheduler AbstractScheduler The scheduler for submitting tasks. data_manager DataManager The Data Manager that interacts with data nodes. repository TaskRepository The repository where tasks are saved. delete ( task_id ) classmethod \u00b6 Deletes the cycle provided as parameter. Parameters: Name Type Description Default task_id str identifier of the task to delete. required delete_all () classmethod \u00b6 Deletes all the persisted tasks. get ( task ) classmethod \u00b6 Gets a task given the Task or the identifier. Parameters: Name Type Description Default task Union[Task, TaskId] The task identifier of the task to get. required Returns: Type Description Task The task with the provided identifier. Exceptions: Type Description ModelNotFound if no task corresponds to task_id . get_all () classmethod \u00b6 Returns the list of all existing tasks. Returns: Type Description List The list of tasks handled by this Task Manager. get_or_create ( task_config , scenario_id = None , pipeline_id = None ) classmethod \u00b6 Returns a task created from the provided task configuration. If no task exists for that task configuration, in the provided scenario_id and pipeline_id , then a new task is created and returned. Parameters: Name Type Description Default task_config TaskConfig The task configuration object. required scenario_id ScenarioId The identifier of the scenario creating the task. None pipeline_id PipelineId The identifier of the pipeline creating the task. None Returns: Type Description Task A task, potentially new, that is created for that task configuration. Exceptions: Type Description MultipleTaskFromSameConfigWithSameParent if more than one task already exists with the same configuration, and the same parent id (scenario or pipeline identifier, depending on the scope of the data node). TODO: This comment makes no sense - Data Node scope hard_delete ( task_id , scenario_id = None , pipeline_id = None ) classmethod \u00b6 Deletes the task given as parameter and the nested data nodes, and jobs. Deletes the task given as parameter and propagate the hard deletion. The hard delete is propagated to a nested data nodes if the data nodes is not shared by another pipeline or if a scenario id is given as parameter, by another scenario. task_id (TaskId): identifier of the task to hard delete. pipeline_id (PipelineId) : identifier of the optional parent pipeline. scenario_id (ScenarioId) : identifier of the optional parent scenario. ModelNotFound error if no pipeline corresponds to pipeline_id. set ( task ) classmethod \u00b6 Saves or updates a task. Parameters: Name Type Description Default task Task The task to save. required task_model \u00b6 TaskModel dataclass \u00b6 Hold the model of a Task. A model refers to the structure of a Task stored in a database. The tuple (config_name, parent_id) forms a unique key. Attributes: Name Type Description id str Identifier of a Data Node. parent_id Optional[str] Identifier of the parent (pipeline_id, scenario_id, cycle_id) or None . config_name str Name of the Data Node Config. input Input data node of the Task, saved as its ID string representation. function_name str Name of the task function. function_module str Module name of the task function. output Output data node of the Task, saved as its ID string representation. task_repository \u00b6 TaskRepository ( FileSystemRepository ) \u00b6 storage_folder : Path property readonly \u00b6 Base folder used by repository to store data from_model ( self , model ) \u00b6 Converts a model to its functional object. to_model ( self , task ) \u00b6 Converts the object to be saved to its model.","title":"Reference Manual"},{"location":"manuals/reference/#taipy-packages-and-classes","text":"Top-level package for Taipy.","title":"Taipy packages and classes"},{"location":"manuals/reference/#taipy.common","text":"","title":"common"},{"location":"manuals/reference/#taipy.common.frequency","text":"","title":"frequency"},{"location":"manuals/reference/#taipy.common.frequency.Frequency","text":"Enumeration representing the recurrence of a Scenario, and so the duration of its work cycle. The possible values are DAILY, WEEKLY, MONTHLY, QUARTERLY, YEARLY","title":"Frequency"},{"location":"manuals/reference/#taipy.common.repr_enum","text":"","title":"repr_enum"},{"location":"manuals/reference/#taipy.common.repr_enum.ReprEnum","text":"An enumeration.","title":"ReprEnum"},{"location":"manuals/reference/#taipy.config","text":"","title":"config"},{"location":"manuals/reference/#taipy.config.checker","text":"","title":"checker"},{"location":"manuals/reference/#taipy.config.checker.checker","text":"","title":"checker"},{"location":"manuals/reference/#taipy.config.checker.checker.Checker","text":"holds the various checks to perform on the config.","title":"Checker"},{"location":"manuals/reference/#taipy.config.checker.issue","text":"","title":"issue"},{"location":"manuals/reference/#taipy.config.checker.issue.Issue","text":"Dataclass representing an issue detected in the compiled configuration. Attributes: Name Type Description level str Level of the issue among ERROR, WARNING, INFO. field str Config field on which the issue has been detected. value Any Value of the field on which the issue has been detected. message str Readable message to help the user fix the issue. tag Optional[str] Optional tag to be used to filter issues.","title":"Issue"},{"location":"manuals/reference/#taipy.config.checker.issue_collector","text":"","title":"issue_collector"},{"location":"manuals/reference/#taipy.config.checker.issue_collector.IssueCollector","text":"Dataclass representing an issue detected in the compiled configuration. Attributes: Name Type Description errors List[Issue] List of error issues collected. warnings List[Issue] List warning issues collected. infos List[Issue] List info issues collected. all List[Issue] List of all issues collected ordered by decreasing level (Error, warning and info).","title":"IssueCollector"},{"location":"manuals/reference/#taipy.config.checker.issue_collector.IssueCollector.add_error","text":"Adds an issue with error level.","title":"add_error()"},{"location":"manuals/reference/#taipy.config.checker.issue_collector.IssueCollector.add_info","text":"Adds an issue with info level.","title":"add_info()"},{"location":"manuals/reference/#taipy.config.checker.issue_collector.IssueCollector.add_warning","text":"Adds an issue with warning level.","title":"add_warning()"},{"location":"manuals/reference/#taipy.config.config","text":"","title":"config"},{"location":"manuals/reference/#taipy.config.config.Config","text":"Singleton entry point to configure Taipy application and retrieve the configuration values.","title":"Config"},{"location":"manuals/reference/#taipy.config.config.Config.add_data_node","text":"Adds a new data node configuration.","title":"add_data_node()"},{"location":"manuals/reference/#taipy.config.config.Config.add_default_data_node","text":"Configures the default data node configuration.","title":"add_default_data_node()"},{"location":"manuals/reference/#taipy.config.config.Config.add_default_pipeline","text":"Configures the default pipeline configuration.","title":"add_default_pipeline()"},{"location":"manuals/reference/#taipy.config.config.Config.add_default_scenario","text":"Configures the default scenario configuration.","title":"add_default_scenario()"},{"location":"manuals/reference/#taipy.config.config.Config.add_default_task","text":"Configures the default task configuration.","title":"add_default_task()"},{"location":"manuals/reference/#taipy.config.config.Config.add_pipeline","text":"Adds a new pipeline configuration.","title":"add_pipeline()"},{"location":"manuals/reference/#taipy.config.config.Config.add_scenario","text":"Adds a new scenario configuration.","title":"add_scenario()"},{"location":"manuals/reference/#taipy.config.config.Config.add_task","text":"Adds a new task configuration.","title":"add_task()"},{"location":"manuals/reference/#taipy.config.config.Config.data_nodes","text":"Returns data node configs by config name.","title":"data_nodes()"},{"location":"manuals/reference/#taipy.config.config.Config.export","text":"Exports the configuration to a toml file. The configuration exported is the configuration applied. It is compiled from the three possible methods to configure the application: The python code configuration, the file configuration and the environment configuration. Parameters: Name Type Description Default filename str or Path File to export. required Note Overwrite the file if it already exists.","title":"export()"},{"location":"manuals/reference/#taipy.config.config.Config.export_code_config","text":"Exports the python code configuration as a toml file. Parameters: Name Type Description Default filename str File to export. required Note Overwrite the file if it already exists.","title":"export_code_config()"},{"location":"manuals/reference/#taipy.config.config.Config.global_config","text":"Returns configuration values related to the global application.","title":"global_config()"},{"location":"manuals/reference/#taipy.config.config.Config.job_config","text":"Returns configuration values related to the job executions.","title":"job_config()"},{"location":"manuals/reference/#taipy.config.config.Config.load","text":"Loads configuration from file located at the filename given as parameter. Parameters: Name Type Description Default filename str or Path File to load. required","title":"load()"},{"location":"manuals/reference/#taipy.config.config.Config.pipelines","text":"Returns pipeline configs by config name.","title":"pipelines()"},{"location":"manuals/reference/#taipy.config.config.Config.scenarios","text":"Returns scenario configs by config name.","title":"scenarios()"},{"location":"manuals/reference/#taipy.config.config.Config.set_global_config","text":"Configures fields related to global application.","title":"set_global_config()"},{"location":"manuals/reference/#taipy.config.config.Config.set_job_config","text":"Configures fields related to job execution.","title":"set_job_config()"},{"location":"manuals/reference/#taipy.config.config.Config.tasks","text":"Returns task configs by config name.","title":"tasks()"},{"location":"manuals/reference/#taipy.config.config_template_handler","text":"","title":"config_template_handler"},{"location":"manuals/reference/#taipy.config.config_template_handler.ConfigTemplateHandler","text":"Factory to handle actions related to config value templating.","title":"ConfigTemplateHandler"},{"location":"manuals/reference/#taipy.config.data_node_config","text":"","title":"data_node_config"},{"location":"manuals/reference/#taipy.config.data_node_config.DataNodeConfig","text":"Holds all the configuration fields needed to create actual data nodes from the DataNodeConfig. A Data Node config is made to be used as a generator for actual data nodes. It holds configuration information needed to create an actual data node. Attributes: Name Type Description name str Unique name as an identifier of the data node config. We strongly recommend to use lowercase alphanumeric characters, dash character '-', or underscore character ' '. Note that other characters are replaced according the following rules : - Space characters are replaced by underscore characters (' '). - Unicode characters are replaced by a corresponding alphanumeric character using the Unicode library. - Other characters are replaced by dash characters ('-'). storage_type str Storage type of the data nodes created from the data node config. The possible values are : \"csv\", \"excel\", \"pickle\", \"sql\" and \"In_memory\". Default value is \"pickle\". Note that the \"in_memory\" value can only be used when JobConfig.mode is \"standalone\". scope Scope The usage scope of the data nodes created from the data node config. Default value is Pipeline. properties dict Dictionary of additional properties.","title":"DataNodeConfig"},{"location":"manuals/reference/#taipy.config.global_app_config","text":"","title":"global_app_config"},{"location":"manuals/reference/#taipy.config.global_app_config.GlobalAppConfig","text":"Holds configuration fields related to the global application. Parameters: Name Type Description Default notification bool Boolean field to activate/deactivate the notification. Default value : false. None broker_endpoint str broker endpoint used for notification. Must be populated if notification is true. Default value is None. None root_folder str Path of the base folder for the taipy application. Default value is \"./taipy/\" None storage_folder str Folder name used to store Taipy data. Default value is \".data/\". It is used in conjunction with the root_folder field. That means the storage path is (Default path : \"./taipy/.data/\") None clean_entities_enabled bool Boolean field to activate/deactivate the clean entities feature. Default: false None properties dict Dictionary of additional properties. {}","title":"GlobalAppConfig"},{"location":"manuals/reference/#taipy.config.job_config","text":"","title":"job_config"},{"location":"manuals/reference/#taipy.config.job_config.JobConfig","text":"Holds configuration fields related to the job executions. Parameters: Name Type Description Default mode str Field representing the Taipy operating mode. Possible values are \"standalone\", \"airflow\". Default value: \"standalone\". None nb_of_workers int Maximum number of running workers to execute jobs. Must be a positive integer. Default value : 1 None hostname str Hostname. Default value is \"localhost\". None airflow_dags_folder str Folder name used to store the dags to be read by airflow if airflow mode is activated. Default value is \".dag/\". It is used in conjunction with the GlobalAppConfig.root_folder field. That means the path for the airflow dag folder is (Default path : \"./taipy/.dag/\"). None airflow_folder str Folder name used by airflow if airflow mode is activated. Default value is \".airflow/\". It is used in conjunction with the GlobalAppConfig.root_folder field. That means the path for the airflow dag folder is (Default path : \"./taipy/.airflow/\"). None start_airflow bool Allow Taipy to start Airflow if not alreay started. None airflow_api_retry int Retry pattern on Airflow APIs. None airflow_user str User name used with the REST API. Default value is \"admin\". None airflow_password str Password used with the REST API. Default value is get from standalone_admin_password.txt file created by Airflow on standalone mode. None properties dict Dictionary of additional properties. {}","title":"JobConfig"},{"location":"manuals/reference/#taipy.config.job_config.JobConfig.is_standalone","text":"True if the config is set to standalone execution","title":"is_standalone()"},{"location":"manuals/reference/#taipy.config.pipeline_config","text":"","title":"pipeline_config"},{"location":"manuals/reference/#taipy.config.pipeline_config.PipelineConfig","text":"Holds all the configuration fields needed to create actual pipelines from the PipelineConfig. Attributes: Name Type Description name str Unique name as an identifier of the pipeline config. We strongly recommend to use lowercase alphanumeric characters, dash character '-', or underscore character ' '. Note that other characters are replaced according the following rules : - Space characters are replaced by underscore characters (' '). - Unicode characters are replaced by a corresponding alphanumeric character using the Unicode library. - Other characters are replaced by dash characters ('-'). tasks list List of task configs. Default value: []. properties dict Dictionary of additional properties.","title":"PipelineConfig"},{"location":"manuals/reference/#taipy.config.scenario_config","text":"","title":"scenario_config"},{"location":"manuals/reference/#taipy.config.scenario_config.ScenarioConfig","text":"Holds all the configuration fields needed to create actual scenarios from the ScenarioConfig. Attributes: Name Type Description name str Unique name as an identifier of the scenario config. We strongly recommend to use lowercase alphanumeric characters, dash character '-', or underscore character ' '. Note that other characters are replaced according the following rules : - Space characters are replaced by underscore characters (' '). - Unicode characters are replaced by a corresponding alphanumeric character using the Unicode library. - Other characters are replaced by dash characters ('-'). pipelines list List of pipeline configs. Default value: []. properties dict Dictionary of additional properties.","title":"ScenarioConfig"},{"location":"manuals/reference/#taipy.config.task_config","text":"","title":"task_config"},{"location":"manuals/reference/#taipy.config.task_config.TaskConfig","text":"Holds all the configuration fields needed to create actual tasks from the TaskConfig. Attributes: Name Type Description name str Unique name as an identifier of the task config. We strongly recommend to use lowercase alphanumeric characters, dash character '-', or underscore character ' '. Note that other characters are replaced according the following rules : - Space characters are replaced by underscore characters (' '). - Unicode characters are replaced by a corresponding alphanumeric character using the Unicode library. - Other characters are replaced by dash characters ('-'). inputs list List of data node config inputs. Default value: []. outputs list List of data node config outputs. Default value: []. function Callable User function taking as inputs some parameters compatible with the exposed types (exposed_type field) of the inputs data nodes and returning results compatible with the exposed types (exposed_type field) of the outputs list. Default value: None. properties dict Dictionary of additional properties.","title":"TaskConfig"},{"location":"manuals/reference/#taipy.config.toml_serializer","text":"","title":"toml_serializer"},{"location":"manuals/reference/#taipy.config.toml_serializer.TomlSerializer","text":"Convert configuration from TOML representation to Python Dict and reciprocally.","title":"TomlSerializer"},{"location":"manuals/reference/#taipy.cycle","text":"","title":"cycle"},{"location":"manuals/reference/#taipy.cycle.cycle","text":"","title":"cycle"},{"location":"manuals/reference/#taipy.cycle.cycle.Cycle","text":"A Cycle object holds the frequency representing a work cycle. Attributes: Name Type Description frequency Frequency The frequency of the cycle properties dict[str, str] List of additional arguments. name str Name that identifies the cycle. creation_date datetime Date and time of the creation of the cycle start_date datetime Date and time of the start of the cycle end_date datetime Date and time of the end of the cycle id str Unique identifier of the cycle","title":"Cycle"},{"location":"manuals/reference/#taipy.cycle.cycle_manager","text":"","title":"cycle_manager"},{"location":"manuals/reference/#taipy.cycle.cycle_manager.CycleManager","text":"The Cycle Manager is responsible for managing all the cycle-related capabilities. This class provides methods for creating, storing, updating, retrieving and deleting cycles.","title":"CycleManager"},{"location":"manuals/reference/#taipy.cycle.cycle_manager.CycleManager.create","text":"Creates a new cycle. Parameters: Name Type Description Default frequency Frequency The frequency of the new cycle. required name str The name of the new cycle. Default: None . None creation_date datetime The date and time when the cycle is created. Default: None . None display_name Optional[str] The display name of the cycle. None properties dict[str, str] other properties. Default: None . {}","title":"create()"},{"location":"manuals/reference/#taipy.cycle.cycle_manager.CycleManager.delete","text":"Deletes a cycle. Parameters: Name Type Description Default cycle_id str The identifier of the cycle to be deleted. required Exceptions: Type Description ModelNotFound if no cycle corresponds to cycle_id .","title":"delete()"},{"location":"manuals/reference/#taipy.cycle.cycle_manager.CycleManager.delete_all","text":"Deletes all cycles.","title":"delete_all()"},{"location":"manuals/reference/#taipy.cycle.cycle_manager.CycleManager.get","text":"Gets the cycle corresponding to the identifier given as parameter. Parameters: Name Type Description Default cycle_id CycleId The identifier of the cycle to retrieve. required Exceptions: Type Description ModelNotFound if no cycle corresponds to cycle_id .","title":"get()"},{"location":"manuals/reference/#taipy.cycle.cycle_manager.CycleManager.get_all","text":"Returns all the existing cycles.","title":"get_all()"},{"location":"manuals/reference/#taipy.cycle.cycle_manager.CycleManager.get_or_create","text":"Returns a cycle with the provided parameters. If no cycle already exists with the provided parameter values, a new cycle is created and returned. Parameters: Name Type Description Default frequency Frequency The frequency of the cycle. required creation_date Optional[datetime] The creation date of the cycle. Default value : None . None display_name Optional[str] The display name of the cycle. None Returns: Type Description Cycle a cycle that has the indicated parameters. A new cycle may be created.","title":"get_or_create()"},{"location":"manuals/reference/#taipy.cycle.cycle_manager.CycleManager.set","text":"Saves or updates a cycle. Parameters: Name Type Description Default cycle Cycle The cycle to save. required","title":"set()"},{"location":"manuals/reference/#taipy.cycle.cycle_model","text":"","title":"cycle_model"},{"location":"manuals/reference/#taipy.cycle.cycle_model.CycleModel","text":"CycleModel(id: .new_type at 0x7fb9ed49fc10>, name: str, frequency: taipy.common.frequency.Frequency, properties: dict, creation_date: str, start_date: str, end_date: str)","title":"CycleModel"},{"location":"manuals/reference/#taipy.cycle.cycle_repository","text":"","title":"cycle_repository"},{"location":"manuals/reference/#taipy.cycle.cycle_repository.CycleRepository","text":"","title":"CycleRepository"},{"location":"manuals/reference/#taipy.cycle.cycle_repository.CycleRepository.storage_folder","text":"Base folder used by repository to store data","title":"storage_folder"},{"location":"manuals/reference/#taipy.cycle.cycle_repository.CycleRepository.from_model","text":"Converts a model to its functional object.","title":"from_model()"},{"location":"manuals/reference/#taipy.cycle.cycle_repository.CycleRepository.to_model","text":"Converts the object to be saved to its model.","title":"to_model()"},{"location":"manuals/reference/#taipy.data","text":"","title":"data"},{"location":"manuals/reference/#taipy.data.csv","text":"","title":"csv"},{"location":"manuals/reference/#taipy.data.csv.CSVDataNode","text":"A Data Node stored as a CSV file. Attributes: Name Type Description config_name str Name that identifies the data node. We strongly recommend to use lowercase alphanumeric characters, dash character '-', or underscore character ' '. Note that other characters are replaced according the following rules : - Space characters are replaced by underscore characters (' '). - Unicode characters are replaced by a corresponding alphanumeric character using the Unicode library. - Other characters are replaced by dash characters ('-'). scope Scope The usage scope of this data node. id str Unique identifier of this data node. name str User-readable name of the data node. parent_id str Identifier of the parent (pipeline_id, scenario_id, cycle_id) or None . last_edition_date datetime Date and time of the last edition. job_ids List[str] Ordered list of jobs that have written this data node. up_to_date bool True if the data is considered as up to date. False otherwise. properties dict Dict of additional arguments. Note that the properties parameter should at least contain a value for \"path\" properties.","title":"CSVDataNode"},{"location":"manuals/reference/#taipy.data.data_manager","text":"","title":"data_manager"},{"location":"manuals/reference/#taipy.data.data_manager.DataManager","text":"A Data Manager is responsible for all managing data node related capabilities. In particular, it is exposing methods for creating, storing, updating, retrieving, deleting data nodes.","title":"DataManager"},{"location":"manuals/reference/#taipy.data.data_manager.DataManager.delete","text":"Deletes the data node provided as parameter. Parameters: Name Type Description Default data_node_id str) identifier of the data node to delete. required Exceptions: Type Description ModelNotFound Raised if no data node corresponds to data_node_id.","title":"delete()"},{"location":"manuals/reference/#taipy.data.data_manager.DataManager.delete_all","text":"Deletes all data nodes.","title":"delete_all()"},{"location":"manuals/reference/#taipy.data.data_manager.DataManager.get","text":"Gets the data node corresponding to the DataNode or the identifier given as parameter. Parameters: Name Type Description Default data_node Union[DataNode, DataNodeId]) data node to get. required Exceptions: Type Description ModelNotFound Raised if no data node corresponds to data_node_id.","title":"get()"},{"location":"manuals/reference/#taipy.data.data_manager.DataManager.get_all","text":"Returns the list of all existing data nodes.","title":"get_all()"},{"location":"manuals/reference/#taipy.data.data_manager.DataManager.get_or_create","text":"Gets or creates a Data Node. Returns the data node created from the data_node_config, by (pipeline_id and scenario_id) if it already exists, or creates and returns a new data_node. Parameters: Name Type Description Default data_node_config DataNodeConfig) data node configuration object. required scenario_id Optional[ScenarioId]) id of the scenario creating the data node. None pipeline_id Optional[PipelineId]) id of the pipeline creating the data node. None Exceptions: Type Description MultipleDataNodeFromSameConfigWithSameParent Raised if more than 1 data node already exist with same config, and the same parent id (scenario_id, or pipeline_id depending on the scope of the data node). InvalidDataNodeType Raised if the type of the data node config is invalid.","title":"get_or_create()"},{"location":"manuals/reference/#taipy.data.data_manager.DataManager.set","text":"Saves or Updates the data node given as parameter. Parameters: Name Type Description Default data_node DataNode) data node to save or update. required","title":"set()"},{"location":"manuals/reference/#taipy.data.data_model","text":"","title":"data_model"},{"location":"manuals/reference/#taipy.data.data_model.DataNodeModel","text":"The model of a DataNode. A model refers to the structure of a Data Node stored in a database. Attributes: Name Type Description id str Identifier of a DataNode. config_name int Name of the DataNodeConfig . scope taipy.data.node.scope.Scope Scope of the usage of a DataNode. type str Name of the class that represents a DataNode. name str User-readable name of the data node. parent_id str Identifier of the parent (pipeline_id, scenario_id, cycle_id) or None . last_edition_date str ISO format of the last edition date and time. job_ids List[str] List of jobs that computed the data node. edition_in_progress bool True if a task computing this data node has been submitted and not completed yet. False otherwise. data_node_properties Dict[str, Any] Additional properties of the data node. Note The tuple (config_name, parent_id) forms a unique key.","title":"DataNodeModel"},{"location":"manuals/reference/#taipy.data.data_node","text":"","title":"data_node"},{"location":"manuals/reference/#taipy.data.data_node.DataNode","text":"Data Node represents a reference to a dataset but not the data itself. A Data Node holds meta data related to the dataset it refers. In particular, a data node holds the name, the scope, the parent_id, the last edition date and additional properties of the data. A data Node is also made to contain information and methods needed to access the dataset. This information depends on the type of storage and it is hold by children classes (such as SQL Data Node, CSV Data Node, ...). It is strongly recommended to only instantiate children classes of Data Node through a Data Manager. Attributes: Name Type Description config_name str Name that identifies the data node. We strongly recommend to use lowercase alphanumeric characters, dash character '-', or underscore character ' '. Note that other characters are replaced according the following rules : - Space characters are replaced by underscore characters (' '). - Unicode characters are replaced by a corresponding alphanumeric character using the Unicode library. - Other characters are replaced by dash characters ('-'). scope Scope The usage scope of this data node. id str Unique identifier of this data node. name str User-readable name of the data node. parent_id str Identifier of the parent (pipeline_id, scenario_id, cycle_id) or None . last_edition_date datetime Date and time of the last edition. job_ids List[str] Ordered list of jobs that have written this data node. validity_days Optional[int] Number of days to be added to the data node validity duration. If validity_days, validity_hours, and validity_minutes are all set to None, The data_node is always up to date. validity_hours Optional[int] Number of hours to be added to the data node validity duration. If validity_days, validity_hours, and validity_minutes are all set to None, The data_node is always up to date. validity_minutes Optional[int] Number of minutes to be added to the data node validity duration. If validity_days, validity_hours, and validity_minutes are all set to None, The data_node is always up to date. edition_in_progress bool) True if a task computing the data node has been submitted and not completed yet. False otherwise. properties dict Dict of additional arguments.","title":"DataNode"},{"location":"manuals/reference/#taipy.data.data_node.DataNode.filter","text":"Filter data based on the provided list of tuples (key, value, operator) If mulitple filter operators, filtered data will be joined based on the join operator (AND or OR)","title":"filter()"},{"location":"manuals/reference/#taipy.data.data_node.DataNode.validity","text":"Number of minutes where the Data Node is up-to-date.","title":"validity()"},{"location":"manuals/reference/#taipy.data.data_repository","text":"","title":"data_repository"},{"location":"manuals/reference/#taipy.data.data_repository.DataRepository","text":"","title":"DataRepository"},{"location":"manuals/reference/#taipy.data.data_repository.DataRepository.storage_folder","text":"Base folder used by repository to store data","title":"storage_folder"},{"location":"manuals/reference/#taipy.data.data_repository.DataRepository.from_model","text":"Converts a model to its functional object.","title":"from_model()"},{"location":"manuals/reference/#taipy.data.data_repository.DataRepository.to_model","text":"Converts the object to be saved to its model.","title":"to_model()"},{"location":"manuals/reference/#taipy.data.excel","text":"","title":"excel"},{"location":"manuals/reference/#taipy.data.excel.ExcelDataNode","text":"A Data Node stored as an Excel file (xlsx format). Attributes: Name Type Description config_name str Name that identifies the data node. We strongly recommend to use lowercase alphanumeric characters, dash character '-', or underscore character ' '. Note that other characters are replaced according the following rules : - Space characters are replaced by underscore characters (' '). - Unicode characters are replaced by a corresponding alphanumeric character using the Unicode library. - Other characters are replaced by dash characters ('-'). scope Scope The usage scope of this data node. id str Unique identifier of this data node. name str User-readable name of the data node. parent_id str Identifier of the parent (pipeline_id, scenario_id, cycle_id) or None . last_edition_date datetime Date and time of the last edition. job_ids List[str] Ordered list of jobs that have written this data node. up_to_date bool True if the data is considered as up to date. False otherwise. properties dict Dict of additional arguments. Note that the properties parameter should at least contain a value for \"path\" properties.","title":"ExcelDataNode"},{"location":"manuals/reference/#taipy.data.in_memory","text":"","title":"in_memory"},{"location":"manuals/reference/#taipy.data.in_memory.InMemoryDataNode","text":"A Data Node stored in memory. This Data Node implementation is not compatible with a parallel execution of taipy tasks, but only with a Synchronous task executor. The purpose of InMemoryDataNode is to be used for development or debug. Attributes: Name Type Description config_name str Name that identifies the data node. We strongly recommend to use lowercase alphanumeric characters, dash character '-', or underscore character ' '. Note that other characters are replaced according the following rules : - Space characters are replaced by underscore characters (' '). - Unicode characters are replaced by a corresponding alphanumeric character using the Unicode library. - Other characters are replaced by dash characters ('-'). scope Scope The usage scope of this data node. id str Unique identifier of this data node. name str User-readable name of the data node. parent_id str Identifier of the parent (pipeline_id, scenario_id, cycle_id) or None . last_edition_date datetime Date and time of the last edition. job_ids List[str] Ordered list of jobs that have written this data node. up_to_date bool True if the data is considered as up to date. False otherwise. properties dict Dict of additional arguments. Note that at the creation of the In Memory data node, if the property default_data is present, the data node is automatically written with the corresponding default_data value.","title":"InMemoryDataNode"},{"location":"manuals/reference/#taipy.data.operator","text":"","title":"operator"},{"location":"manuals/reference/#taipy.data.operator.JoinOperator","text":"An enumeration.","title":"JoinOperator"},{"location":"manuals/reference/#taipy.data.operator.Operator","text":"The operator of filtering of a Data Node.","title":"Operator"},{"location":"manuals/reference/#taipy.data.pickle","text":"","title":"pickle"},{"location":"manuals/reference/#taipy.data.pickle.PickleDataNode","text":"A Data Node stored as a pickle file. Attributes: Name Type Description config_name str Name that identifies the data node. We strongly recommend to use lowercase alphanumeric characters, dash character '-', or underscore character ' '. Note that other characters are replaced according the following rules : - Space characters are replaced by underscore characters (' '). - Unicode characters are replaced by a corresponding alphanumeric character using the Unicode library. - Other characters are replaced by dash characters ('-'). scope Scope The usage scope of this data node. id str Unique identifier of this data node. name str User-readable name of the data node. parent_id str Identifier of the parent (pipeline_id, scenario_id, cycle_id) or None . last_edition_date datetime Date and time of the last edition. job_ids List[str] Ordered list of jobs that have written this data node. up_to_date bool True if the data is considered as up to date. False otherwise. properties dict Dict of additional arguments. Note that at the creation of the data node, if the property \"default_data\" is present, the data node is automatically written with the corresponding default_data value. If the property \"path\" is present, data will be stored using the corresponding value as the name of the file.","title":"PickleDataNode"},{"location":"manuals/reference/#taipy.data.scope","text":"","title":"scope"},{"location":"manuals/reference/#taipy.data.scope.OrderedEnum","text":"An enumeration.","title":"OrderedEnum"},{"location":"manuals/reference/#taipy.data.scope.Scope","text":"The scope of usage of a Data Node.","title":"Scope"},{"location":"manuals/reference/#taipy.data.sql","text":"","title":"sql"},{"location":"manuals/reference/#taipy.data.sql.SQLDataNode","text":"A Data Node stored as a SQL database. Attributes: Name Type Description config_name str Name that identifies the data node. We strongly recommend to use lowercase alphanumeric characters, dash character '-', or underscore character ' '. Note that other characters are replaced according the following rules : - Space characters are replaced by underscore characters (' '). - Unicode characters are replaced by a corresponding alphanumeric character using the Unicode library. - Other characters are replaced by dash characters ('-'). scope Scope The usage scope of this data node. id str Unique identifier of this data node. name str User-readable name of the data node. parent_id str Identifier of the parent (pipeline_id, scenario_id, cycle_id) or None . last_edition_date datetime Date and time of the last edition. job_ids List[str] Ordered list of jobs that have written this data node. edition_in_progress bool True if a task computing the data node has been submitted and not completed yet. False otherwise. properties dict Dict of additional arguments. Note that properties should at least contain values for \"db_username\", \"db_password\", \"db_name\", \"db_engine\" and \"query\" properties.","title":"SQLDataNode"},{"location":"manuals/reference/#taipy.exceptions","text":"","title":"exceptions"},{"location":"manuals/reference/#taipy.exceptions.configuration","text":"","title":"configuration"},{"location":"manuals/reference/#taipy.exceptions.configuration.ConfigurationIssueError","text":"Raised if an inconsistency has been detected in the configuration.","title":"ConfigurationIssueError"},{"location":"manuals/reference/#taipy.exceptions.configuration.InconsistentEnvVariableError","text":"Inconsistency value has been detected in an environment variable referenced by the configuration.","title":"InconsistentEnvVariableError"},{"location":"manuals/reference/#taipy.exceptions.configuration.LoadingError","text":"Raised if an error occurs while loading the configuration file.","title":"LoadingError"},{"location":"manuals/reference/#taipy.exceptions.configuration.MissingEnvVariableError","text":"Environment variable referenced in configuration is missing.","title":"MissingEnvVariableError"},{"location":"manuals/reference/#taipy.exceptions.cycle","text":"","title":"cycle"},{"location":"manuals/reference/#taipy.exceptions.cycle.CycleAlreadyExists","text":"Exception raised if it is trying to create a Cycle that has already exists","title":"CycleAlreadyExists"},{"location":"manuals/reference/#taipy.exceptions.cycle.NonExistingCycle","text":"Exception raised if we request a cycle not known by the cycle manager.","title":"NonExistingCycle"},{"location":"manuals/reference/#taipy.exceptions.data_node","text":"","title":"data_node"},{"location":"manuals/reference/#taipy.exceptions.data_node.InvalidDataNodeType","text":"Raised if a data node does not exist.","title":"InvalidDataNodeType"},{"location":"manuals/reference/#taipy.exceptions.data_node.MissingRequiredProperty","text":"Raised if a required property is missing when creating a Data Node.","title":"MissingRequiredProperty"},{"location":"manuals/reference/#taipy.exceptions.data_node.MultipleDataNodeFromSameConfigWithSameParent","text":"Raised if there are multiple data nodes from the same data node configuration and the same parent identifier.","title":"MultipleDataNodeFromSameConfigWithSameParent"},{"location":"manuals/reference/#taipy.exceptions.data_node.NoData","text":"Raised when reading a data node before it has been written.","title":"NoData"},{"location":"manuals/reference/#taipy.exceptions.data_node.NonExistingDataNode","text":"Raised if a requested DataNode is not known by the DataNode Manager.","title":"NonExistingDataNode"},{"location":"manuals/reference/#taipy.exceptions.data_node.NonExistingExcelSheet","text":"Raised if a requested Sheet name does not exist in the provided Excel file.","title":"NonExistingExcelSheet"},{"location":"manuals/reference/#taipy.exceptions.data_node.NotMatchSheetNameAndCustomObject","text":"Raised if a provided list of sheet names does not match with the provided list of custom objects.","title":"NotMatchSheetNameAndCustomObject"},{"location":"manuals/reference/#taipy.exceptions.data_node.UnknownDatabaseEngine","text":"Exception raised when creating a connection with a SQLDataNode","title":"UnknownDatabaseEngine"},{"location":"manuals/reference/#taipy.exceptions.job","text":"","title":"job"},{"location":"manuals/reference/#taipy.exceptions.job.DataNodeWritingError","text":"Raised if an error happens during the writing in a data node.","title":"DataNodeWritingError"},{"location":"manuals/reference/#taipy.exceptions.job.InvalidSubscriber","text":"Raised if we try to load a function that is not valid.","title":"InvalidSubscriber"},{"location":"manuals/reference/#taipy.exceptions.job.JobNotDeletedException","text":"Raised if we try to delete a job that cannot be deleted.","title":"JobNotDeletedException"},{"location":"manuals/reference/#taipy.exceptions.job.NonExistingJob","text":"Raised if we try to get a job that does not exist.","title":"NonExistingJob"},{"location":"manuals/reference/#taipy.exceptions.pipeline","text":"","title":"pipeline"},{"location":"manuals/reference/#taipy.exceptions.pipeline.MultiplePipelineFromSameConfigWithSameParent","text":"Exception raised if it exists multiple pipelines from the same pipeline config and with the same parent_id","title":"MultiplePipelineFromSameConfigWithSameParent"},{"location":"manuals/reference/#taipy.exceptions.pipeline.NonExistingPipeline","text":"Raised if a requested Pipeline is not known by the Pipeline Manager.","title":"NonExistingPipeline"},{"location":"manuals/reference/#taipy.exceptions.pipeline.NonExistingPipelineConfig","text":"Raised if a requested Pipeline configuration is not known by the Pipeline Manager.","title":"NonExistingPipelineConfig"},{"location":"manuals/reference/#taipy.exceptions.repository","text":"","title":"repository"},{"location":"manuals/reference/#taipy.exceptions.repository.ModelNotFound","text":"Raised when trying to fetch a non existent model.","title":"ModelNotFound"},{"location":"manuals/reference/#taipy.exceptions.scenario","text":"","title":"scenario"},{"location":"manuals/reference/#taipy.exceptions.scenario.DeletingMasterScenario","text":"Raised when trying to remove a master scenario","title":"DeletingMasterScenario"},{"location":"manuals/reference/#taipy.exceptions.scenario.DifferentScenarioConfigs","text":"Scenarios must contains the same config","title":"DifferentScenarioConfigs"},{"location":"manuals/reference/#taipy.exceptions.scenario.DoesNotBelongToACycle","text":"Raised when setting a scenario to be the master scenario but it doesn't belong to any cycle","title":"DoesNotBelongToACycle"},{"location":"manuals/reference/#taipy.exceptions.scenario.InsufficientScenarioToCompare","text":"Must provide at least 2 scenarios for scenario comparison","title":"InsufficientScenarioToCompare"},{"location":"manuals/reference/#taipy.exceptions.scenario.NonExistingComparator","text":"Must provide an existing comparator","title":"NonExistingComparator"},{"location":"manuals/reference/#taipy.exceptions.scenario.NonExistingScenario","text":"Raised when a requested scenario is not known by the Scenario Manager.","title":"NonExistingScenario"},{"location":"manuals/reference/#taipy.exceptions.scenario.NonExistingScenarioConfig","text":"Raised when a requested scenario configuration is not known by the Scenario Manager.","title":"NonExistingScenarioConfig"},{"location":"manuals/reference/#taipy.exceptions.task","text":"","title":"task"},{"location":"manuals/reference/#taipy.exceptions.task.MultipleTaskFromSameConfigWithSameParent","text":"Raised if there are multiple tasks from the same task configuration and the same parent identifier.","title":"MultipleTaskFromSameConfigWithSameParent"},{"location":"manuals/reference/#taipy.exceptions.task.NonExistingTask","text":"Raised when a requested task is not known by the Task Manager.","title":"NonExistingTask"},{"location":"manuals/reference/#taipy.exceptions.task.NonExistingTaskConfig","text":"Raised when a requested task configuration is not known by the Task Manager.","title":"NonExistingTaskConfig"},{"location":"manuals/reference/#taipy.gui","text":"","title":"gui"},{"location":"manuals/reference/#taipy.gui--gui-package-graphical-user-interface","text":"The Graphical User Interface module of Taipy lets you run a Web server that a Web browser can connect to. The server generates Web pages on the fly, configured by the application developer. Each page can contain regular text and images, as well as Taipy controls that are typically linked to some value that is managed by the whole Taipy application.","title":"gui package: Graphical User Interface"},{"location":"manuals/reference/#taipy.gui.data","text":"","title":"data"},{"location":"manuals/reference/#taipy.gui.data.data_format","text":"","title":"data_format"},{"location":"manuals/reference/#taipy.gui.data.data_format.DataFormat","text":"An enumeration.","title":"DataFormat"},{"location":"manuals/reference/#taipy.gui.gui","text":"","title":"gui"},{"location":"manuals/reference/#taipy.gui.gui.Gui","text":"The class that handles the Graphical User Interface. Attributes: Name Type Description on_action t.FunctionType The default function that is called when a control triggers an action, as the result of an interaction with the end-user. on_change t.FunctionType The function that is called when a control modifies the variable it is bound to, as the result of an interaction with the end-user.","title":"Gui"},{"location":"manuals/reference/#taipy.gui.gui.Gui.__init__","text":"Initializes a new Gui instance. Parameters: Name Type Description Default page t.Union[str, PageRenderer] An optional PageRenderer instance that is used when there is a single page in this interface, referenced as the root page (located at / ). If page is a raw string, a Markdown page renderer is built from that string. Note that if pages is provided, those pages are added as well. None css_file string An optional pathname to a CSS file that gets used as a style sheet in all the pages. The default value is a file that has the same base name as the Python file defining the main function, sitting next to this Python file, with the .css extension. '__main__'","title":"__init__()"},{"location":"manuals/reference/#taipy.gui.gui.Gui.block_ui","text":"Blocks the UI Parameters: Name Type Description Default action string | function The action to be carried on cancel. If empty string or None, no Cancel action will be provided to the user. required message string The message to show. Default: Work in Progress... 'Work in Progress...'","title":"block_ui()"},{"location":"manuals/reference/#taipy.gui.gui.Gui.navigate","text":"Navigate to a page Parameters: Name Type Description Default to t.Optional[str] page to navigate to. Should be a valid page identifier. If ommitted, navigates to the root page. ''","title":"navigate()"},{"location":"manuals/reference/#taipy.gui.gui.Gui.run","text":"Starts the server that delivers pages to Web clients. Once you enter run , users can run Web browsers and point to the Web server URL that Gui serves. The default is to listen to the localhost address (127.0.0.1) on the port number 5000. However, the configuration of the Gui object may impact that (see TODO-Configuration-TODO). Parameters: Name Type Description Default run_server bool whether or not to run a Web server locally. If set to False , a Web server is not created and started. True","title":"run()"},{"location":"manuals/reference/#taipy.gui.gui.Gui.show_notification","text":"Sends a notification to the user interface. Parameters: Name Type Description Default type string The notification type. This can be one of \"success\" , \"info\" , \"warning\" or \"error\" . To remove the last notification, set this parameter to the empty string. 'I' message string The text message to display. '' browser_notification bool If set to True , the browser will also show the notification. If not specified or set to None , this parameter will user the value of app_config[browser_notification] . None duration t.Optional[int] The time, in milliseconds, during which the notification is shown. If not specified or set to None , this parameter will user the value of app_config[notification_duration] . None Note that you can also call this function with type set to the first letter or the alert type (ie setting type to \"i\" is equivalent to setting it to \"info\" ).","title":"show_notification()"},{"location":"manuals/reference/#taipy.gui.gui.Gui.unblock_ui","text":"Unblocks the UI","title":"unblock_ui()"},{"location":"manuals/reference/#taipy.gui.page","text":"","title":"page"},{"location":"manuals/reference/#taipy.gui.page.Page","text":"A page that can be served by a Gui instance. In order for Gui to serve pages to a Web browser, you must create instances of Page . Every page has a name, so it can be located in the address bar of the browser, and some content that is generated from a text template. Attributes: Name Type Description renderer PageRenderer The renderer to be used for this page. route string The name of this page. style string TBD head t.Union[str, None] TBD","title":"Page"},{"location":"manuals/reference/#taipy.gui.renderers","text":"","title":"renderers"},{"location":"manuals/reference/#taipy.gui.renderers.Html","text":"The page renderer for HTML text.","title":"Html"},{"location":"manuals/reference/#taipy.gui.renderers.Html.__init__","text":"Initializes a new Html page renderer. Parameters: Name Type Description Default content string The text content or the path to the file holding the HTML text to be transformed. required","title":"__init__()"},{"location":"manuals/reference/#taipy.gui.renderers.Markdown","text":"The page renderer for Markdown text.","title":"Markdown"},{"location":"manuals/reference/#taipy.gui.renderers.Markdown.__init__","text":"Initializes a new Markdown page renderer. Parameters: Name Type Description Default content string The text content or the path to the file holding the Markdown text to be transformed. required","title":"__init__()"},{"location":"manuals/reference/#taipy.gui.renderers.PageRenderer","text":"The base class that transform template text to actual pages that can be displayed on a Web browser. When a page is requested to be displayed, it is transformed into HTML code that can be sent to the client. All control placeholders are replaced by the appropriate graphical component so you can display your application variables, and potentially interact with them.","title":"PageRenderer"},{"location":"manuals/reference/#taipy.gui.renderers.PageRenderer.__init__","text":"Initializes a new PageRenderer with the indicated content. Parameters: Name Type Description Default content string The text content or the path to the file holding the text to be transformed. required If content is a path to a readable file, the file is read entirely as the text template.","title":"__init__()"},{"location":"manuals/reference/#taipy.gui.renderers.jsonencoder","text":"","title":"jsonencoder"},{"location":"manuals/reference/#taipy.gui.renderers.jsonencoder.TaipyJsonEncoder","text":"","title":"TaipyJsonEncoder"},{"location":"manuals/reference/#taipy.gui.renderers.jsonencoder.TaipyJsonEncoder.default","text":"Implement this method in a subclass such that it returns a serializable object for o , or calls the base implementation (to raise a TypeError ). For example, to support arbitrary iterators, you could implement default like this:: def default(self, o): !!! try iterable = iter(o) except TypeError: pass !!! else return list(iterable) # Let the base class default method raise the TypeError return JSONEncoder.default(self, o)","title":"default()"},{"location":"manuals/reference/#taipy.gui.types","text":"","title":"types"},{"location":"manuals/reference/#taipy.gui.types.AttributeType","text":"An enumeration.","title":"AttributeType"},{"location":"manuals/reference/#taipy.gui.types.WsType","text":"An enumeration.","title":"WsType"},{"location":"manuals/reference/#taipy.gui.utils","text":"","title":"utils"},{"location":"manuals/reference/#taipy.gui.utils.killable_thread","text":"","title":"killable_thread"},{"location":"manuals/reference/#taipy.gui.utils.killable_thread.KillableThread","text":"","title":"KillableThread"},{"location":"manuals/reference/#taipy.gui.utils.killable_thread.KillableThread.start","text":"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object.","title":"start()"},{"location":"manuals/reference/#taipy.job","text":"","title":"job"},{"location":"manuals/reference/#taipy.job.job","text":"","title":"job"},{"location":"manuals/reference/#taipy.job.job.Job","text":"Execution of a Task. A Job is the execution wrapper around a Task. It handles the status of the execution, contains raising exceptions during the execution and notifies subscriber when the job is finished. Attributes: Name Type Description id Id of the Job. task Task that is executed by the job. force Boolean to enforce the execution whatever the cache data nodes. status Current status of the job. creation_date Date of the object creation.","title":"Job"},{"location":"manuals/reference/#taipy.job.job.Job.exceptions","text":"Contains exceptions raised during the execution. Returns: Type Description List[Exception] Exceptions raised as list.","title":"exceptions"},{"location":"manuals/reference/#taipy.job.job.Job.__contains__","text":"Returns true if the Job contains a specific task. Returns: Type Description True if the Job is based on this task.","title":"__contains__()"},{"location":"manuals/reference/#taipy.job.job.Job.is_blocked","text":"Returns true if the job is blocked. Returns: Type Description bool True if the job is blocked.","title":"is_blocked()"},{"location":"manuals/reference/#taipy.job.job.Job.is_cancelled","text":"Returns true if the job is cancelled. Returns: Type Description bool True if the job is cancelled.","title":"is_cancelled()"},{"location":"manuals/reference/#taipy.job.job.Job.is_completed","text":"Returns true if the job is completed. Returns: Type Description bool True if the job is completed.","title":"is_completed()"},{"location":"manuals/reference/#taipy.job.job.Job.is_failed","text":"Returns true if the job failed. Returns: Type Description bool True if the job has failed.","title":"is_failed()"},{"location":"manuals/reference/#taipy.job.job.Job.is_finished","text":"Returns true if the job is finished. Returns: Type Description bool True if the job is finished.","title":"is_finished()"},{"location":"manuals/reference/#taipy.job.job.Job.is_pending","text":"Returns true if the job is pending. Returns: Type Description bool True if the job is pending.","title":"is_pending()"},{"location":"manuals/reference/#taipy.job.job.Job.is_running","text":"Returns true if the job is running. Returns: Type Description bool True if the job is running.","title":"is_running()"},{"location":"manuals/reference/#taipy.job.job.Job.is_skipped","text":"Returns true if the job is skipped. Returns: Type Description bool True if the job is skipped.","title":"is_skipped()"},{"location":"manuals/reference/#taipy.job.job.Job.is_submitted","text":"Returns true if the job is submitted. Returns: Type Description bool True if the job is submitted.","title":"is_submitted()"},{"location":"manuals/reference/#taipy.job.job.Job.on_status_change","text":"Allows to be notified when the status of the job changes. Job passing through multiple statuses (Submitted, pending, etc.) before being finished. You can be triggered on each change through this function unless for the Submitted status. Parameters: Name Type Description Default functions Callables that will be called on each status change. ()","title":"on_status_change()"},{"location":"manuals/reference/#taipy.job.job.Job.update_status","text":"Update the Job status based on if an exception was raised or not.","title":"update_status()"},{"location":"manuals/reference/#taipy.job.job_manager","text":"","title":"job_manager"},{"location":"manuals/reference/#taipy.job.job_manager.JobManager","text":"The Job Manager is responsible for managing all the job-related capabilities. This class provides methods for creating, storing, updating, retrieving and deleting jobs.","title":"JobManager"},{"location":"manuals/reference/#taipy.job.job_manager.JobManager.create","text":"Returns a new job representing a unique execution of the provided task. Parameters: Name Type Description Default task Task The task to execute. required callbacks Iterable[Callable] Iterable of callable to be executed on job status change. required force Boolean to enforce re execution of the task whatever the cache of the output data nodes. False Returns: Type Description Job A new job, that is created for executing given task.","title":"create()"},{"location":"manuals/reference/#taipy.job.job_manager.JobManager.delete","text":"Deletes the job if it is finished. Exceptions: Type Description JobNotDeletedException if the job is not finished.","title":"delete()"},{"location":"manuals/reference/#taipy.job.job_manager.JobManager.delete_all","text":"Deletes all jobs.","title":"delete_all()"},{"location":"manuals/reference/#taipy.job.job_manager.JobManager.get","text":"Gets the job from the job id given as parameter. Returns: Type Description Job The Job corresponding to the id. Exceptions: Type Description NonExistingJob if not found.","title":"get()"},{"location":"manuals/reference/#taipy.job.job_manager.JobManager.get_all","text":"Gets all the existing jobs. Returns: Type Description List[taipy.job.job.Job] List of all jobs.","title":"get_all()"},{"location":"manuals/reference/#taipy.job.job_manager.JobManager.get_latest","text":"Allows to retrieve the latest computed job of a task. Returns: Type Description Job The latest computed job of the task.","title":"get_latest()"},{"location":"manuals/reference/#taipy.job.job_manager.JobManager.set","text":"Saves or updates a job. Parameters: Name Type Description Default job Job The job to save. required","title":"set()"},{"location":"manuals/reference/#taipy.job.job_model","text":"","title":"job_model"},{"location":"manuals/reference/#taipy.job.job_model.JobModel","text":"JobModel(id: .new_type at 0x7fb9ed49f670>, task_id: str, status: taipy.job.status.Status, force: bool, creation_date: str, subscribers: List[Dict], exceptions: List[str])","title":"JobModel"},{"location":"manuals/reference/#taipy.job.job_repository","text":"","title":"job_repository"},{"location":"manuals/reference/#taipy.job.job_repository.JobRepository","text":"","title":"JobRepository"},{"location":"manuals/reference/#taipy.job.job_repository.JobRepository.storage_folder","text":"Base folder used by repository to store data","title":"storage_folder"},{"location":"manuals/reference/#taipy.job.job_repository.JobRepository.from_model","text":"Converts a model to its functional object.","title":"from_model()"},{"location":"manuals/reference/#taipy.job.job_repository.JobRepository.to_model","text":"Converts the object to be saved to its model.","title":"to_model()"},{"location":"manuals/reference/#taipy.job.status","text":"","title":"status"},{"location":"manuals/reference/#taipy.job.status.Status","text":"Enumeration representing the execution status of a Job. The possible values are SUBMITTED, BLOCKED, PENDING, RUNNING, CANCELLED, FAILED, COMPLETED, SKIPPED","title":"Status"},{"location":"manuals/reference/#taipy.pipeline","text":"","title":"pipeline"},{"location":"manuals/reference/#taipy.pipeline.pipeline","text":"","title":"pipeline"},{"location":"manuals/reference/#taipy.pipeline.pipeline.Pipeline","text":"A Pipeline entity that holds a list of tasks and additional arguments representing a set of data processing elements connected in series. Attributes: Name Type Description config_name str Name that identifies the pipeline configuration. We strongly recommend to use lowercase alphanumeric characters, dash characters ('-'), or underscore characters (' '). Other characters are replaced according the following rules: - Space characters are replaced by underscore characters (' '). - Unicode characters are replaced by a corresponding alphanumeric character using the Unicode library. - Other characters are replaced by dash characters ('-'). properties dict List of additional arguments. tasks List[Task] List of tasks. pipeline_id str Unique identifier of this pipeline. parent_id str Identifier of the parent (pipeline_id, scenario_id, cycle_id) or None .","title":"Pipeline"},{"location":"manuals/reference/#taipy.pipeline.pipeline_manager","text":"","title":"pipeline_manager"},{"location":"manuals/reference/#taipy.pipeline.pipeline_manager.PipelineManager","text":"The Pipeline Manager is responsible for managing all pipeline-related capabilities.","title":"PipelineManager"},{"location":"manuals/reference/#taipy.pipeline.pipeline_manager.PipelineManager.delete","text":"Deletes the pipeline provided as parameter. Parameters: Name Type Description Default pipeline_id str identifier of the pipeline to delete. required","title":"delete()"},{"location":"manuals/reference/#taipy.pipeline.pipeline_manager.PipelineManager.delete_all","text":"Deletes all pipelines.","title":"delete_all()"},{"location":"manuals/reference/#taipy.pipeline.pipeline_manager.PipelineManager.get","text":"Gets a pipeline. Parameters: Name Type Description Default pipeline Union[Pipeline, PipelineId] pipeline identifier or the pipeline to get. required Exceptions: Type Description NonExistingPipeline if no pipeline corresponds to pipeline_id .","title":"get()"},{"location":"manuals/reference/#taipy.pipeline.pipeline_manager.PipelineManager.get_all","text":"Returns all existing pipelines. Returns: Type Description List[Pipeline] the list of all pipelines managed by this pipeline manager.","title":"get_all()"},{"location":"manuals/reference/#taipy.pipeline.pipeline_manager.PipelineManager.get_or_create","text":"Returns a pipeline created from the pipeline configuration. Parameters: Name Type Description Default pipeline_config PipelineConfig The pipeline configuration object. required scenario_id Optional[ScenarioId] id of the scenario creating the pipeline. Default value : None . None Exceptions: Type Description MultiplePipelineFromSameConfigWithSameParent if more than one pipeline already exists with the same config, and the same parent id (scenario_id, or pipeline_id depending on the scope of the data nodes).","title":"get_or_create()"},{"location":"manuals/reference/#taipy.pipeline.pipeline_manager.PipelineManager.hard_delete","text":"Deletes the pipeline given as parameter and the nested tasks, data nodes, and jobs. Deletes the pipeline given as parameter and propagate the hard deletion. The hard delete is propagated to a nested task if the task is not shared by another pipeline or if a scenario id is given as parameter, by another scenario. pipeline_id (PipelineId) : identifier of the pipeline to hard delete. scenario_id (ScenarioId) : identifier of the optional parent scenario. ModelNotFound error if no pipeline corresponds to pipeline_id.","title":"hard_delete()"},{"location":"manuals/reference/#taipy.pipeline.pipeline_manager.PipelineManager.set","text":"Saves or updates a pipeline. Parameters: Name Type Description Default pipeline Pipeline the pipeline to save or update. required","title":"set()"},{"location":"manuals/reference/#taipy.pipeline.pipeline_manager.PipelineManager.submit","text":"Submits the pipeline corresponding to the pipeline or the identifier given as parameter for execution. All the tasks of pipeline will be submitted for execution. Parameters: Name Type Description Default pipeline Union[PipelineId, Pipeline] the pipeline or its id to submit. required callbacks Optional[List[Callable]] Callbacks on job status changes. None force bool Boolean to enforce re execution of the tasks whatever the cache data nodes. False","title":"submit()"},{"location":"manuals/reference/#taipy.pipeline.pipeline_manager.PipelineManager.subscribe","text":"Subscribes a function to be called when the status of a Job changes. If pipeline is not passed, the subscription is added to all pipelines. Note Notification will be available only for jobs created after this subscription.","title":"subscribe()"},{"location":"manuals/reference/#taipy.pipeline.pipeline_manager.PipelineManager.unsubscribe","text":"Unsubscribes a function that is called when the status of a Job changes. If pipeline is not passed, the subscription is removed to all pipelines. Note The function will continue to be called for ongoing jobs.","title":"unsubscribe()"},{"location":"manuals/reference/#taipy.pipeline.pipeline_model","text":"","title":"pipeline_model"},{"location":"manuals/reference/#taipy.pipeline.pipeline_model.PipelineModel","text":"Class to hold a model of a Pipeline. A model refers to the structure of a Pipeline stored in a database. Attributes: Name Type Description id PipelineId identifier of a Pipeline. parent_id str Identifier of the parent (pipeline_id, scenario_id, cycle_id) or None . name str name of the pipeline. properties(dict) List of additional arguments.","title":"PipelineModel"},{"location":"manuals/reference/#taipy.pipeline.pipeline_repository","text":"","title":"pipeline_repository"},{"location":"manuals/reference/#taipy.pipeline.pipeline_repository.PipelineRepository","text":"","title":"PipelineRepository"},{"location":"manuals/reference/#taipy.pipeline.pipeline_repository.PipelineRepository.storage_folder","text":"Base folder used by repository to store data","title":"storage_folder"},{"location":"manuals/reference/#taipy.pipeline.pipeline_repository.PipelineRepository.from_model","text":"Converts a model to its functional object.","title":"from_model()"},{"location":"manuals/reference/#taipy.pipeline.pipeline_repository.PipelineRepository.to_model","text":"Converts the object to be saved to its model.","title":"to_model()"},{"location":"manuals/reference/#taipy.repository","text":"","title":"repository"},{"location":"manuals/reference/#taipy.repository.fs_base","text":"","title":"fs_base"},{"location":"manuals/reference/#taipy.repository.fs_base.CustomEncoder","text":"","title":"CustomEncoder"},{"location":"manuals/reference/#taipy.repository.fs_base.CustomEncoder.default","text":"Implement this method in a subclass such that it returns a serializable object for o , or calls the base implementation (to raise a TypeError ). For example, to support arbitrary iterators, you could implement default like this:: def default(self, o): !!! try iterable = iter(o) except TypeError: pass !!! else return list(iterable) # Let the base class default method raise the TypeError return JSONEncoder.default(self, o)","title":"default()"},{"location":"manuals/reference/#taipy.repository.fs_base.FileSystemRepository","text":"Holds common methods to be used and extended when the need for saving dataclasses as JSON files in local storage emerges. Some lines have type: ignore because MyPy won't recognize some generic attributes. This should be revised in the future. Attributes: Name Type Description model ModelType Generic dataclass. dir_name str Folder that will hold the files for this dataclass model.","title":"FileSystemRepository"},{"location":"manuals/reference/#taipy.repository.fs_base.FileSystemRepository.storage_folder","text":"Base folder used by repository to store data","title":"storage_folder"},{"location":"manuals/reference/#taipy.repository.fs_base.FileSystemRepository.from_model","text":"Converts a model to its functional object.","title":"from_model()"},{"location":"manuals/reference/#taipy.repository.fs_base.FileSystemRepository.to_model","text":"Converts the object to be saved to its model.","title":"to_model()"},{"location":"manuals/reference/#taipy.scenario","text":"","title":"scenario"},{"location":"manuals/reference/#taipy.scenario.scenario","text":"","title":"scenario"},{"location":"manuals/reference/#taipy.scenario.scenario.Scenario","text":"Represents an instance of the business case to solve. It holds a set of pipelines to submit for execution in order to solve the business case. Attributes: Name Type Description config_name str Name that identifies the scenario configuration. We strongly recommend to use lowercase alphanumeric characters, dash characters ('-'), or underscore characters (' '). Other characters are replaced according the following rules: - Space characters are replaced by underscore characters (' '). - Unicode characters are replaced by a corresponding alphanumeric character using the Unicode library. - Other characters are replaced by dash characters ('-'). pipelines List[Pipeline] List of pipelines. properties dict Dictionary of additional properties of the scenario. scenario_id str Unique identifier of this scenario. Will be generated if None value provided. creation_date datetime Date and time of the creation of the scenario. is_master bool True if the scenario is the master of its cycle. False otherwise. cycle Cycle Cycle of the scenario.","title":"Scenario"},{"location":"manuals/reference/#taipy.scenario.scenario.Scenario.add_subscriber","text":"Adds callback function to be called when executing the scenario each time a scenario job changes status","title":"add_subscriber()"},{"location":"manuals/reference/#taipy.scenario.scenario.Scenario.new_id","text":"Generates a unique scenario identifier.","title":"new_id()"},{"location":"manuals/reference/#taipy.scenario.scenario.Scenario.remove_subscriber","text":"Removes callback function","title":"remove_subscriber()"},{"location":"manuals/reference/#taipy.scenario.scenario_manager","text":"","title":"scenario_manager"},{"location":"manuals/reference/#taipy.scenario.scenario_manager.ScenarioManager","text":"Scenario Manager is responsible for all managing scenario related capabilities. In particular, it is exposing methods for creating, storing, updating, retrieving, deleting, submitting scenarios.","title":"ScenarioManager"},{"location":"manuals/reference/#taipy.scenario.scenario_manager.ScenarioManager.compare","text":"Compares the data nodes of given scenarios with known datanode config name. Parameters: Name Type Description Default scenarios Scenario) Scenario objects to compare () data_node_config_name Optional[str]) config name of the DataNode to compare scenarios, if no ds_config_name is None Exceptions: Type Description InsufficientScenarioToCompare Provided only one or no scenario for comparison NonExistingComparator The provided comparator does not exist DifferentScenarioConfigs The provided scenarios do not share the same scenario_config NonExistingScenarioConfig Cannot find the shared scenario config of the provided scenarios","title":"compare()"},{"location":"manuals/reference/#taipy.scenario.scenario_manager.ScenarioManager.create","text":"Creates and returns a new scenario from the scenario configuration provided as parameter. If the scenario belongs to a work cycle, the cycle (corresponding to the creation_date and the configuration frequency attribute) is created if it does not exist yet. Parameters: Name Type Description Default config ScenarioConfig) Scenario configuration object. required creation_date Optional[datetime.datetime]) Creation date of the scenario. Current date time is used as default value. None display_name Optional[str]) Display name of the scenario. None","title":"create()"},{"location":"manuals/reference/#taipy.scenario.scenario_manager.ScenarioManager.delete","text":"Deletes the scenario given as parameter. Parameters: Name Type Description Default scenario_id ScenarioId) identifier of the scenario to delete. required Exceptions: Type Description DeletingMasterScenario scenario_id corresponds to a master Scenario. It cannot be deleted. ModelNotFound No scenario corresponds to scenario_id.","title":"delete()"},{"location":"manuals/reference/#taipy.scenario.scenario_manager.ScenarioManager.delete_all","text":"Deletes all scenarios.","title":"delete_all()"},{"location":"manuals/reference/#taipy.scenario.scenario_manager.ScenarioManager.get","text":"Returns the scenario corresponding to the scenario or the identifier given as parameter. Parameters: Name Type Description Default scenario Union[Scenario, ScenarioId]) scenario to get. required Exceptions: Type Description NonExistingScenario No scenario corresponds to scenario_id.","title":"get()"},{"location":"manuals/reference/#taipy.scenario.scenario_manager.ScenarioManager.get_all","text":"Returns the list of all existing scenarios.","title":"get_all()"},{"location":"manuals/reference/#taipy.scenario.scenario_manager.ScenarioManager.get_all_by_cycle","text":"Returns the list of all existing scenarios that belong to the cycle given as parameter. Parameters: Name Type Description Default cycle Cycle) Cycle of the scenarios to return. required","title":"get_all_by_cycle()"},{"location":"manuals/reference/#taipy.scenario.scenario_manager.ScenarioManager.get_all_masters","text":"Returns the list of all master scenarios.","title":"get_all_masters()"},{"location":"manuals/reference/#taipy.scenario.scenario_manager.ScenarioManager.get_master","text":"Returns the master scenario of the cycle given as parameter. None is the cycle has no master scenario. Parameters: Name Type Description Default cycle Cycle) cycle of the master scenario to return. required","title":"get_master()"},{"location":"manuals/reference/#taipy.scenario.scenario_manager.ScenarioManager.hard_delete","text":"Deletes the scenario given as parameter and the nested pipelines, tasks, data nodes, and jobs. Deletes the scenario given as parameter and propagate the hard deletion. The hard delete is propagated to a nested pipeline if the pipeline is not shared by another scenario. scenario_id (ScenarioId) : identifier of the scenario to hard delete. ModelNotFound error if no scenario corresponds to scenario_id.","title":"hard_delete()"},{"location":"manuals/reference/#taipy.scenario.scenario_manager.ScenarioManager.set","text":"Saves or Updates the scenario given as parameter. Parameters: Name Type Description Default scenario Scenario) Scenario to save or update. required","title":"set()"},{"location":"manuals/reference/#taipy.scenario.scenario_manager.ScenarioManager.set_master","text":"Promotes scenario given as parameter as master scenario of its cycle. If the cycle already had a master scenario it will be demoted and it will no longer be master for the cycle. Parameters: Name Type Description Default scenario Scenario) scenario to promote as master. required","title":"set_master()"},{"location":"manuals/reference/#taipy.scenario.scenario_manager.ScenarioManager.submit","text":"Submits the scenario corresponding to the scenario of the identifier given as parameter for execution. All the tasks of scenario will be submitted for execution. Parameters: Name Type Description Default scenario Union[Scenario, ScenarioId]) the scenario or its identifier to submit. required force bool Boolean to enforce re execution of the tasks whatever the cache data nodes. False","title":"submit()"},{"location":"manuals/reference/#taipy.scenario.scenario_manager.ScenarioManager.subscribe","text":"Subscribes a function to be called each time one of the provided scenario jobs changes status. If scenario is not passed, the subscription is added to all scenarios. Note Notification will be available only for jobs created after this subscription.","title":"subscribe()"},{"location":"manuals/reference/#taipy.scenario.scenario_manager.ScenarioManager.unsubscribe","text":"Unsubscribes a function that is called when the status of a Job changes. If scenario is not passed, the subscription is removed to all scenarios. Note The function will continue to be called for ongoing jobs.","title":"unsubscribe()"},{"location":"manuals/reference/#taipy.scenario.scenario_model","text":"","title":"scenario_model"},{"location":"manuals/reference/#taipy.scenario.scenario_model.ScenarioModel","text":"ScenarioModel(id: .new_type at 0x7fb9ed49f700>, name: str, pipelines: List[PipelineId], properties: dict, creation_date: str, master_scenario: bool, subscribers: List[Dict], cycle: Optional[CycleId] = None)","title":"ScenarioModel"},{"location":"manuals/reference/#taipy.scenario.scenario_repository","text":"","title":"scenario_repository"},{"location":"manuals/reference/#taipy.scenario.scenario_repository.ScenarioRepository","text":"","title":"ScenarioRepository"},{"location":"manuals/reference/#taipy.scenario.scenario_repository.ScenarioRepository.storage_folder","text":"Base folder used by repository to store data","title":"storage_folder"},{"location":"manuals/reference/#taipy.scenario.scenario_repository.ScenarioRepository.from_model","text":"Converts a model to its functional object.","title":"from_model()"},{"location":"manuals/reference/#taipy.scenario.scenario_repository.ScenarioRepository.to_model","text":"Converts the object to be saved to its model.","title":"to_model()"},{"location":"manuals/reference/#taipy.scheduler","text":"","title":"scheduler"},{"location":"manuals/reference/#taipy.scheduler.abstract_scheduler","text":"","title":"abstract_scheduler"},{"location":"manuals/reference/#taipy.scheduler.abstract_scheduler.AbstractScheduler","text":"Creates and schedules Jobs. Attributes: Name Type Description data_manager DataManager is an element that retrieves and deals with Data Node.","title":"AbstractScheduler"},{"location":"manuals/reference/#taipy.scheduler.executor","text":"","title":"executor"},{"location":"manuals/reference/#taipy.scheduler.executor.synchronous","text":"","title":"synchronous"},{"location":"manuals/reference/#taipy.scheduler.executor.synchronous.Synchronous","text":"Equivalent to the Python standard Thread/Process Pool Executor but the function is executed directly.","title":"Synchronous"},{"location":"manuals/reference/#taipy.scheduler.executor.synchronous.Synchronous.submit","text":"Submits a callable to be executed with the given arguments. Schedules the callable to be executed as fn( args, *kwargs) and returns a Future instance representing the execution of the callable. Returns: Type Description A Future representing the given call.","title":"submit()"},{"location":"manuals/reference/#taipy.scheduler.job_dispatcher","text":"","title":"job_dispatcher"},{"location":"manuals/reference/#taipy.scheduler.job_dispatcher.JobDispatcher","text":"Wrapper around executor that will run jobs. Job can be executed on different contexts (locally, etc.). This wrapper instantiate the executor based on its args then deal with its low level interface to provide a homogeneous way to execute jobs.","title":"JobDispatcher"},{"location":"manuals/reference/#taipy.scheduler.job_dispatcher.JobDispatcher.can_execute","text":"Returns True if a worker is available for a new run.","title":"can_execute()"},{"location":"manuals/reference/#taipy.scheduler.job_dispatcher.JobDispatcher.dispatch","text":"Dispatches a Job on an available worker for execution. Parameters: Name Type Description Default job Job Element to execute. required","title":"dispatch()"},{"location":"manuals/reference/#taipy.scheduler.scheduler","text":"","title":"scheduler"},{"location":"manuals/reference/#taipy.scheduler.scheduler.Scheduler","text":"","title":"Scheduler"},{"location":"manuals/reference/#taipy.scheduler.scheduler.Scheduler.is_blocked","text":"Returns True if the execution of the job or the task is blocked by the execution of another job. Parameters: Name Type Description Default obj Union[taipy.task.task.Task, taipy.job.job.Job] Task or Job. required Returns: Type Description bool True if one of its input data nodes is blocked.","title":"is_blocked()"},{"location":"manuals/reference/#taipy.scheduler.scheduler.Scheduler.submit","text":"Submit pipeline for execution. Parameters: Name Type Description Default pipeline Pipeline to be transformed into Job(s) for execution. required callbacks Optional[Iterable[Callable]] Optional list of functions that should be executed once the job is done. None force bool Boolean to enforce re execution of the tasks whatever the cache data nodes. False Returns: Type Description List[taipy.job.job.Job] The created Jobs.","title":"submit()"},{"location":"manuals/reference/#taipy.taipy","text":"Main module.","title":"taipy"},{"location":"manuals/reference/#taipy.taipy.Taipy","text":"Main Taipy class","title":"Taipy"},{"location":"manuals/reference/#taipy.taipy.Taipy.check_configuration","text":"Checks configuration. Returns: Type Description IssueCollector Collector containing the info, the warning and the error messages.","title":"check_configuration()"},{"location":"manuals/reference/#taipy.taipy.Taipy.clean_all_entities","text":"Deletes all entities from the data folder. Returns: Type Description bool True if the operation succeeded, False otherwise.","title":"clean_all_entities()"},{"location":"manuals/reference/#taipy.taipy.Taipy.compare_scenarios","text":"Compares the data nodes of given scenarios with known datanode config name. Parameters: Name Type Description Default scenarios Scenario) Scenario objects to compare () data_node_config_name Optional[str]) config name of the DataNode to compare scenarios, if no datanode_config_name is provided, the scenarios will be compared based on all the previously defined comparators. None Exceptions: Type Description InsufficientScenarioToCompare Provided only one or no scenario for comparison NonExistingComparator The provided comparator does not exist DifferentScenarioConfigs The provided scenarios do not share the same scenario_config NonExistingScenarioConfig Cannot find the shared scenario config of the provided scenarios","title":"compare_scenarios()"},{"location":"manuals/reference/#taipy.taipy.Taipy.configure_data_node","text":"Configures a new data node configuration.","title":"configure_data_node()"},{"location":"manuals/reference/#taipy.taipy.Taipy.configure_default_data_node","text":"Configures the default behavior of a data node configuration.","title":"configure_default_data_node()"},{"location":"manuals/reference/#taipy.taipy.Taipy.configure_default_pipeline","text":"Configures the default behavior of a pipeline configuration.","title":"configure_default_pipeline()"},{"location":"manuals/reference/#taipy.taipy.Taipy.configure_default_scenario","text":"Configures the default behavior of a scenario configuration.","title":"configure_default_scenario()"},{"location":"manuals/reference/#taipy.taipy.Taipy.configure_default_task","text":"Configures the default behavior of a task configuration.","title":"configure_default_task()"},{"location":"manuals/reference/#taipy.taipy.Taipy.configure_global_app","text":"Configures fields related to global application.","title":"configure_global_app()"},{"location":"manuals/reference/#taipy.taipy.Taipy.configure_job_executions","text":"Configures fields related to job execution.","title":"configure_job_executions()"},{"location":"manuals/reference/#taipy.taipy.Taipy.configure_pipeline","text":"Configures a new pipeline configuration.","title":"configure_pipeline()"},{"location":"manuals/reference/#taipy.taipy.Taipy.configure_scenario","text":"Configures a new scenario configuration.","title":"configure_scenario()"},{"location":"manuals/reference/#taipy.taipy.Taipy.configure_task","text":"Configures a new task configuration.","title":"configure_task()"},{"location":"manuals/reference/#taipy.taipy.Taipy.create_pipeline","text":"Creates and Returns a new pipeline from the pipeline configuration given as parameter. Parameters: Name Type Description Default config PipelineConfig The pipeline configuration object. required","title":"create_pipeline()"},{"location":"manuals/reference/#taipy.taipy.Taipy.create_scenario","text":"Creates and returns a new scenario from the scenario configuration provided as parameter. If the scenario belongs to a work cycle, the cycle (corresponding to the creation_date and the configuration frequency attribute) is created if it does not exist yet. Parameters: Name Type Description Default config ScenarioConfig) Scenario configuration object. required creation_date Optional[datetime.datetime]) Creation date. Current date time used as default value. None name Optional[str]) Display name of the scenario. None","title":"create_scenario()"},{"location":"manuals/reference/#taipy.taipy.Taipy.delete_job","text":"Deletes the job if it is finished. Exceptions: Type Description JobNotDeletedException if the job is not finished.","title":"delete_job()"},{"location":"manuals/reference/#taipy.taipy.Taipy.delete_jobs","text":"Deletes all jobs.","title":"delete_jobs()"},{"location":"manuals/reference/#taipy.taipy.Taipy.delete_pipeline","text":"Deletes the pipeline given as parameter and the nested tasks, data nodes, and jobs. Deletes the pipeline given as parameter and propagate the hard deletion. The hard delete is propagated to a nested task if the task is not shared by another pipeline. pipeline_id (PipelineId) : identifier of the pipeline to hard delete. ModelNotFound error if no pipeline corresponds to pipeline_id.","title":"delete_pipeline()"},{"location":"manuals/reference/#taipy.taipy.Taipy.delete_scenario","text":"Deletes the scenario given as parameter and the nested pipelines, tasks, data nodes, and jobs. Deletes the scenario given as parameter and propagate the hard deletion. The hard delete is propagated to a nested pipeline if the pipeline is not shared by another scenario. scenario_id (ScenarioId) : identifier of the scenario to hard delete. ModelNotFound error if no scenario corresponds to scenario_id.","title":"delete_scenario()"},{"location":"manuals/reference/#taipy.taipy.Taipy.export_configuration","text":"Exports the configuration to a toml file. The configuration exported is the configuration applied. It is compiled from the three possible methods to configure the application: The python code configuration, the file configuration and the environment configuration. Parameters: Name Type Description Default filename str or Path File to export. required Note Overwrite the file if it already exists.","title":"export_configuration()"},{"location":"manuals/reference/#taipy.taipy.Taipy.get","text":"Gets an entity given the identifier as parameter. Parameters: Name Type Description Default entity Union[TaskId, DataNodeId, PipelineId, ScenarioId] The identifier of the entity to get. required Returns: Type Description Union[taipy.task.task.Task, taipy.data.data_node.DataNode, taipy.pipeline.pipeline.Pipeline, taipy.scenario.scenario.Scenario, taipy.job.job.Job, taipy.cycle.cycle.Cycle] The entity corresponding to the provided identifier. Exceptions: Type Description ModelNotFound if no entity corresponds to entity_id .","title":"get()"},{"location":"manuals/reference/#taipy.taipy.Taipy.get_all_masters","text":"Returns the list of all master scenarios.","title":"get_all_masters()"},{"location":"manuals/reference/#taipy.taipy.Taipy.get_data_nodes","text":"Returns the list of all existing data nodes.","title":"get_data_nodes()"},{"location":"manuals/reference/#taipy.taipy.Taipy.get_jobs","text":"Gets all the existing jobs. Returns: Type Description List[taipy.job.job.Job] List of all jobs.","title":"get_jobs()"},{"location":"manuals/reference/#taipy.taipy.Taipy.get_latest_job","text":"Gets the latest job of a task. Returns: Type Description Job The latest computed job of the task.","title":"get_latest_job()"},{"location":"manuals/reference/#taipy.taipy.Taipy.get_master","text":"Returns the master scenario of the cycle given as parameter. None if the cycle has no master scenario. Parameters: Name Type Description Default cycle Cycle) cycle of the master scenario to return. required","title":"get_master()"},{"location":"manuals/reference/#taipy.taipy.Taipy.get_pipelines","text":"Returns all existing pipelines. Returns: Type Description List[Pipeline] the list of all pipelines managed by this pipeline manager.","title":"get_pipelines()"},{"location":"manuals/reference/#taipy.taipy.Taipy.get_scenarios","text":"Returns the list of all existing scenarios filtered by cycle if given as parameter. Parameters: Name Type Description Default cycle Optional[Cycle]) Cycle of the scenarios to return. None","title":"get_scenarios()"},{"location":"manuals/reference/#taipy.taipy.Taipy.get_tasks","text":"Returns the list of all existing tasks. Returns: Type Description List The list of tasks handled by this Task Manager.","title":"get_tasks()"},{"location":"manuals/reference/#taipy.taipy.Taipy.load_configuration","text":"Loads configuration from file located at the filename given as parameter. Parameters: Name Type Description Default filename str or Path File to load. required","title":"load_configuration()"},{"location":"manuals/reference/#taipy.taipy.Taipy.set","text":"Saves or updates a data node, a task, a job, a pipeline, a scenario or a cycle. Parameters: Name Type Description Default entity Union[taipy.data.data_node.DataNode, taipy.task.task.Task, taipy.pipeline.pipeline.Pipeline, taipy.scenario.scenario.Scenario, taipy.cycle.cycle.Cycle] The entity to save. required","title":"set()"},{"location":"manuals/reference/#taipy.taipy.Taipy.set_master","text":"Promotes scenario given as parameter as master scenario of its cycle. If the cycle already had a master scenario it will be demoted, and it will no longer be master for the cycle. Parameters: Name Type Description Default scenario Scenario) scenario to promote as master. required","title":"set_master()"},{"location":"manuals/reference/#taipy.taipy.Taipy.submit","text":"Submits the entity given as parameter for execution. All the tasks of the entity task/pipeline/scenario will be submitted for execution. Parameters: Name Type Description Default entity Union[Scenario, Pipeline]) the entity to submit. required","title":"submit()"},{"location":"manuals/reference/#taipy.taipy.Taipy.subscribe_pipeline","text":"Subscribes a function to be called when the status of a Job changes. If pipeline is not passed, the subscription is added to all pipelines. Note Notification will be available only for jobs created after this subscription.","title":"subscribe_pipeline()"},{"location":"manuals/reference/#taipy.taipy.Taipy.subscribe_scenario","text":"Subscribes a function to be called each time one of the provided scenario jobs changes status. If scenario is not passed, the subscription is added to all scenarios. Note Notification will be available only for jobs created after this subscription.","title":"subscribe_scenario()"},{"location":"manuals/reference/#taipy.taipy.Taipy.unsubscribe_pipeline","text":"Unsubscribes a function that is called when the status of a Job changes. If pipeline is not passed, the subscription is removed to all pipelines. Note The function will continue to be called for ongoing jobs.","title":"unsubscribe_pipeline()"},{"location":"manuals/reference/#taipy.taipy.Taipy.unsubscribe_scenario","text":"Unsubscribes a function that is called when the status of a Job changes. If scenario is not passed, the subscription is removed to all scenarios. Note The function will continue to be called for ongoing jobs.","title":"unsubscribe_scenario()"},{"location":"manuals/reference/#taipy.task","text":"","title":"task"},{"location":"manuals/reference/#taipy.task.task","text":"","title":"task"},{"location":"manuals/reference/#taipy.task.task.Task","text":"Holds user function that will be executed, its parameters qs data nodes and outputs as data nodes. This element bring together the user code as function, parameters and outputs. Attributes: Name Type Description config_name Name that identifies the task config. We strongly recommend to use lowercase alphanumeric characters, dash character '-', or underscore character ' '. Note that other characters are replaced according the following rules : - Space character ' ' is replaced by ' '. - Unicode characters are replaced by a corresponding alphanumeric character using unicode library. - Other characters are replaced by dash character '-'. input Data node input as list. function Taking data from input data node and return data that should go inside of the output data node. output Data node output result of the function as optional list. id Unique identifier of this task. Generated if None . parent_id Identifier of the parent (pipeline_id, scenario_id, cycle_id) or None .","title":"Task"},{"location":"manuals/reference/#taipy.task.task.Task.scope","text":"Retrieve the lowest scope of the task based on its data node. Returns: Type Description Scope Lowest scope present in input and output data node or GLOBAL if there are no neither input or output.","title":"scope"},{"location":"manuals/reference/#taipy.task.task_manager","text":"","title":"task_manager"},{"location":"manuals/reference/#taipy.task.task_manager.TaskManager","text":"The Task Manager saves and retrieves Tasks. Attributes: Name Type Description tasks Dict[(TaskId, Task)] A dictionary that associates every task with its identifier. scheduler AbstractScheduler The scheduler for submitting tasks. data_manager DataManager The Data Manager that interacts with data nodes. repository TaskRepository The repository where tasks are saved.","title":"TaskManager"},{"location":"manuals/reference/#taipy.task.task_manager.TaskManager.delete","text":"Deletes the cycle provided as parameter. Parameters: Name Type Description Default task_id str identifier of the task to delete. required","title":"delete()"},{"location":"manuals/reference/#taipy.task.task_manager.TaskManager.delete_all","text":"Deletes all the persisted tasks.","title":"delete_all()"},{"location":"manuals/reference/#taipy.task.task_manager.TaskManager.get","text":"Gets a task given the Task or the identifier. Parameters: Name Type Description Default task Union[Task, TaskId] The task identifier of the task to get. required Returns: Type Description Task The task with the provided identifier. Exceptions: Type Description ModelNotFound if no task corresponds to task_id .","title":"get()"},{"location":"manuals/reference/#taipy.task.task_manager.TaskManager.get_all","text":"Returns the list of all existing tasks. Returns: Type Description List The list of tasks handled by this Task Manager.","title":"get_all()"},{"location":"manuals/reference/#taipy.task.task_manager.TaskManager.get_or_create","text":"Returns a task created from the provided task configuration. If no task exists for that task configuration, in the provided scenario_id and pipeline_id , then a new task is created and returned. Parameters: Name Type Description Default task_config TaskConfig The task configuration object. required scenario_id ScenarioId The identifier of the scenario creating the task. None pipeline_id PipelineId The identifier of the pipeline creating the task. None Returns: Type Description Task A task, potentially new, that is created for that task configuration. Exceptions: Type Description MultipleTaskFromSameConfigWithSameParent if more than one task already exists with the same configuration, and the same parent id (scenario or pipeline identifier, depending on the scope of the data node). TODO: This comment makes no sense - Data Node scope","title":"get_or_create()"},{"location":"manuals/reference/#taipy.task.task_manager.TaskManager.hard_delete","text":"Deletes the task given as parameter and the nested data nodes, and jobs. Deletes the task given as parameter and propagate the hard deletion. The hard delete is propagated to a nested data nodes if the data nodes is not shared by another pipeline or if a scenario id is given as parameter, by another scenario. task_id (TaskId): identifier of the task to hard delete. pipeline_id (PipelineId) : identifier of the optional parent pipeline. scenario_id (ScenarioId) : identifier of the optional parent scenario. ModelNotFound error if no pipeline corresponds to pipeline_id.","title":"hard_delete()"},{"location":"manuals/reference/#taipy.task.task_manager.TaskManager.set","text":"Saves or updates a task. Parameters: Name Type Description Default task Task The task to save. required","title":"set()"},{"location":"manuals/reference/#taipy.task.task_model","text":"","title":"task_model"},{"location":"manuals/reference/#taipy.task.task_model.TaskModel","text":"Hold the model of a Task. A model refers to the structure of a Task stored in a database. The tuple (config_name, parent_id) forms a unique key. Attributes: Name Type Description id str Identifier of a Data Node. parent_id Optional[str] Identifier of the parent (pipeline_id, scenario_id, cycle_id) or None . config_name str Name of the Data Node Config. input Input data node of the Task, saved as its ID string representation. function_name str Name of the task function. function_module str Module name of the task function. output Output data node of the Task, saved as its ID string representation.","title":"TaskModel"},{"location":"manuals/reference/#taipy.task.task_repository","text":"","title":"task_repository"},{"location":"manuals/reference/#taipy.task.task_repository.TaskRepository","text":"","title":"TaskRepository"},{"location":"manuals/reference/#taipy.task.task_repository.TaskRepository.storage_folder","text":"Base folder used by repository to store data","title":"storage_folder"},{"location":"manuals/reference/#taipy.task.task_repository.TaskRepository.from_model","text":"Converts a model to its functional object.","title":"from_model()"},{"location":"manuals/reference/#taipy.task.task_repository.TaskRepository.to_model","text":"Converts the object to be saved to its model.","title":"to_model()"},{"location":"manuals/core/user_core_concepts/","text":"Taipy core is made for data scientists to turn their algorithms into real applications. Taipy core provides the necessary concepts for modeling, executing, and monitoring such algorithms. In this section, we define the following concepts : Data node Task Job Pipeline Scenario Cycle Data node \u00b6 A data node is one of the most important concepts in Taipy core. It does not contain the data itself, but it holds all the necessary information to read and write the actual data. It can be seen as a dataset descriptor or as a data reference. A data node can reference any data. It could be a text, a numeric value, a list of parameters, a custom python object, the content of a JSON or a CSV file, the content of one or multiple database table(s), or any other data. It is made to model any type of data: Input, intermediate, or output data, internal or external data, local or remote data, historical data, set of parameters, trained model, etc. The data node information depends on the data itself, its exposed format, and its storage type. For instance, if the data is stored in an SQL database, the corresponding data node should contain the username, password, host, and port, but also the queries to read and write the data as well as the python class used for the deserialization. On another use case, if the data is stored in a CSV file, the corresponding data node should contain for instance, the path to the file and the python class used for the deserialization. Let's take an example. Let's assume we want to build an application to predict some sales demand every month in order to adjust a production planning constrained by some capacity. For that purpose, we may have six data nodes to model the various data. One for the sales history, one for the trained model, one for the current month, one for the sales predictions, one for the capacity of production, and one for the production orders. Storage type \u00b6 Taipy proposes various predefined data nodes corresponding to the most popular storage types . Thanks to predefined data nodes , the data scientist developer does not need to spend much time configuring the storage types or the query system . Most of the time, a predefined data node corresponding to a basic and standard use case satisfies the user's need. Here is the list of predefined data nodes storage types : Pickle (Default storage type) CSV Excel Generic (Work In Progress) In memory (For development purposes only. Not recommended for production deployment) SQL The various predefined storage types are mainly used for input data. Indeed, the input data is usually provided by an external component, and the data scientist user does not control the format. However, in most cases, particularly for intermediate or output data nodes , it is not relevant to prefer one storage type . The end-user wants to manipulate the corresponding data within the Taipy application. Still, the user does not have any particular specifications regarding the storage type . In such a case, the data scientist developer does not need to spend time configuring the storage type . Taipy recommends using the default storage type pickle that does not require any configuration. In our example The sales history comes from our company record system, so we do not control its storage type. We got the data as a CSV file. We can use a predefined CSV data node to model the sales history. Concerning the production orders data node , we want to write the data into a database shared by other company components. We can use an SQL data node to model the production orders. We have no particular specification for the other data nodes. We can use the default storage type: Pickle. In case a more specific method to store, read and write the data is needed by the user, Taipy proposes a Generic data node that can be used for any storage type or any kind of query system . The user only needs to provide two python functions, one for reading and one for writing the data. Exposed type \u00b6 As explained before, a data node may represent any data. For data nodes representing a collection of entities (like CSV files, SQL table, Excel sheet), the default exposed type is pandas dataframe. A numpy format is also available. If needed, the user can specify a Python Custom Class as exposed type . When reading the data, Taipy will return the entities as a Custom Class list. For example, in the case of a CSV file, each line of the CSV file corresponds to an instance of a Custom Class object. Then, the complete CSV file data corresponds to a Custom Class list. Task \u00b6 A Task is a runnable piece of code written by the developer user (typically a data scientist). It represents one step among the various data processing steps the user is working on. Concretely, a task means a python function that can be executed. For example, a task could be a preprocessing step to prepare some data. It could also be a more complex step that computes a whole training model using a machine learning algorithm. Since a task represents a function, it can take a set of parameters as input and return a set of results as output. Each parameter and each result is modeled as a data node. In our example We create three tasks: The first is the training task that takes the sales history as the input data node and returns the trained model as the output data node. The second is the predicting task that takes the trained model and the current month as input and returns the sales predictions. And the third task is the production planning task that takes the capacity and the sales predictions as input data nodes and returns the production orders as output. Remark Since no task computes them, we can consider sales history, current month, and capacity as input data nodes. The data nodes trained model and sales predictions can be considered intermediate data nodes, and the production orders as an output data node since no task is reading it. Job \u00b6 A Job represents a unique execution of a task. Each time a task is submitted for execution, a new job is created. A job holds all the information related to its task execution, including the creation date, the execution Status , the user function log messages, and the eventual exception raised. Pipeline \u00b6 A Pipeline is made to model an algorithm. It represents a direct acyclic graph of input, intermediate, and output data nodes linked together by tasks. A pipeline is a set of connected tasks that the user wants to run together for functional reasons. It then represents an execution graph as a consistent set of tasks. In a typical machine learning application, we can have a pipeline dedicated to preprocessing and preparing data, a pipeline for computing a training model, and a pipeline dedicated to scoring. In the example We want to have two pipelines. A first sales pipeline (boxed in the green on the picture) is made of training and predict tasks. A second production pipeline (in the dark grey rectangle on the picture) made of the planning task. Indeed, the two pipelines could represent two different workflows that can be run independently, on different schedule or by different users. Note that the various pipelines do not require to be disjointed. Scenario \u00b6 A Scenario is made to model a business concept. It represents an instance of a business problem to solve on consistent data and parameter sets. In other words, when an end user select a scenario , he/she should have access to all the information and data needed to understand the business case he/she is working on and to make the right decisions. Example Suppose we want to build an application to predict demand every month and compute production orders. In that case, we can create the first scenario for January. It must contain everything we need to understand the January case, access input data, compute predictions, visualize our forecast algorithm results, make production decisions, and publish January production orders. Then we can create another scenario for the February production planning. And so on. Two scenarios can also be used to represent the same instance of a business problem but with two different assumptions. Example Now, we want to perform some simulation on the impact of our capacity data on our production planning. We want to create two scenarios for the same February use case. The first scenario can forecast demand and compute production orders with a low capacity. In contrast, the second scenario assumes a high capacity value. Cycle and Master scenario \u00b6 Business problems are often recurrent. A cycle (or work cycle) represents an iteration of such a recurrent work pattern. Each cycle has a start date and a duration that depends on the frequency on which a user must publish a scenario in production. In Taipy, a cycle duration depends on the Frequency of the scenarios, which is among daily , weekly , monthly , quarterly , or yearly . Each recurrent scenario is attached to a cycle . In other words, each cycle contains multiple scenarios. At the end of a cycle (start date + duration), only one of the scenarios can be applied in production. This scenario is called master scenario . There is only one master scenario per cycle. Example The user must publish production orders every month. Each month is modeled as a cycle in Taipy, and each cycle contains one or multiple scenarios. Depending on the simulation we ran, we may have one unique scenario (a master one) for the January cycle and two scenarios for the February cycle (one with the low capacity assumption and one with the high capacity assumption). As a user of the application, I can decide to apply the low capacity scenario in production for February. For that, I promote my low capacity scenario as master for the February cycle. Scope \u00b6","title":"Core concepts"},{"location":"manuals/core/user_core_concepts/#data-node","text":"A data node is one of the most important concepts in Taipy core. It does not contain the data itself, but it holds all the necessary information to read and write the actual data. It can be seen as a dataset descriptor or as a data reference. A data node can reference any data. It could be a text, a numeric value, a list of parameters, a custom python object, the content of a JSON or a CSV file, the content of one or multiple database table(s), or any other data. It is made to model any type of data: Input, intermediate, or output data, internal or external data, local or remote data, historical data, set of parameters, trained model, etc. The data node information depends on the data itself, its exposed format, and its storage type. For instance, if the data is stored in an SQL database, the corresponding data node should contain the username, password, host, and port, but also the queries to read and write the data as well as the python class used for the deserialization. On another use case, if the data is stored in a CSV file, the corresponding data node should contain for instance, the path to the file and the python class used for the deserialization. Let's take an example. Let's assume we want to build an application to predict some sales demand every month in order to adjust a production planning constrained by some capacity. For that purpose, we may have six data nodes to model the various data. One for the sales history, one for the trained model, one for the current month, one for the sales predictions, one for the capacity of production, and one for the production orders.","title":"Data node"},{"location":"manuals/core/user_core_concepts/#storage-type","text":"Taipy proposes various predefined data nodes corresponding to the most popular storage types . Thanks to predefined data nodes , the data scientist developer does not need to spend much time configuring the storage types or the query system . Most of the time, a predefined data node corresponding to a basic and standard use case satisfies the user's need. Here is the list of predefined data nodes storage types : Pickle (Default storage type) CSV Excel Generic (Work In Progress) In memory (For development purposes only. Not recommended for production deployment) SQL The various predefined storage types are mainly used for input data. Indeed, the input data is usually provided by an external component, and the data scientist user does not control the format. However, in most cases, particularly for intermediate or output data nodes , it is not relevant to prefer one storage type . The end-user wants to manipulate the corresponding data within the Taipy application. Still, the user does not have any particular specifications regarding the storage type . In such a case, the data scientist developer does not need to spend time configuring the storage type . Taipy recommends using the default storage type pickle that does not require any configuration. In our example The sales history comes from our company record system, so we do not control its storage type. We got the data as a CSV file. We can use a predefined CSV data node to model the sales history. Concerning the production orders data node , we want to write the data into a database shared by other company components. We can use an SQL data node to model the production orders. We have no particular specification for the other data nodes. We can use the default storage type: Pickle. In case a more specific method to store, read and write the data is needed by the user, Taipy proposes a Generic data node that can be used for any storage type or any kind of query system . The user only needs to provide two python functions, one for reading and one for writing the data.","title":"Storage type"},{"location":"manuals/core/user_core_concepts/#exposed-type","text":"As explained before, a data node may represent any data. For data nodes representing a collection of entities (like CSV files, SQL table, Excel sheet), the default exposed type is pandas dataframe. A numpy format is also available. If needed, the user can specify a Python Custom Class as exposed type . When reading the data, Taipy will return the entities as a Custom Class list. For example, in the case of a CSV file, each line of the CSV file corresponds to an instance of a Custom Class object. Then, the complete CSV file data corresponds to a Custom Class list.","title":"Exposed type"},{"location":"manuals/core/user_core_concepts/#task","text":"A Task is a runnable piece of code written by the developer user (typically a data scientist). It represents one step among the various data processing steps the user is working on. Concretely, a task means a python function that can be executed. For example, a task could be a preprocessing step to prepare some data. It could also be a more complex step that computes a whole training model using a machine learning algorithm. Since a task represents a function, it can take a set of parameters as input and return a set of results as output. Each parameter and each result is modeled as a data node. In our example We create three tasks: The first is the training task that takes the sales history as the input data node and returns the trained model as the output data node. The second is the predicting task that takes the trained model and the current month as input and returns the sales predictions. And the third task is the production planning task that takes the capacity and the sales predictions as input data nodes and returns the production orders as output. Remark Since no task computes them, we can consider sales history, current month, and capacity as input data nodes. The data nodes trained model and sales predictions can be considered intermediate data nodes, and the production orders as an output data node since no task is reading it.","title":"Task"},{"location":"manuals/core/user_core_concepts/#job","text":"A Job represents a unique execution of a task. Each time a task is submitted for execution, a new job is created. A job holds all the information related to its task execution, including the creation date, the execution Status , the user function log messages, and the eventual exception raised.","title":"Job"},{"location":"manuals/core/user_core_concepts/#pipeline","text":"A Pipeline is made to model an algorithm. It represents a direct acyclic graph of input, intermediate, and output data nodes linked together by tasks. A pipeline is a set of connected tasks that the user wants to run together for functional reasons. It then represents an execution graph as a consistent set of tasks. In a typical machine learning application, we can have a pipeline dedicated to preprocessing and preparing data, a pipeline for computing a training model, and a pipeline dedicated to scoring. In the example We want to have two pipelines. A first sales pipeline (boxed in the green on the picture) is made of training and predict tasks. A second production pipeline (in the dark grey rectangle on the picture) made of the planning task. Indeed, the two pipelines could represent two different workflows that can be run independently, on different schedule or by different users. Note that the various pipelines do not require to be disjointed.","title":"Pipeline"},{"location":"manuals/core/user_core_concepts/#scenario","text":"A Scenario is made to model a business concept. It represents an instance of a business problem to solve on consistent data and parameter sets. In other words, when an end user select a scenario , he/she should have access to all the information and data needed to understand the business case he/she is working on and to make the right decisions. Example Suppose we want to build an application to predict demand every month and compute production orders. In that case, we can create the first scenario for January. It must contain everything we need to understand the January case, access input data, compute predictions, visualize our forecast algorithm results, make production decisions, and publish January production orders. Then we can create another scenario for the February production planning. And so on. Two scenarios can also be used to represent the same instance of a business problem but with two different assumptions. Example Now, we want to perform some simulation on the impact of our capacity data on our production planning. We want to create two scenarios for the same February use case. The first scenario can forecast demand and compute production orders with a low capacity. In contrast, the second scenario assumes a high capacity value.","title":"Scenario"},{"location":"manuals/core/user_core_concepts/#cycle-and-master-scenario","text":"Business problems are often recurrent. A cycle (or work cycle) represents an iteration of such a recurrent work pattern. Each cycle has a start date and a duration that depends on the frequency on which a user must publish a scenario in production. In Taipy, a cycle duration depends on the Frequency of the scenarios, which is among daily , weekly , monthly , quarterly , or yearly . Each recurrent scenario is attached to a cycle . In other words, each cycle contains multiple scenarios. At the end of a cycle (start date + duration), only one of the scenarios can be applied in production. This scenario is called master scenario . There is only one master scenario per cycle. Example The user must publish production orders every month. Each month is modeled as a cycle in Taipy, and each cycle contains one or multiple scenarios. Depending on the simulation we ran, we may have one unique scenario (a master one) for the January cycle and two scenarios for the February cycle (one with the low capacity assumption and one with the high capacity assumption). As a user of the application, I can decide to apply the low capacity scenario in production for February. For that, I promote my low capacity scenario as master for the February cycle.","title":"Cycle and Master scenario"},{"location":"manuals/core/user_core_concepts/#scope","text":"","title":"Scope"},{"location":"manuals/core/user_core_configuration/","text":"Taipy is an application builder. The purpose of configuring the application back end is to describe the user application entities and how they behave at runtime. In this documentation we first provide a complete description of the configuration attributes. In a second section, an example is proposed, showing how to create a standard Taipy configuration. Because multiple configuration methods are possible, we then provide a documentation of the configuration mechanism. Finally the method to export a configuration is described. Configuration attributes \u00b6 TODO JRM Add reference to the ref manual Describe config nodes (Global, job, data node, ...) The configuration includes configuration for global application, job executions, scenarios, pipelines, tasks and data nodes. As an example, the data node configurations may have name, storage type, credentials, format, path, scope, or any custom property. List all the fields and for each field provide possible values, examples Building a python configuration \u00b6 Configuration mechanism \u00b6 Here is a possible example of a workflow for the developer. Example First as a developer, I am designing and developing my taipy application. I don\u2019t really need to care about configuration, so I use the simple default configuration. Then, I am testing the application built. At this step, I need my application to have a more realistic behavior like real data. For that, I need more configuration. I can specify for my specific input dataset what file to use. I am using the Python code configuration for that. Then, once I am happy with my application running on local, I am deploying it to a remote environment for testing and debugging the application. This is on a dedicated environment made for testing deployment and for integration testing. I can use an explicit file configuration. I can easily update the file if necessary to be efficient in debugging, without changing the code directly. Once the step 3 is done, I want to be able to deploy a released and tagged version of my application on several remote environments (e.g. pre-production, production). I am creating one file per remote environment with a few values that differ from the step 3, and on each environment, I am setting a different environment variable value to point to the right configuration file. Four methods to configure taipy are possible: A default configuration A Python configuration A file configuration using TOML file format An environment variable configuration These methods are described below. Default configuration \u00b6 The first method is the default configuration and is directly provided by the Taipy library. It allows the developer to run the application in the most basic and standard way (running in localhost, storing data on the local file system, executing tasks sequentially and synchronously, ....). Nothing is needed from the user at this point. Here is the TOML export file of all (not None) default values : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 [ TAIPY ] root_folder = \"./taipy/\" storage_folder = \".data/\" [ JOB ] mode = \"standalone\" nb_of_workers = \"1\" hostname = \"localhost\" [ DATA_NODE . default ] storage_type = \"pickle\" scope = \"PIPELINE\" [ TASK . default ] inputs = [] outputs = [] [ PIPELINE . default ] tasks = [] [ SCENARIO . default ] pipelines = [] Python code configuration \u00b6 Then, a code configuration can be done on a Python file directly when designing the pipelines and scenarios. This configuration can be done by importing the taipy.Config class and calling the various methods. This python configuration is meant to be used during the application development phase. It overrides the default configuration: if some values are not provided, the default configuration applies. Example 1 2 dataset_cfg = Config . add_data_node ( name = \"dataset\" , storage_type = \"csv\" , path = \"./local/path/to/my/dataset.csv\" ) task_cfg = Config . add_task ( name = \"my_task\" , inputs = data_set_cfg , my_function , outputs = []) Explicit TOML file configuration \u00b6 Taipy also provides file configuration. Indeed, a TOML file can be explicitly provided by the developer to the Taipy application using Python coding such as : Config . load ( \"folder/config.toml\" ) This file configuration overrides the code configuration (and the default configuration). Here is an example of a TOML file : 1 2 3 4 5 6 7 8 9 10 11 12 13 [ TAIPY ] version = 0.5.5 [ JOB ] mode = \"standalone\" nb_of_workers = 5 [ DATA_NODE . Default ] storage_type = pickle [ DATA_NODE . dataset ] storage_type = csv path = \"remote/path/subfolder/file.csv\" Environment variable file configuration \u00b6 Finally, if the environment variable TAIPY_CONFIG_PATH is defined with the path of a TOML config, Taipy will automatically load the file and override the previous configurations (explicit file configuration, code configuration and default configuration). Exporting configuration \u00b6 Taipy also provides a method to export the configuration applied after the compilation of all the configurations (default, Python code, explicit file, and environment variable configurations) which is the result of the overwriting. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 [ TAIPY ] notification = false broker_endpoint = \"my_broker_end_point\" root_folder = \"./root/\" storage_folder = \"./data/\" [ JOB ] mode = \"standalone\" nb_of_workers = \"5\" [ DATA_NODE . default ] custom = \"default_custom_property\" [ DATA_NODE . dataset ] storage_type = \"csv\" custom = \"custom property\" Path = \"the/path/to/my/dataset.csv\" [ DATA_NODE . forecasts ] storage_type = \"csv\" Path = \"the/path/to/my/forecasts.csv\" [ DATA_NODE . date ] scope = \"SCENARIO\" default_data = \"15/03/2022\" [ TASK . t1 ] inputs = [ \"dataset\" , \"date\" ] outputs = [ \"forecasts\" ] description = \"my description\" [ PIPELINE . p1 ] tasks = [ \"t1\" ,] cron = \"daily\" [ SCENARIO . s1 ] pipelines = [ \"p1\" ,] frequency = \"DAILY\" owner = \"John Doe\" Environment variable \u00b6 Configuration can be set dynamically using environment variables through the syntax ENV[MY_VARIABLE] . At runtime, Taipy will search MY_VARIABLE in the environment variables then use it. This is especially useful if you want to use secret strings such as host names, user names or passwords. For example, if you are using Airflow as scheduler, you can hide the password from the configuration file using an environment variable: [JOB] airflow_password = \"ENV[PASS]\" Job execution configuration \u00b6 Standalone \u00b6 By default, Taipy execute each Task one by one synchronously. You can ensure this behavior by setting: [JOB] mode = \"standalone\" nb_of_workers = 1 To execute tasks in parallel, you can allow Taipy to use multiple processes by setting the nb_of_workers property to a positive integer greater then 1, for example: [JOB] mode = \"standalone\" nb_of_workers = 8 Using Airflow \u00b6 Taipy tasks can run with Airflow. For that, you need to specify: [JOB] mode = \"airflow\" Start Airflow from Taipy \u00b6 To start Airflow within Taipy, you can use the following configuration: [JOB] start_airflow = True By default, Airflow creates a local folder .airflow to store its dependencies. You can change this location with the airflow_folder config: [JOB] airflow_folder = \"my_custom_path\" Production setting Taipy starts Airflow in standalone mode. It is an Airflow development mode and not recommended for production. Use an external Airflow \u00b6 The default configuration is to use an external Airflow. You can specify it by setting: [JOB] start_airflow = False By default, Taipy is connected to Airflow on localhost:8080 . You can change it: [JOB] hostname = \"my_remote_airflow:port\" Taipy Task are converted in Airflow DAG through the Airflow DAG Folder. By default, this folder is .dags , but you can update it: [JOB] airflow_dags_folder = \"/dags\" Remote Airflow The Airflow Dag generation can only be accomplished through this folder. If Taipy and Airflow are not on the same machine or if Airflow uses remote workers, you should mount this folder as shared. Airflow can take time before loading DAGS . In order to wait for Airflow to be ready to schedule tasks, Taipy requests the scheduling several times until the request is actually accepted. Depending on your Airflow configuration, you can update the number of retries: [JOB] airflow_api_retry = 10 Taipy authentication with Airflow is based on basic_auth . If Airflow is not started by Taipy, you should provide this configuration: [JOB] airflow_user = \"user\" airflow_password = \"pass\" Security To ensure you are not exposing your company's secrets, we recommend using environment-based configuration for airflow_user and airflow_password .","title":"Core configuration"},{"location":"manuals/core/user_core_configuration/#configuration-attributes","text":"TODO JRM Add reference to the ref manual Describe config nodes (Global, job, data node, ...) The configuration includes configuration for global application, job executions, scenarios, pipelines, tasks and data nodes. As an example, the data node configurations may have name, storage type, credentials, format, path, scope, or any custom property. List all the fields and for each field provide possible values, examples","title":"Configuration attributes"},{"location":"manuals/core/user_core_configuration/#building-a-python-configuration","text":"","title":"Building a python configuration"},{"location":"manuals/core/user_core_configuration/#configuration-mechanism","text":"Here is a possible example of a workflow for the developer. Example First as a developer, I am designing and developing my taipy application. I don\u2019t really need to care about configuration, so I use the simple default configuration. Then, I am testing the application built. At this step, I need my application to have a more realistic behavior like real data. For that, I need more configuration. I can specify for my specific input dataset what file to use. I am using the Python code configuration for that. Then, once I am happy with my application running on local, I am deploying it to a remote environment for testing and debugging the application. This is on a dedicated environment made for testing deployment and for integration testing. I can use an explicit file configuration. I can easily update the file if necessary to be efficient in debugging, without changing the code directly. Once the step 3 is done, I want to be able to deploy a released and tagged version of my application on several remote environments (e.g. pre-production, production). I am creating one file per remote environment with a few values that differ from the step 3, and on each environment, I am setting a different environment variable value to point to the right configuration file. Four methods to configure taipy are possible: A default configuration A Python configuration A file configuration using TOML file format An environment variable configuration These methods are described below.","title":"Configuration mechanism"},{"location":"manuals/core/user_core_configuration/#default-configuration","text":"The first method is the default configuration and is directly provided by the Taipy library. It allows the developer to run the application in the most basic and standard way (running in localhost, storing data on the local file system, executing tasks sequentially and synchronously, ....). Nothing is needed from the user at this point. Here is the TOML export file of all (not None) default values : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 [ TAIPY ] root_folder = \"./taipy/\" storage_folder = \".data/\" [ JOB ] mode = \"standalone\" nb_of_workers = \"1\" hostname = \"localhost\" [ DATA_NODE . default ] storage_type = \"pickle\" scope = \"PIPELINE\" [ TASK . default ] inputs = [] outputs = [] [ PIPELINE . default ] tasks = [] [ SCENARIO . default ] pipelines = []","title":"Default configuration"},{"location":"manuals/core/user_core_configuration/#python-code-configuration","text":"Then, a code configuration can be done on a Python file directly when designing the pipelines and scenarios. This configuration can be done by importing the taipy.Config class and calling the various methods. This python configuration is meant to be used during the application development phase. It overrides the default configuration: if some values are not provided, the default configuration applies. Example 1 2 dataset_cfg = Config . add_data_node ( name = \"dataset\" , storage_type = \"csv\" , path = \"./local/path/to/my/dataset.csv\" ) task_cfg = Config . add_task ( name = \"my_task\" , inputs = data_set_cfg , my_function , outputs = [])","title":"Python code configuration"},{"location":"manuals/core/user_core_configuration/#explicit-toml-file-configuration","text":"Taipy also provides file configuration. Indeed, a TOML file can be explicitly provided by the developer to the Taipy application using Python coding such as : Config . load ( \"folder/config.toml\" ) This file configuration overrides the code configuration (and the default configuration). Here is an example of a TOML file : 1 2 3 4 5 6 7 8 9 10 11 12 13 [ TAIPY ] version = 0.5.5 [ JOB ] mode = \"standalone\" nb_of_workers = 5 [ DATA_NODE . Default ] storage_type = pickle [ DATA_NODE . dataset ] storage_type = csv path = \"remote/path/subfolder/file.csv\"","title":"Explicit TOML file configuration"},{"location":"manuals/core/user_core_configuration/#environment-variable-file-configuration","text":"Finally, if the environment variable TAIPY_CONFIG_PATH is defined with the path of a TOML config, Taipy will automatically load the file and override the previous configurations (explicit file configuration, code configuration and default configuration).","title":"Environment variable file configuration"},{"location":"manuals/core/user_core_configuration/#exporting-configuration","text":"Taipy also provides a method to export the configuration applied after the compilation of all the configurations (default, Python code, explicit file, and environment variable configurations) which is the result of the overwriting. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 [ TAIPY ] notification = false broker_endpoint = \"my_broker_end_point\" root_folder = \"./root/\" storage_folder = \"./data/\" [ JOB ] mode = \"standalone\" nb_of_workers = \"5\" [ DATA_NODE . default ] custom = \"default_custom_property\" [ DATA_NODE . dataset ] storage_type = \"csv\" custom = \"custom property\" Path = \"the/path/to/my/dataset.csv\" [ DATA_NODE . forecasts ] storage_type = \"csv\" Path = \"the/path/to/my/forecasts.csv\" [ DATA_NODE . date ] scope = \"SCENARIO\" default_data = \"15/03/2022\" [ TASK . t1 ] inputs = [ \"dataset\" , \"date\" ] outputs = [ \"forecasts\" ] description = \"my description\" [ PIPELINE . p1 ] tasks = [ \"t1\" ,] cron = \"daily\" [ SCENARIO . s1 ] pipelines = [ \"p1\" ,] frequency = \"DAILY\" owner = \"John Doe\"","title":"Exporting configuration"},{"location":"manuals/core/user_core_configuration/#environment-variable","text":"Configuration can be set dynamically using environment variables through the syntax ENV[MY_VARIABLE] . At runtime, Taipy will search MY_VARIABLE in the environment variables then use it. This is especially useful if you want to use secret strings such as host names, user names or passwords. For example, if you are using Airflow as scheduler, you can hide the password from the configuration file using an environment variable: [JOB] airflow_password = \"ENV[PASS]\"","title":"Environment variable"},{"location":"manuals/core/user_core_configuration/#job-execution-configuration","text":"","title":"Job execution configuration"},{"location":"manuals/core/user_core_configuration/#standalone","text":"By default, Taipy execute each Task one by one synchronously. You can ensure this behavior by setting: [JOB] mode = \"standalone\" nb_of_workers = 1 To execute tasks in parallel, you can allow Taipy to use multiple processes by setting the nb_of_workers property to a positive integer greater then 1, for example: [JOB] mode = \"standalone\" nb_of_workers = 8","title":"Standalone"},{"location":"manuals/core/user_core_configuration/#using-airflow","text":"Taipy tasks can run with Airflow. For that, you need to specify: [JOB] mode = \"airflow\"","title":"Using Airflow"},{"location":"manuals/core/user_core_configuration/#start-airflow-from-taipy","text":"To start Airflow within Taipy, you can use the following configuration: [JOB] start_airflow = True By default, Airflow creates a local folder .airflow to store its dependencies. You can change this location with the airflow_folder config: [JOB] airflow_folder = \"my_custom_path\" Production setting Taipy starts Airflow in standalone mode. It is an Airflow development mode and not recommended for production.","title":"Start Airflow from Taipy"},{"location":"manuals/core/user_core_configuration/#use-an-external-airflow","text":"The default configuration is to use an external Airflow. You can specify it by setting: [JOB] start_airflow = False By default, Taipy is connected to Airflow on localhost:8080 . You can change it: [JOB] hostname = \"my_remote_airflow:port\" Taipy Task are converted in Airflow DAG through the Airflow DAG Folder. By default, this folder is .dags , but you can update it: [JOB] airflow_dags_folder = \"/dags\" Remote Airflow The Airflow Dag generation can only be accomplished through this folder. If Taipy and Airflow are not on the same machine or if Airflow uses remote workers, you should mount this folder as shared. Airflow can take time before loading DAGS . In order to wait for Airflow to be ready to schedule tasks, Taipy requests the scheduling several times until the request is actually accepted. Depending on your Airflow configuration, you can update the number of retries: [JOB] airflow_api_retry = 10 Taipy authentication with Airflow is based on basic_auth . If Airflow is not started by Taipy, you should provide this configuration: [JOB] airflow_user = \"user\" airflow_password = \"pass\" Security To ensure you are not exposing your company's secrets, we recommend using environment-based configuration for airflow_user and airflow_password .","title":"Use an external Airflow"},{"location":"manuals/core/user_core_features/","text":"Cycle Management \u00b6 TODO JRM Scenario Management \u00b6 TODO JRM pipeline Management \u00b6 TODO JRM Task Management \u00b6 TODO JRM Data Management \u00b6 TODO JRM Scheduler \u00b6 TODO JRM","title":"Core features"},{"location":"manuals/core/user_core_features/#cycle-management","text":"TODO JRM","title":"Cycle Management"},{"location":"manuals/core/user_core_features/#scenario-management","text":"TODO JRM","title":"Scenario Management"},{"location":"manuals/core/user_core_features/#pipeline-management","text":"TODO JRM","title":"pipeline Management"},{"location":"manuals/core/user_core_features/#task-management","text":"TODO JRM","title":"Task Management"},{"location":"manuals/core/user_core_features/#data-management","text":"TODO JRM","title":"Data Management"},{"location":"manuals/core/user_core_features/#scheduler","text":"TODO JRM","title":"Scheduler"},{"location":"manuals/deployment/prepare-taipy-for-deployment/","text":"Prepare your application for deployment \u00b6 To be able to deploy a Taipy application you should specify some options in your GUI. These options will be provided from the environment with a default value to allow you to continue to work locally without impact. Options \u00b6 port: Binding port for your application. By default, Taipy used the port 5000 . client_url: Url used to fetch data from the front end side. By default, Taipy used localhost:5000 . host: Allows Taipy to listen to a public IP. Example \u00b6 In a standard local Taipy application, you should have something that looks like # Your code gui . run ( title = \"Taipy Demo\" ) To be able to run in a remote environment, you should transform this line in import os # Your code gui . run ( title = \"Taipy Demo\" , host = '0.0.0.0' , port = os . environ . get ( 'PORT' , '5000' ), client_url = os . environ . get ( 'CLIENT_URL' , 'localhost:5000' ) )","title":"Prepare your application for deployment"},{"location":"manuals/deployment/prepare-taipy-for-deployment/#prepare-your-application-for-deployment","text":"To be able to deploy a Taipy application you should specify some options in your GUI. These options will be provided from the environment with a default value to allow you to continue to work locally without impact.","title":"Prepare your application for deployment"},{"location":"manuals/deployment/prepare-taipy-for-deployment/#options","text":"port: Binding port for your application. By default, Taipy used the port 5000 . client_url: Url used to fetch data from the front end side. By default, Taipy used localhost:5000 . host: Allows Taipy to listen to a public IP.","title":"Options"},{"location":"manuals/deployment/prepare-taipy-for-deployment/#example","text":"In a standard local Taipy application, you should have something that looks like # Your code gui . run ( title = \"Taipy Demo\" ) To be able to run in a remote environment, you should transform this line in import os # Your code gui . run ( title = \"Taipy Demo\" , host = '0.0.0.0' , port = os . environ . get ( 'PORT' , '5000' ), client_url = os . environ . get ( 'CLIENT_URL' , 'localhost:5000' ) )","title":"Example"},{"location":"manuals/deployment/heroku/docker/","text":"Deploy a Dockerize Taipy application with Heroku \u00b6 Prerequisites \u00b6 Minimal knowledge in Docker. Docker should be installed. Check the official documentation for docker installation. Prepare your Taipy application Set up your Heroku environment 1. Create your Dockerfile \u00b6 Besides your application, you should create a Dockerfile that will allow Docker to build your container. Here is an example with main.py as the entry point of your application and requirements.txt file with all your dependencies (Taipy included): # Your Python version FROM python:3.9 # Install your application WORKDIR /app COPY . /app RUN pip install -r requirements.txt # Start up command CMD python demo8.py Note \u00b6 This Dockerfile is provided as an example and tested without security consideration, do not use it for a production environment. 2. Build and test your Docker \u00b6 At the same place of your Dockerfile, run the following command to create a Docker image named : docker build . -t <my-taipy-app> You can now run it with the command line: docker run -p 5000:5000 -d --name <my-taipy-app> <my-taipy-app> Open your browser and go on http://localhost:5000 -- a start up time can be present --. 3. Deployment \u00b6 In our example, we use the name <my-taipy-app> for our application. On Heroku, this name should be unique. So you should replace it everywhere by a custom value. heroku login heroku create <my-taipy-app> heroku container:login heroku container:push web -a <my-taipy-app> heroku config:set CLIENT_URL=\"https://<my-taipy-app>.herokuapp.com\" -a <my-taipy-app> heroku container:release web -a <my-taipy-app> 4. Check your deployment \u00b6 You can go on the url https://<my-taipy-app>.herokuapp.com with your browser or run heroku open -a <my-taipy-app> . Your application should be deployed correctly. 5. Clean your resources \u00b6 Stop the local docker container: docker stop <my-taipy-app> Remove the local docker container: docker rm <my-taipy-app> Remove the local docker image: docker rmi <my-taipy-app> Remove the Heroku application: heroku apps:destroy <my-taipy-app> --confirm <my-taipy-app>","title":"Based on Docker"},{"location":"manuals/deployment/heroku/docker/#deploy-a-dockerize-taipy-application-with-heroku","text":"","title":"Deploy a Dockerize Taipy application with Heroku"},{"location":"manuals/deployment/heroku/docker/#prerequisites","text":"Minimal knowledge in Docker. Docker should be installed. Check the official documentation for docker installation. Prepare your Taipy application Set up your Heroku environment","title":"Prerequisites"},{"location":"manuals/deployment/heroku/docker/#1-create-your-dockerfile","text":"Besides your application, you should create a Dockerfile that will allow Docker to build your container. Here is an example with main.py as the entry point of your application and requirements.txt file with all your dependencies (Taipy included): # Your Python version FROM python:3.9 # Install your application WORKDIR /app COPY . /app RUN pip install -r requirements.txt # Start up command CMD python demo8.py","title":"1. Create your Dockerfile"},{"location":"manuals/deployment/heroku/docker/#note","text":"This Dockerfile is provided as an example and tested without security consideration, do not use it for a production environment.","title":"Note"},{"location":"manuals/deployment/heroku/docker/#2-build-and-test-your-docker","text":"At the same place of your Dockerfile, run the following command to create a Docker image named : docker build . -t <my-taipy-app> You can now run it with the command line: docker run -p 5000:5000 -d --name <my-taipy-app> <my-taipy-app> Open your browser and go on http://localhost:5000 -- a start up time can be present --.","title":"2. Build and test your Docker"},{"location":"manuals/deployment/heroku/docker/#3-deployment","text":"In our example, we use the name <my-taipy-app> for our application. On Heroku, this name should be unique. So you should replace it everywhere by a custom value. heroku login heroku create <my-taipy-app> heroku container:login heroku container:push web -a <my-taipy-app> heroku config:set CLIENT_URL=\"https://<my-taipy-app>.herokuapp.com\" -a <my-taipy-app> heroku container:release web -a <my-taipy-app>","title":"3. Deployment"},{"location":"manuals/deployment/heroku/docker/#4-check-your-deployment","text":"You can go on the url https://<my-taipy-app>.herokuapp.com with your browser or run heroku open -a <my-taipy-app> . Your application should be deployed correctly.","title":"4. Check your deployment"},{"location":"manuals/deployment/heroku/docker/#5-clean-your-resources","text":"Stop the local docker container: docker stop <my-taipy-app> Remove the local docker container: docker rm <my-taipy-app> Remove the local docker image: docker rmi <my-taipy-app> Remove the Heroku application: heroku apps:destroy <my-taipy-app> --confirm <my-taipy-app>","title":"5. Clean your resources"},{"location":"manuals/deployment/heroku/getting-started/","text":"Deploy on Heroku \u00b6 Heroku is a Cloud provider that allows you to deploy dev and test app for free. The following documentation allows quick deployments on this platform for sharing applications. Important note \u00b6 This documentation is made for test and dev only. We do not recommend deploying applications in a production environment or sensitive data using this documentation! Summary \u00b6 Prepare your application for deployment Set up your Heroku environment. Deploy your application with a deployment based on Git. Deploy your application with a deployment based on Docker.","title":"Getting started"},{"location":"manuals/deployment/heroku/getting-started/#deploy-on-heroku","text":"Heroku is a Cloud provider that allows you to deploy dev and test app for free. The following documentation allows quick deployments on this platform for sharing applications.","title":"Deploy on Heroku"},{"location":"manuals/deployment/heroku/getting-started/#important-note","text":"This documentation is made for test and dev only. We do not recommend deploying applications in a production environment or sensitive data using this documentation!","title":"Important note"},{"location":"manuals/deployment/heroku/getting-started/#summary","text":"Prepare your application for deployment Set up your Heroku environment. Deploy your application with a deployment based on Git. Deploy your application with a deployment based on Docker.","title":"Summary"},{"location":"manuals/deployment/heroku/git/","text":"Deploy a Taipy application based on git with Heroku \u00b6 Prerequisite \u00b6 Minimal knowledge in Git. Git should be installed, otherwise check the official documentation . Prepare your Taipy application Set up your Heroku environment 1. Add version control on your application \u00b6 Note: This step is necessary only if your application doesn't already use Git. git init git config [--global] user.name \"Full Name\" git config [--global] user.email \"email@address.com\" git add . git commit -m \"My first commit\" 2. Prepare your stack \u00b6 To be able to run your app, Heroku will need the following files: runtime.txt : the version of Python you want to use. You can find the list of available version at Heroku supported versions of Python . For example, put in your runtime.txt : python-3.9.10 Now you should save this file in your git repository by doing: git add runtime.txt git commit -m \"Add Heroku runtime requirement\" Procfile : command launched by Heroku to start your application. If your entrypoint file is main.py , put in your Procfile : web: python main.py Now you should save this file in your git repository by doing: git add Procfile git commit -m \"Add Heroku Procfile requirement\" requirements.txt : your dependencies file. See Virtual environments for details. Note: If you already have a requirements.txt file up to date in your Git, you can ignore this step. You can create this file by dumping all your dependencies then commit the file by doing: pip freeze > requirements.txt git add requirements.txt git commit -m \"Add dependencies file\" 3. Deployment \u00b6 In our example, we use the name my-taipy-app for our application. On Heroku, this name should be unique. So you should replace it everywhere by a custom value. heroku login heroku create my-taipy-app heroku git:remote -a <my-taipy-app> heroku config:set CLIENT_URL=\"https://<my-taipy-app>.herokuapp.com\" -a <my-taipy-app> git push heroku main Note: This example works if you are working on the main branch. If you are working on another branch you should probably do git push heroku my-branch:main check the official Heroku doc . 4. Check your deployment \u00b6 You can go on the url https://<my-taipy-app>.herokuapp.com with your browser or run heroku open -a <my-taipy-app> . Your application should be deployed correctly. 5. Clean your resources \u00b6 Remove the Heroku application: heroku apps:destroy <my-taipy-app> --confirm <my-taipy-app>","title":"Based on Git"},{"location":"manuals/deployment/heroku/git/#deploy-a-taipy-application-based-on-git-with-heroku","text":"","title":"Deploy a Taipy application based on git with Heroku"},{"location":"manuals/deployment/heroku/git/#prerequisite","text":"Minimal knowledge in Git. Git should be installed, otherwise check the official documentation . Prepare your Taipy application Set up your Heroku environment","title":"Prerequisite"},{"location":"manuals/deployment/heroku/git/#1-add-version-control-on-your-application","text":"Note: This step is necessary only if your application doesn't already use Git. git init git config [--global] user.name \"Full Name\" git config [--global] user.email \"email@address.com\" git add . git commit -m \"My first commit\"","title":"1. Add version control on your application"},{"location":"manuals/deployment/heroku/git/#2-prepare-your-stack","text":"To be able to run your app, Heroku will need the following files: runtime.txt : the version of Python you want to use. You can find the list of available version at Heroku supported versions of Python . For example, put in your runtime.txt : python-3.9.10 Now you should save this file in your git repository by doing: git add runtime.txt git commit -m \"Add Heroku runtime requirement\" Procfile : command launched by Heroku to start your application. If your entrypoint file is main.py , put in your Procfile : web: python main.py Now you should save this file in your git repository by doing: git add Procfile git commit -m \"Add Heroku Procfile requirement\" requirements.txt : your dependencies file. See Virtual environments for details. Note: If you already have a requirements.txt file up to date in your Git, you can ignore this step. You can create this file by dumping all your dependencies then commit the file by doing: pip freeze > requirements.txt git add requirements.txt git commit -m \"Add dependencies file\"","title":"2. Prepare your stack"},{"location":"manuals/deployment/heroku/git/#3-deployment","text":"In our example, we use the name my-taipy-app for our application. On Heroku, this name should be unique. So you should replace it everywhere by a custom value. heroku login heroku create my-taipy-app heroku git:remote -a <my-taipy-app> heroku config:set CLIENT_URL=\"https://<my-taipy-app>.herokuapp.com\" -a <my-taipy-app> git push heroku main Note: This example works if you are working on the main branch. If you are working on another branch you should probably do git push heroku my-branch:main check the official Heroku doc .","title":"3. Deployment"},{"location":"manuals/deployment/heroku/git/#4-check-your-deployment","text":"You can go on the url https://<my-taipy-app>.herokuapp.com with your browser or run heroku open -a <my-taipy-app> . Your application should be deployed correctly.","title":"4. Check your deployment"},{"location":"manuals/deployment/heroku/git/#5-clean-your-resources","text":"Remove the Heroku application: heroku apps:destroy <my-taipy-app> --confirm <my-taipy-app>","title":"5. Clean your resources"},{"location":"manuals/deployment/heroku/setup/","text":"Heroku setup \u00b6 1. Create an account on Heroku \u00b6 Go on Heroku Signup to create an account on Heroku. 2. Install the Heroku CLI \u00b6 To run commands that will provision your infrastructure, you should install the Heroku CLI. The complete documentation is available on the Heroku CLI page.","title":"Setup"},{"location":"manuals/deployment/heroku/setup/#heroku-setup","text":"","title":"Heroku setup"},{"location":"manuals/deployment/heroku/setup/#1-create-an-account-on-heroku","text":"Go on Heroku Signup to create an account on Heroku.","title":"1. Create an account on Heroku"},{"location":"manuals/deployment/heroku/setup/#2-install-the-heroku-cli","text":"To run commands that will provision your infrastructure, you should install the Heroku CLI. The complete documentation is available on the Heroku CLI page.","title":"2. Install the Heroku CLI"},{"location":"manuals/docker/Dockerfile/","text":"FROM python:3.9 as taipy # Web port of the application EXPOSE 5000 # Install your application WORKDIR /opt/airflow COPY . . RUN pip install -r requirements.txt RUN pip install pip install 'apache-airflow==2.2.3' \\ --constraint \"https://raw.githubusercontent.com/apache/airflow/constraints-2.2.3/constraints-3.9.txt\" RUN mkdir -p /app/data && chmod -R 777 /app/data RUN useradd -ms /bin/bash airflow USER airflow CMD python demo_cli.py FROM apache/airflow:latest-python3.9 as airflow USER root RUN apt update -y RUN apt install -y git USER airflow COPY . . RUN pip install -r requirements.txt RUN pip install --upgrade numpy ENV PYTHONPATH=/opt/airflow","title":"Dockerfile"},{"location":"manuals/docker/airflow/","text":"Taipy application with Airflow \u00b6 Prerequisites \u00b6 Minimal knowledge in Docker. Docker should be installed. Check the official documentation for Docker installation. Docker-compose should be installed. Check the official documentation for docker-compose installation. Had done the Getting-Started Airflow and Taipy in the same container \u00b6 The simplest way to try your Taipy application with Airflow is to let Taipy start Airflow by itself. To do that, you must install the Airflow dependencies in the container itself. Replace your Dockerfile by the following: # Your Python version FROM python:3.9 # Web port of the application EXPOSE 5000 # Install your application WORKDIR /app COPY . /app RUN pip install -r requirements.txt RUN pip install pip install 'apache-airflow==2.2.3' \\ --constraint \"https://raw.githubusercontent.com/apache/airflow/constraints-2.2.3/constraints-3.9.txt\" # Start up command CMD python my-app.py Then you should specify in your configuration Airflow as scheduler. [JOB] mode = \"airflow\" hostname = \"http://localhost:8080\" start_airflow = true Airflow and Taipy in different containers \u00b6 The Apache Airflow community provides an official docker-compose file . However, Taipy needs an custom version of this file, that you download from this link . Please download this file and copy it next to your main application file. Docker-compose minimal version Make sure that the version is greater or equal to 1.29 . Custom image \u00b6 To run your application, you must provide Airflow a custom image that contains all the Airflow dependencies. Everything is already packaged in this Dockerfile . Please download it and copy it next to the main application source file. Update your configuration with the parameters below to allow the communication between Airflow and Taipy. [TAIPY] storage_folder = \"/app/data\" [JOB] mode = \"airflow\" hostname = \"http://airflow-webserver:8080\" start_airflow = false airflow_api_retry = 100 airflow_dags_folder=\"/app/dags\" airflow_user=\"airflow\" airflow_password=\"airflow\" If you run on Linux You should first run the following commands ( For more information click here ): mkdir -p ./dags ./logs ./plugins echo -e \"AIRFLOW_UID=$(id -u)\" > .env Before you run your application, you must create the Airflow database using the command: docker-compose up airflow-init Then, you can run your application by doing: docker-compose up -d --build You can access the Airflow server at http://0.0.0.0:8080/home . The default value for both the user name and the password is airflow . Because the initialization of Airflow can be lengthy, the server URL may not be available before a couple of minutes. If your application has a Taipy user interface, you can connect to it at http://0.0.0.0:5000 . You can clean all resources by doing: docker-compose down --volumes --remove-orphans","title":"Running with Airflow"},{"location":"manuals/docker/airflow/#taipy-application-with-airflow","text":"","title":"Taipy application with Airflow"},{"location":"manuals/docker/airflow/#prerequisites","text":"Minimal knowledge in Docker. Docker should be installed. Check the official documentation for Docker installation. Docker-compose should be installed. Check the official documentation for docker-compose installation. Had done the Getting-Started","title":"Prerequisites"},{"location":"manuals/docker/airflow/#airflow-and-taipy-in-the-same-container","text":"The simplest way to try your Taipy application with Airflow is to let Taipy start Airflow by itself. To do that, you must install the Airflow dependencies in the container itself. Replace your Dockerfile by the following: # Your Python version FROM python:3.9 # Web port of the application EXPOSE 5000 # Install your application WORKDIR /app COPY . /app RUN pip install -r requirements.txt RUN pip install pip install 'apache-airflow==2.2.3' \\ --constraint \"https://raw.githubusercontent.com/apache/airflow/constraints-2.2.3/constraints-3.9.txt\" # Start up command CMD python my-app.py Then you should specify in your configuration Airflow as scheduler. [JOB] mode = \"airflow\" hostname = \"http://localhost:8080\" start_airflow = true","title":"Airflow and Taipy in the same container"},{"location":"manuals/docker/airflow/#airflow-and-taipy-in-different-containers","text":"The Apache Airflow community provides an official docker-compose file . However, Taipy needs an custom version of this file, that you download from this link . Please download this file and copy it next to your main application file. Docker-compose minimal version Make sure that the version is greater or equal to 1.29 .","title":"Airflow and Taipy in different containers"},{"location":"manuals/docker/airflow/#custom-image","text":"To run your application, you must provide Airflow a custom image that contains all the Airflow dependencies. Everything is already packaged in this Dockerfile . Please download it and copy it next to the main application source file. Update your configuration with the parameters below to allow the communication between Airflow and Taipy. [TAIPY] storage_folder = \"/app/data\" [JOB] mode = \"airflow\" hostname = \"http://airflow-webserver:8080\" start_airflow = false airflow_api_retry = 100 airflow_dags_folder=\"/app/dags\" airflow_user=\"airflow\" airflow_password=\"airflow\" If you run on Linux You should first run the following commands ( For more information click here ): mkdir -p ./dags ./logs ./plugins echo -e \"AIRFLOW_UID=$(id -u)\" > .env Before you run your application, you must create the Airflow database using the command: docker-compose up airflow-init Then, you can run your application by doing: docker-compose up -d --build You can access the Airflow server at http://0.0.0.0:8080/home . The default value for both the user name and the password is airflow . Because the initialization of Airflow can be lengthy, the server URL may not be available before a couple of minutes. If your application has a Taipy user interface, you can connect to it at http://0.0.0.0:5000 . You can clean all resources by doing: docker-compose down --volumes --remove-orphans","title":"Custom image"},{"location":"manuals/docker/docker-compose.yml/","text":"# Licensed to the Apache Software Foundation (ASF) under one # or more contributor license agreements. See the NOTICE file # distributed with this work for additional information # regarding copyright ownership. The ASF licenses this file # to you under the Apache License, Version 2.0 (the # \"License\"); you may not use this file except in compliance # with the License. You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, # software distributed under the License is distributed on an # \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY # KIND, either express or implied. See the License for the # specific language governing permissions and limitations # under the License. # # Basic Airflow cluster configuration for CeleryExecutor with Redis and PostgreSQL. # # WARNING: This configuration is for local development. Do not use it in a production deployment. # # This configuration supports basic configuration using environment variables or an .env file # The following variables are supported: # # AIRFLOW_IMAGE_NAME - Docker image name used to run Airflow. # Default: apache/airflow:2.2.3 # AIRFLOW_UID - User ID in Airflow containers # Default: 50000 # Those configurations are useful mostly in case of standalone testing/running Airflow in test/try-out mode # # _AIRFLOW_WWW_USER_USERNAME - Username for the administrator account (if requested). # Default: airflow # _AIRFLOW_WWW_USER_PASSWORD - Password for the administrator account (if requested). # Default: airflow # _PIP_ADDITIONAL_REQUIREMENTS - Additional PIP requirements to add when starting all containers. # Default: '' # # Feel free to modify this file to suit your needs. --- version: '3' x-airflow-common: &airflow-common # In order to add custom dependencies or upgrade provider packages you can use your extended image. # Comment the image line, place your Dockerfile in the directory where you placed the docker-compose.yaml # and uncomment the \"build\" line below, Then run `docker-compose build` to build the images. #${AIRFLOW_IMAGE_NAME:-apache/airflow:2.2.3} image: custom-airflow build: context: . target: airflow environment: &airflow-common-env AIRFLOW__CORE__EXECUTOR: CeleryExecutor AIRFLOW__CORE__SQL_ALCHEMY_CONN: postgresql+psycopg2://airflow:airflow@postgres/airflow AIRFLOW__CELERY__RESULT_BACKEND: db+postgresql://airflow:airflow@postgres/airflow AIRFLOW__CELERY__BROKER_URL: redis://:@redis:6379/0 AIRFLOW__CORE__FERNET_KEY: '' AIRFLOW__CORE__DAGS_ARE_PAUSED_AT_CREATION: 'true' AIRFLOW__CORE__LOAD_EXAMPLES: 'true' AIRFLOW__API__AUTH_BACKEND: 'airflow.api.auth.backend.basic_auth' _PIP_ADDITIONAL_REQUIREMENTS: ${_PIP_ADDITIONAL_REQUIREMENTS:-} volumes: - ./dags:/opt/airflow/dags - ./logs:/opt/airflow/logs - ./plugins:/opt/airflow/plugins - application-data:/app/data user: \"${AIRFLOW_UID:-50000}:0\" depends_on: &airflow-common-depends-on redis: condition: service_healthy postgres: condition: service_healthy services: taipy: build: context: . target: taipy ports: - \"5000:5000\" volumes: - ./dags:/app/dags - application-data:/app/data user: \"${AIRFLOW_UID:-50000}:0\" depends_on: <<: *airflow-common-depends-on airflow-init: condition: service_completed_successfully postgres: image: postgres:13 environment: POSTGRES_USER: airflow POSTGRES_PASSWORD: airflow POSTGRES_DB: airflow volumes: - postgres-db-volume:/var/lib/postgresql/data healthcheck: test: [\"CMD\", \"pg_isready\", \"-U\", \"airflow\"] interval: 5s retries: 5 restart: always redis: image: redis:latest expose: - 6379 healthcheck: test: [\"CMD\", \"redis-cli\", \"ping\"] interval: 5s timeout: 30s retries: 50 restart: always airflow-webserver: <<: *airflow-common command: webserver ports: - 8080:8080 healthcheck: test: [\"CMD\", \"curl\", \"--fail\", \"http://localhost:8080/health\"] interval: 10s timeout: 10s retries: 5 restart: always depends_on: <<: *airflow-common-depends-on airflow-init: condition: service_completed_successfully airflow-scheduler: <<: *airflow-common command: scheduler healthcheck: test: [\"CMD-SHELL\", 'airflow jobs check --job-type SchedulerJob --hostname \"$${HOSTNAME}\"'] interval: 10s timeout: 10s retries: 5 restart: always depends_on: <<: *airflow-common-depends-on airflow-init: condition: service_completed_successfully airflow-worker: <<: *airflow-common command: celery worker healthcheck: test: - \"CMD-SHELL\" - 'celery --app airflow.executors.celery_executor.app inspect ping -d \"celery@$${HOSTNAME}\"' interval: 10s timeout: 10s retries: 5 environment: <<: *airflow-common-env # Required to handle warm shutdown of the Celery workers properly # See https://airflow.apache.org/docs/docker-stack/entrypoint.html#signal-propagation DUMB_INIT_SETSID: \"0\" restart: always depends_on: <<: *airflow-common-depends-on airflow-init: condition: service_completed_successfully airflow-triggerer: <<: *airflow-common command: triggerer healthcheck: test: [\"CMD-SHELL\", 'airflow jobs check --job-type TriggererJob --hostname \"$${HOSTNAME}\"'] interval: 10s timeout: 10s retries: 5 restart: always depends_on: <<: *airflow-common-depends-on airflow-init: condition: service_completed_successfully airflow-init: <<: *airflow-common entrypoint: /bin/bash # yamllint disable rule:line-length command: - -c - | function ver() { printf \"%04d%04d%04d%04d\" $${1//./ } } airflow_version=$$(gosu airflow airflow version) airflow_version_comparable=$$(ver $${airflow_version}) min_airflow_version=2.2.0 min_airflow_version_comparable=$$(ver $${min_airflow_version}) if (( airflow_version_comparable < min_airflow_version_comparable )); then echo echo -e \"\\033[1;31mERROR!!!: Too old Airflow version $${airflow_version}.\\e[0m\" echo \"The minimum Airflow version supported: $${min_airflow_version}. Only use this or higher!\" echo exit 1 fi if [[ -z \"${AIRFLOW_UID}\" ]]; then echo echo -e \"\\033[1;33mWARNING: AIRFLOW_UID not set!\\e[0m\" echo \"If you are on Linux, you must follow the instructions below to set \" echo \"AIRFLOW_UID environment variable, otherwise files will be owned by root.\" echo \"For other operating systems you can get rid of the warning with manually created .env file:\" echo \" See: https://airflow.apache.org/docs/apache-airflow/stable/start/docker.html#setting-the-right-airflow-user\" echo fi one_meg=1048576 mem_available=$$(($$(getconf _PHYS_PAGES) * $$(getconf PAGE_SIZE) / one_meg)) cpus_available=$$(grep -cE 'cpu[0-9]+' /proc/stat) disk_available=$$(df / | tail -1 | awk '{print $$4}') warning_resources=\"false\" if (( mem_available < 4000 )) ; then echo echo -e \"\\033[1;33mWARNING: Not enough memory available for Docker.\\e[0m\" echo \"At least 4GB of memory required. You have $$(numfmt --to iec $$((mem_available * one_meg)))\" echo warning_resources=\"true\" fi if (( cpus_available < 2 )); then echo echo -e \"\\033[1;33mWARNING: Not enough CPUS available for Docker.\\e[0m\" echo \"At least 2 CPUs recommended. You have $${cpus_available}\" echo warning_resources=\"true\" fi if (( disk_available < one_meg * 10 )); then echo echo -e \"\\033[1;33mWARNING: Not enough Disk space available for Docker.\\e[0m\" echo \"At least 10 GBs recommended. You have $$(numfmt --to iec $$((disk_available * 1024 )))\" echo warning_resources=\"true\" fi if [[ $${warning_resources} == \"true\" ]]; then echo echo -e \"\\033[1;33mWARNING: You have not enough resources to run Airflow (see above)!\\e[0m\" echo \"Please follow the instructions to increase the available resources:\" echo \" https://airflow.apache.org/docs/apache-airflow/stable/start/docker.html#before-you-begin\" echo fi mkdir -p /sources/logs /sources/dags /sources/plugins chown -R \"${AIRFLOW_UID}:0\" /sources/{logs,dags,plugins} exec /entrypoint airflow version # yamllint enable rule:line-length environment: <<: *airflow-common-env _AIRFLOW_DB_UPGRADE: 'true' _AIRFLOW_WWW_USER_CREATE: 'true' _AIRFLOW_WWW_USER_USERNAME: ${_AIRFLOW_WWW_USER_USERNAME:-airflow} _AIRFLOW_WWW_USER_PASSWORD: ${_AIRFLOW_WWW_USER_PASSWORD:-airflow} user: \"0:0\" volumes: - .:/sources airflow-cli: <<: *airflow-common profiles: - debug environment: <<: *airflow-common-env CONNECTION_CHECK_MAX_COUNT: \"0\" # Workaround for entrypoint issue. See: https://github.com/apache/airflow/issues/16252 command: - bash - -c - airflow flower: <<: *airflow-common command: celery flower ports: - 5555:5555 healthcheck: test: [\"CMD\", \"curl\", \"--fail\", \"http://localhost:5555/\"] interval: 10s timeout: 10s retries: 5 restart: always depends_on: <<: *airflow-common-depends-on airflow-init: condition: service_completed_successfully volumes: postgres-db-volume: application-data:","title":"Docker compose.yml"},{"location":"manuals/docker/standalone/","text":"Standalone Taipy application \u00b6 Prerequisites \u00b6 Minimal knowledge in Docker. Docker must be installed. Check the official documentation for docker installation. Docker-compose must be installed. Check the official documentation for docker-compose installation. Important information: The following setup is designed for development and testing. It does not target a production deployment. Basic Taipy Dockerfile \u00b6 The following example allows you to run your application inside a Docker container. # Your Python version FROM python:3.9 # Web port of the application EXPOSE 5000 # Install your application WORKDIR /app COPY . /app RUN pip install -r requirements.txt # Start up command CMD python my-app.py Build the container using the command: docker build -t my-taipy-app . When the container is ready, you can run it in the background with the command: docker run -p 5000:5000 -d --name my-taipy-app my-taipy-app Then go on http://localhost:5000 . Note that the -p option indicates the port number binding the container and the host. To stop the container, use the command: docker stop my-taipy-app You can remove the container from docker with the command: docker rm my-taipy-app Then you can delete the container imager with the command: docker rmi my-taipy-app Simplify build with docker-compose \u00b6 You can also wrap your build and run steps with docker-compose . Create a docker-compose.yml with the following content: version : \"3.9\" services : taipy : build : . ports : - \"5000:5000\" You can build and run your application with: docker-compose up --build -d Then go on http://localhost:5000 . You can clean all resources by doing: docker-compose down --remove-orphans .","title":"Standalone Application"},{"location":"manuals/docker/standalone/#standalone-taipy-application","text":"","title":"Standalone Taipy application"},{"location":"manuals/docker/standalone/#prerequisites","text":"Minimal knowledge in Docker. Docker must be installed. Check the official documentation for docker installation. Docker-compose must be installed. Check the official documentation for docker-compose installation. Important information: The following setup is designed for development and testing. It does not target a production deployment.","title":"Prerequisites"},{"location":"manuals/docker/standalone/#basic-taipy-dockerfile","text":"The following example allows you to run your application inside a Docker container. # Your Python version FROM python:3.9 # Web port of the application EXPOSE 5000 # Install your application WORKDIR /app COPY . /app RUN pip install -r requirements.txt # Start up command CMD python my-app.py Build the container using the command: docker build -t my-taipy-app . When the container is ready, you can run it in the background with the command: docker run -p 5000:5000 -d --name my-taipy-app my-taipy-app Then go on http://localhost:5000 . Note that the -p option indicates the port number binding the container and the host. To stop the container, use the command: docker stop my-taipy-app You can remove the container from docker with the command: docker rm my-taipy-app Then you can delete the container imager with the command: docker rmi my-taipy-app","title":"Basic Taipy Dockerfile"},{"location":"manuals/docker/standalone/#simplify-build-with-docker-compose","text":"You can also wrap your build and run steps with docker-compose . Create a docker-compose.yml with the following content: version : \"3.9\" services : taipy : build : . ports : - \"5000:5000\" You can build and run your application with: docker-compose up --build -d Then go on http://localhost:5000 . You can clean all resources by doing: docker-compose down --remove-orphans .","title":"Simplify build with docker-compose"},{"location":"manuals/gui/user/","text":"About \u00b6 Taipy can generate a graphical user interface for you, if you need one. What is a graphical user interface \u00b6 A graphical user interface is made of generated Web pages that are served by a Web server hosted by the Taipy application itself (or on which the Taipy application relies). This server and its settings are handled by the Gui object . How is the Graphical User Interface generated \u00b6 The generated Web pages are build from a set of template text files that you provide, where you would have planted placeholders that will display application data, in different ways, and let final users of the application interact with it. We call these representative and interactive objects: controls . In order to describe the content of pages, Taipy comes the support for two template formats, handled by the classes Markdown and Html . The basic principle is that you create pages as you need them, give them a name so you can point your browser to show them, and provide them to a Gui instance used in your application. When the run() method of the Gui instance is invoked, a Web client can connect to the underlying Web server and request for a given page. At this time, Taipy transforms the page that you had created into some HTML content that is sent to the client so the user can see the application interface. You can find more information on how pages are created and used in Taipy application in the Pages section.","title":"About"},{"location":"manuals/gui/user/#about","text":"Taipy can generate a graphical user interface for you, if you need one.","title":"About"},{"location":"manuals/gui/user/#what-is-a-graphical-user-interface","text":"A graphical user interface is made of generated Web pages that are served by a Web server hosted by the Taipy application itself (or on which the Taipy application relies). This server and its settings are handled by the Gui object .","title":"What is a graphical user interface"},{"location":"manuals/gui/user/#how-is-the-graphical-user-interface-generated","text":"The generated Web pages are build from a set of template text files that you provide, where you would have planted placeholders that will display application data, in different ways, and let final users of the application interact with it. We call these representative and interactive objects: controls . In order to describe the content of pages, Taipy comes the support for two template formats, handled by the classes Markdown and Html . The basic principle is that you create pages as you need them, give them a name so you can point your browser to show them, and provide them to a Gui instance used in your application. When the run() method of the Gui instance is invoked, a Web client can connect to the underlying Web server and request for a given page. At this time, Taipy transforms the page that you had created into some HTML content that is sent to the client so the user can see the application interface. You can find more information on how pages are created and used in Taipy application in the Pages section.","title":"How is the Graphical User Interface generated"},{"location":"manuals/gui/user_binding/","text":"Binding variables \u00b6 Sometimes, you will want to display information that comes from your application. To achieve this goal, Taipy allows visual elements to relate directly to your application variables, display their values, and even change those variable values. Consider the following application: 1 2 3 4 5 6 7 8 9 10 11 12 13 from taipy.gui import Gui page = \"\"\" # Hello Taipy The variable `x` contains the value <| {x} |>. \"\"\" x = 1234 gui = Gui ( page ) if __name__ == '__main__' : gui . run () When this program runs (and a Web browser is directed to the running server), the root page displays the value of the variable x , directly from your code. Expressions \u00b6 Values that you can use in controls and blocks can be more than raw variable values. You can create complete expressions, just like you would use in the f-string feature (available since Python 3). In the code above, simply replace <|{x}|> by <|{x*2}|> , and the double of x will be displayed in your page. Note You can create complex expressions such as |{x} and {y}| to concatenate two variable values, or whatever your imagination and application requirements are. Lambda expressions \u00b6 Some control properties can be assigned lambda expression to simplify the code. TODO: provide a simple example of a lambda expression usage","title":"Binding variables"},{"location":"manuals/gui/user_binding/#binding-variables","text":"Sometimes, you will want to display information that comes from your application. To achieve this goal, Taipy allows visual elements to relate directly to your application variables, display their values, and even change those variable values. Consider the following application: 1 2 3 4 5 6 7 8 9 10 11 12 13 from taipy.gui import Gui page = \"\"\" # Hello Taipy The variable `x` contains the value <| {x} |>. \"\"\" x = 1234 gui = Gui ( page ) if __name__ == '__main__' : gui . run () When this program runs (and a Web browser is directed to the running server), the root page displays the value of the variable x , directly from your code.","title":"Binding variables"},{"location":"manuals/gui/user_binding/#expressions","text":"Values that you can use in controls and blocks can be more than raw variable values. You can create complete expressions, just like you would use in the f-string feature (available since Python 3). In the code above, simply replace <|{x}|> by <|{x*2}|> , and the double of x will be displayed in your page. Note You can create complex expressions such as |{x} and {y}| to concatenate two variable values, or whatever your imagination and application requirements are.","title":"Expressions"},{"location":"manuals/gui/user_binding/#lambda-expressions","text":"Some control properties can be assigned lambda expression to simplify the code. TODO: provide a simple example of a lambda expression usage","title":"Lambda expressions"},{"location":"manuals/gui/user_blocks/","text":"Blocks \u00b6 Blocks are visual elements that allow for grouping user interface elements. Blocks list \u00b6 Here is the list of all available block elements in Taipy: part Displays its children in a block. expandable Displays its child elements in a collapsable area. layout Organizes its children into cells in a regular grid. pane A side pane.","title":"Blocks"},{"location":"manuals/gui/user_blocks/#blocks","text":"Blocks are visual elements that allow for grouping user interface elements.","title":"Blocks"},{"location":"manuals/gui/user_blocks/#blocks-list","text":"Here is the list of all available block elements in Taipy: part Displays its children in a block. expandable Displays its child elements in a collapsable area. layout Organizes its children into cells in a regular grid. pane A side pane.","title":"Blocks list"},{"location":"manuals/gui/user_callbacks/","text":"Callbacks \u00b6 Callbacks are functions that you create in your application, that are meant to be invoked in response to user actions in generated pages, or other events that the Web browser requires that the application takes care of. Variable value change \u00b6 Some controls (such as input or slider ) let the user modify the value they hold. Because you may want to control what that new value is, and decide whether to use as such or not, a callback function is called in your application when the user activates the control so as to change its value. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from taipy.gui import Gui md = \"\"\" # Hello Taipy The variable `x` is here: <| {x} |slider|>. \"\"\" x = 50 def on_change ( gui , var , val ): if var == \"x\" : print ( f \"'x' was changed to: { x } \" ) Gui ( page = md ) . run () Once in your function body, you can check the new value for the variable, and decide what to do with it: maybe you will need to trigger some other code to propagate the side effects of the variable value being changed. If you need to reset the value displayed at this moment, you can simply change the variable value, assuming you use the gui. (or any other variable name you have set the Gui instance to) prefix when referring to that variable. In our example, that would be gui.x . Actions \u00b6 Controls like buttons don't notify of any value change. Instead, they use callbacks to let the application knows that the user activated them somehow. Example 1 2 3 4 5 6 7 8 9 10 11 12 from taipy.gui import Gui md = \"\"\" # Hello Taipy Press <|THIS|button|> button. \"\"\" def on_action ( gui , id , action ): print ( \"The button was pressed!\" ) Gui ( page = md ) . run () The default behavior for these controls is to call the on_action function within your code, if there is one.","title":"Callbacks"},{"location":"manuals/gui/user_callbacks/#callbacks","text":"Callbacks are functions that you create in your application, that are meant to be invoked in response to user actions in generated pages, or other events that the Web browser requires that the application takes care of.","title":"Callbacks"},{"location":"manuals/gui/user_callbacks/#variable-value-change","text":"Some controls (such as input or slider ) let the user modify the value they hold. Because you may want to control what that new value is, and decide whether to use as such or not, a callback function is called in your application when the user activates the control so as to change its value. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from taipy.gui import Gui md = \"\"\" # Hello Taipy The variable `x` is here: <| {x} |slider|>. \"\"\" x = 50 def on_change ( gui , var , val ): if var == \"x\" : print ( f \"'x' was changed to: { x } \" ) Gui ( page = md ) . run () Once in your function body, you can check the new value for the variable, and decide what to do with it: maybe you will need to trigger some other code to propagate the side effects of the variable value being changed. If you need to reset the value displayed at this moment, you can simply change the variable value, assuming you use the gui. (or any other variable name you have set the Gui instance to) prefix when referring to that variable. In our example, that would be gui.x .","title":"Variable value change"},{"location":"manuals/gui/user_callbacks/#actions","text":"Controls like buttons don't notify of any value change. Instead, they use callbacks to let the application knows that the user activated them somehow. Example 1 2 3 4 5 6 7 8 9 10 11 12 from taipy.gui import Gui md = \"\"\" # Hello Taipy Press <|THIS|button|> button. \"\"\" def on_action ( gui , id , action ): print ( \"The button was pressed!\" ) Gui ( page = md ) . run () The default behavior for these controls is to call the on_action function within your code, if there is one.","title":"Actions"},{"location":"manuals/gui/user_controls/","text":"Controls \u00b6 Controls are user interface objects that represent data. Controls list \u00b6 Here is the list of all available controls in Taipy: text Displays a value as a static text. button A control that can trigger a function when pressed. input A control that displays some text that can potentially be edited. number A kind of [`input`](input.md) that handles numbers. slider Displays and allows the user to set a value within a range. toggle A series of toggle buttons that the user can select. date_selector A control that can display and specified a formatted date, with or without time. chart Displays data sets in a chart or a group of charts. file_download A control that allows to download a file. file_selector A control that allows to upload files. image A control that can display an image. indicator Displays a label on a red to green scale at a specific position. menu A menu control. navbar A navigation bar control. selector A control that allows for selecting items from a list of choices. status Displays a status or a list of statuses. table Displays a data set as tabular data. dialog A modal dialog. tree A control that allows multiple selection and filtering on label.","title":"Controls"},{"location":"manuals/gui/user_controls/#controls","text":"Controls are user interface objects that represent data.","title":"Controls"},{"location":"manuals/gui/user_controls/#controls-list","text":"Here is the list of all available controls in Taipy: text Displays a value as a static text. button A control that can trigger a function when pressed. input A control that displays some text that can potentially be edited. number A kind of [`input`](input.md) that handles numbers. slider Displays and allows the user to set a value within a range. toggle A series of toggle buttons that the user can select. date_selector A control that can display and specified a formatted date, with or without time. chart Displays data sets in a chart or a group of charts. file_download A control that allows to download a file. file_selector A control that allows to upload files. image A control that can display an image. indicator Displays a label on a red to green scale at a specific position. menu A menu control. navbar A navigation bar control. selector A control that allows for selecting items from a list of choices. status Displays a status or a list of statuses. table Displays a data set as tabular data. dialog A modal dialog. tree A control that allows multiple selection and filtering on label.","title":"Controls list"},{"location":"manuals/gui/user_dialogs/","text":"Dialogs \u00b6 TODO: Dialogs documentation Preparation \u00b6 Showing and hiding \u00b6 Return value \u00b6","title":"Dialogs"},{"location":"manuals/gui/user_dialogs/#dialogs","text":"TODO: Dialogs documentation","title":"Dialogs"},{"location":"manuals/gui/user_dialogs/#preparation","text":"","title":"Preparation"},{"location":"manuals/gui/user_dialogs/#showing-and-hiding","text":"","title":"Showing and hiding"},{"location":"manuals/gui/user_dialogs/#return-value","text":"","title":"Return value"},{"location":"manuals/gui/user_gui/","text":"GUI References \u00b6 Here are the various configuration elements that you can set: Host \u00b6 host ( _str_ , defaults to _ \"127.0.0.1\" _ ) Port \u00b6 port The port number that the Web server uses. ( _int_ , defaults to _5000_ ) Title \u00b6 title The string displayed in the browser page title bar when navigating your Taipy application. ( _str_ , defaults to _ \"Taipy App\" _ ) Favicon \u00b6 favicon The path to an image file what will be used as the page's icon when navigating your Taipy application. ( _str_ , defaults to the Avaiga logo ) Dark mode \u00b6 dark_mode You can configure the initial theme mode of your application by simply setting this parameter to the value you prefer. ( _bool_ , defaults to _True_ ) Debug \u00b6 debug Set this to True if you want to display the debug messages of the underlying Web server. ( _bool_ , defaults to _True_ ) Time Zone \u00b6 time_zone This parameter indicates how date and time values should be interpreted. You can use a TZ database name (as listed in Time zones list on Wikipedia ) or one of the following values: - \"client\" indicates that the time zone to be used is the one of the Web client. - \"server\" indicates that the time zone to be used is the one of the Web server. ( _str_ , defaults to _ \"client\" _ ) Client URL \u00b6 client_url ( _str_ , defaults to _ \"https:127.0.0.1:5000\" _ ): TODO Theme \u00b6 theme ( _str_ or _None_ , defaults to _None_ ): Use arrow \u00b6 use_arrow Can be set to True in order to use the Apache Arrow technology to serialize data to Taipy clients. This allows for better performance in many situations. ( _bool_ , defaults to _False_ ) Browser notification \u00b6 browser_notification ( _bool_ , defaults to _True_ ) Notification duration \u00b6 notification_duration The time, in milliseconds, that notifications should remain visible (see Notifications for details). ( _int_ , defaults to _3000_ ) Single client \u00b6 single_client Set to True if only one client can connect and to False if multiple clients can connect to this Gui instance. ( _bool_ , defaults to _False_ )","title":"GUI References"},{"location":"manuals/gui/user_gui/#gui-references","text":"Here are the various configuration elements that you can set:","title":"GUI References"},{"location":"manuals/gui/user_gui/#host","text":"host ( _str_ , defaults to _ \"127.0.0.1\" _ )","title":"Host"},{"location":"manuals/gui/user_gui/#port","text":"port The port number that the Web server uses. ( _int_ , defaults to _5000_ )","title":"Port"},{"location":"manuals/gui/user_gui/#title","text":"title The string displayed in the browser page title bar when navigating your Taipy application. ( _str_ , defaults to _ \"Taipy App\" _ )","title":"Title"},{"location":"manuals/gui/user_gui/#favicon","text":"favicon The path to an image file what will be used as the page's icon when navigating your Taipy application. ( _str_ , defaults to the Avaiga logo )","title":"Favicon"},{"location":"manuals/gui/user_gui/#dark-mode","text":"dark_mode You can configure the initial theme mode of your application by simply setting this parameter to the value you prefer. ( _bool_ , defaults to _True_ )","title":"Dark mode"},{"location":"manuals/gui/user_gui/#debug","text":"debug Set this to True if you want to display the debug messages of the underlying Web server. ( _bool_ , defaults to _True_ )","title":"Debug"},{"location":"manuals/gui/user_gui/#time-zone","text":"time_zone This parameter indicates how date and time values should be interpreted. You can use a TZ database name (as listed in Time zones list on Wikipedia ) or one of the following values: - \"client\" indicates that the time zone to be used is the one of the Web client. - \"server\" indicates that the time zone to be used is the one of the Web server. ( _str_ , defaults to _ \"client\" _ )","title":"Time Zone"},{"location":"manuals/gui/user_gui/#client-url","text":"client_url ( _str_ , defaults to _ \"https:127.0.0.1:5000\" _ ): TODO","title":"Client URL"},{"location":"manuals/gui/user_gui/#theme","text":"theme ( _str_ or _None_ , defaults to _None_ ):","title":"Theme"},{"location":"manuals/gui/user_gui/#use-arrow","text":"use_arrow Can be set to True in order to use the Apache Arrow technology to serialize data to Taipy clients. This allows for better performance in many situations. ( _bool_ , defaults to _False_ )","title":"Use arrow"},{"location":"manuals/gui/user_gui/#browser-notification","text":"browser_notification ( _bool_ , defaults to _True_ )","title":"Browser notification"},{"location":"manuals/gui/user_gui/#notification-duration","text":"notification_duration The time, in milliseconds, that notifications should remain visible (see Notifications for details). ( _int_ , defaults to _3000_ )","title":"Notification duration"},{"location":"manuals/gui/user_gui/#single-client","text":"single_client Set to True if only one client can connect and to False if multiple clients can connect to this Gui instance. ( _bool_ , defaults to _False_ )","title":"Single client"},{"location":"manuals/gui/user_notifications/","text":"Notifications \u00b6 TODO: Notifications documentation","title":"Notifications"},{"location":"manuals/gui/user_notifications/#notifications","text":"TODO: Notifications documentation","title":"Notifications"},{"location":"manuals/gui/user_pages/","text":"Pages \u00b6 Pages are the base for your user interface. Pages hold text, images and controls that display information that the application needs to publish, and ways to interact with the application data. Page renderers \u00b6 Taipy lets you create as many pages as you want, with whatever content you need. Pages are created using page renderers , that convert some text (inside the application code or from an external file) into HTML content that is sent and rendered onto the client device. Note A page rendered is an instance of a Python class that reads some text (directly from a string, or reading a text file) and converts it into a page that can be displayed in a browser. There are different types of page renderers in Taipy and all process their input text with the following steps: The text is parsed in order to locate the Taipy-specific constructs. Those constructs may be controls or blocks , and will trigger the creation of potentially complex HTML components; Control (and block) properties are read, and all referenced application variables are bound. Potentially, callbacks are located and connected from the rendered page back to the Python code, if you want to watch user events (the notion of callbacks is detailed in the section Callbacks ). Registering the page \u00b6 Once you have created an instance of a page renderer for a specified piece of text, you can register that page to the Gui instance used by your application. Viewing the page \u00b6 When the user browser connects to the Web server, requesting the indicated page, the rendering takes place (involving the retrieval of the application variable values) so you can see your application's state, and interact with it. Markdown processing \u00b6 One of the page description format is the Markdown markup language. Taipy uses Python Markdown to translate Markdown text to elements that are used to create Web pages. It also uses many extensions that make it easier to create nice-looking page that user can enjoy. Specifically, Taipy uses the following Markdown extensions : Admonition , Attribute Lists , Fenced Code Blocks , Meta-Data , Markdown in HTML , Sane Lists and Tables . Please refer to the Python Markdown package documentation to get information on how these are used. Beside these extensions, Taipy adds its own, that can parse a Taipy-specific construct that allows for defining controls (and all the properties they need) and structuring elements. The basic syntax for creating Taipy constructs in Markdown is: <|...|...|> (opening with a less than character immediately followed by a vertical bar character \u2014 sometimes called pipe \u2014 followed a potentially empty series of vertical bar-separated items, and closing by a vertical bar character immediately followed by the greater than character). Taipy will interpret any text between the <| and the |> markers and try to make sense of it. The most common use of this construct is to create controls. Taipy expects the control type name to appear between the two first vertical bar character (like in <|control|...}> . Important If the first fragment text is not the name of a control type, Taipy will consider this fragment to be the default value for the default property of the control, whose type name must then appear as the second element. Every following elements will be interpreted as a property name-property value pair using the syntax: property_name=property_value (note that all space characters are significative). Shortcut for Boolean properties Should the =property_value fragment be missing, the property value is interpreted as the Boolean value True . Furthermore if the property name is preceded by the text \" no\u2423 \", \" not\u2423 \", \" don't\u2423 \" or \" dont\u2423 \" (including the trailing space character) then no property value is expected, and the property value is set to False . Some examples \u00b6 Multiple properties You can have several properties defined in the same control fragment: <|button|label=Do something|active=False|> The default property rule The default property name for the control type button is label . In Taipy, the Markdown text <|button|label=Some text|> Is exactly equivalent to <|Some text|button|> which is slightly shorter. The missing Boolean property value rules <|button|active=True|> is equivalent to <|button|active|> And <|button|active=False|> is equivalent to <|button|not active|> There are a very few exceptions to the <|control_type|...|> syntax, that are described in their respective documentation section. The most obvious exception is the text control, that can be created without even mentioning it's type. HTML specifics \u00b6 TODO: HTML specifics documentation Root page \u00b6 TODO: root page documentation Partials \u00b6 There are page fragments that you may want to repeat on different pages. In that situation you will want to use the Partials concept described below. This will avoid repeating yourself when creating your user interfaces. TODO: partials documentation Dialogs \u00b6 Application sometimes need to prompt the user to indicate a situation or request an input of some sort. This need is covered in Taipy using the dialog control that is demonstrated below. TODO: dialogs documentation Panes \u00b6 Modern user interface also provide small pages that pop out and be removed, for temporary use such as providing specific parameters for the application. Taipy lets you create such elements as described below. TODO: panes documentation Local resources \u00b6 TODO: local resources documentation","title":"Pages"},{"location":"manuals/gui/user_pages/#pages","text":"Pages are the base for your user interface. Pages hold text, images and controls that display information that the application needs to publish, and ways to interact with the application data.","title":"Pages"},{"location":"manuals/gui/user_pages/#page-renderers","text":"Taipy lets you create as many pages as you want, with whatever content you need. Pages are created using page renderers , that convert some text (inside the application code or from an external file) into HTML content that is sent and rendered onto the client device. Note A page rendered is an instance of a Python class that reads some text (directly from a string, or reading a text file) and converts it into a page that can be displayed in a browser. There are different types of page renderers in Taipy and all process their input text with the following steps: The text is parsed in order to locate the Taipy-specific constructs. Those constructs may be controls or blocks , and will trigger the creation of potentially complex HTML components; Control (and block) properties are read, and all referenced application variables are bound. Potentially, callbacks are located and connected from the rendered page back to the Python code, if you want to watch user events (the notion of callbacks is detailed in the section Callbacks ).","title":"Page renderers"},{"location":"manuals/gui/user_pages/#registering-the-page","text":"Once you have created an instance of a page renderer for a specified piece of text, you can register that page to the Gui instance used by your application.","title":"Registering the page"},{"location":"manuals/gui/user_pages/#viewing-the-page","text":"When the user browser connects to the Web server, requesting the indicated page, the rendering takes place (involving the retrieval of the application variable values) so you can see your application's state, and interact with it.","title":"Viewing the page"},{"location":"manuals/gui/user_pages/#markdown-processing","text":"One of the page description format is the Markdown markup language. Taipy uses Python Markdown to translate Markdown text to elements that are used to create Web pages. It also uses many extensions that make it easier to create nice-looking page that user can enjoy. Specifically, Taipy uses the following Markdown extensions : Admonition , Attribute Lists , Fenced Code Blocks , Meta-Data , Markdown in HTML , Sane Lists and Tables . Please refer to the Python Markdown package documentation to get information on how these are used. Beside these extensions, Taipy adds its own, that can parse a Taipy-specific construct that allows for defining controls (and all the properties they need) and structuring elements. The basic syntax for creating Taipy constructs in Markdown is: <|...|...|> (opening with a less than character immediately followed by a vertical bar character \u2014 sometimes called pipe \u2014 followed a potentially empty series of vertical bar-separated items, and closing by a vertical bar character immediately followed by the greater than character). Taipy will interpret any text between the <| and the |> markers and try to make sense of it. The most common use of this construct is to create controls. Taipy expects the control type name to appear between the two first vertical bar character (like in <|control|...}> . Important If the first fragment text is not the name of a control type, Taipy will consider this fragment to be the default value for the default property of the control, whose type name must then appear as the second element. Every following elements will be interpreted as a property name-property value pair using the syntax: property_name=property_value (note that all space characters are significative). Shortcut for Boolean properties Should the =property_value fragment be missing, the property value is interpreted as the Boolean value True . Furthermore if the property name is preceded by the text \" no\u2423 \", \" not\u2423 \", \" don't\u2423 \" or \" dont\u2423 \" (including the trailing space character) then no property value is expected, and the property value is set to False .","title":"Markdown processing"},{"location":"manuals/gui/user_pages/#some-examples","text":"Multiple properties You can have several properties defined in the same control fragment: <|button|label=Do something|active=False|> The default property rule The default property name for the control type button is label . In Taipy, the Markdown text <|button|label=Some text|> Is exactly equivalent to <|Some text|button|> which is slightly shorter. The missing Boolean property value rules <|button|active=True|> is equivalent to <|button|active|> And <|button|active=False|> is equivalent to <|button|not active|> There are a very few exceptions to the <|control_type|...|> syntax, that are described in their respective documentation section. The most obvious exception is the text control, that can be created without even mentioning it's type.","title":"Some examples"},{"location":"manuals/gui/user_pages/#html-specifics","text":"TODO: HTML specifics documentation","title":"HTML specifics"},{"location":"manuals/gui/user_pages/#root-page","text":"TODO: root page documentation","title":"Root page"},{"location":"manuals/gui/user_pages/#partials","text":"There are page fragments that you may want to repeat on different pages. In that situation you will want to use the Partials concept described below. This will avoid repeating yourself when creating your user interfaces. TODO: partials documentation","title":"Partials"},{"location":"manuals/gui/user_pages/#dialogs","text":"Application sometimes need to prompt the user to indicate a situation or request an input of some sort. This need is covered in Taipy using the dialog control that is demonstrated below. TODO: dialogs documentation","title":"Dialogs"},{"location":"manuals/gui/user_pages/#panes","text":"Modern user interface also provide small pages that pop out and be removed, for temporary use such as providing specific parameters for the application. Taipy lets you create such elements as described below. TODO: panes documentation","title":"Panes"},{"location":"manuals/gui/user_pages/#local-resources","text":"TODO: local resources documentation","title":"Local resources"},{"location":"manuals/gui/user_styling/","text":"Styling \u00b6 TODO: Styling documentation General concepts \u00b6 Specific styles \u00b6","title":"Styling"},{"location":"manuals/gui/user_styling/#styling","text":"TODO: Styling documentation","title":"Styling"},{"location":"manuals/gui/user_styling/#general-concepts","text":"","title":"General concepts"},{"location":"manuals/gui/user_styling/#specific-styles","text":"","title":"Specific styles"},{"location":"manuals/gui/user_viselements/","text":"Introduction to Visual Elements \u00b6 Visual Elements are user interface objects that are displayed on a given page. Visual elements reflect some application data or give the page some structuring or layout information. Most visual elements let users interact with the page content. You create visual elements using a specific the Markdown syntax (see the Markdown class) or specific HTML tags (see the Html class). Properties \u00b6 Every visual element that you can use in a page has a type and a set of properties. Beside those common properties, every control type has a specific set of properties that you can use, listed in the documentation page for that control type. Property value \u00b6 Every property value can be set to a given value, that depends on the property type, or a formatted string literal, also known as a f-string . This string may reference variable names defined in your code, and the evaluated string is used as the property value. The property value is also updated when your Python variable is modified. Property name \u00b6 Every control type has a default property name If you want to set the value for this property, you can use the short version of the control syntax. Syntax \u00b6 Visual Elements are declared in your page content using the Markdown or the HTML syntax. Markdown \u00b6 Creating a visual element in Markdown text is just a matter of inserting a text fragment. <| control_type | property_name = property_value |...|> Note You can have as many property name-property value pairs as needed, and all the space characters of the property value part are significant. Default property All visual elements have a default property that can be used before the visual element type name type in order to shorten the definition of the element content: <|visual_element_type|default_property_name=default_property_value|> Is equivalent to <|default_property_value|visual_element_type|> Please refer to the section about Markdown syntax for all the details on the Taipy Markdown extension syntax. HTML \u00b6 If you choose to embed Taipy visual elements into existing HTML pages, you can use the following syntax: < taipy:visual_element_type property_name = \"property_value\" ... > </ visual_element_type > The text element of the visual element tag can be used to indicate the default property value for this visual element: < taipy:visual_element_type default_property_name = \"default_property_value\" ... /> is equivalent to < taipy:visual_element_type > default_property_value </ taipy:visual_element_type > HTML syntax extensions The HTML text that is given to the HTML page renderer is not parsed as pure HTML. Instead, it is transformed before it is sent as HTML to be rendered. Therefore, Taipy was able to introduce a few changes to the pure HTML syntax that make it easier to use in the context of describing Taipy pages. Attribute names that be array elements. Some visual elements (such as the chart control) need indexed properties. An attribute name such as y[1] is valid in the Taipy context, where it would not be in raw HTML. Empty attribute value. In the HTML used by Taipy, you can mention an attribute with no value. It would be equivalent to setting it to True . Generic properties \u00b6 Every visual element type has the following properties: id : The identifier of the element, generated in the HTML component. class_name : An additional CSS class that is added to the generated HTML component. Note that all visual element are generated with the \"taipy- visual_element_type \" CSS class set (ie. the button control generates an HTML element that has the taipy-button CSS class). properties : The name of a variable that holds a dictionary where all property name/value pairs will be used by a given visual element declaration. All or most of the Taipy visual elements expose similar properties that can be used in a generic manner across your pages. The id property \u00b6 You can specify an identifier for a specific visual element. This identifier is used as the id attribute of the generated HTML component so you can use it in your CSS selectors. This identifier is also sent to the on_action function of the Gui instance, if this visual element can trigger actions. The properties property \u00b6 There are situations where your visual element may need a lot of different properties. This is typically the case for complex visual elements like the chart or the table controls. Instead of having to list all the properties with their appropriate value, potentially making the reading of the content difficult, you can create a Python dictionary, that contains all the required key-value pair, and use the name of the variable that holds that dictionary as the value of the properties property. Example Say your Markdown content needs the following control: <|dialog|title=Dialog Title|open={show_dialog}|page_id=page|validate_action=validate_action|cancel_action=cancel_action||validate_action_text=Validate|cancel_action_text=Cancel|> You can argue that this is pretty long, and could be improved. In this situation, you might prefer to declare a simple Python dictionary in your code: 1 2 3 4 5 6 7 8 dialog_props = { \"title\" : \"Dialog Title\" , \"page_id\" : \"page\" , \"validate_label\" : \"Validate\" , \"validate_action\" : \"validate_action\" , \"cancel_label\" : \"Cancel\" , \"cancel_action\" : \"cancel_action\" } Then shorten your Markdown text with the following syntax: <{show_dialog}|dialog|properties=dialog_props|> The propagate property \u00b6 If the propagate property is set to True , then the application variable bound to a visual element is updated when the user modifies the value represented by the element. Info Note that if there is a function called on_change declared on the Gui instance, it will be invoked no matter what the propagate value is.\"","title":"Introduction"},{"location":"manuals/gui/user_viselements/#introduction-to-visual-elements","text":"Visual Elements are user interface objects that are displayed on a given page. Visual elements reflect some application data or give the page some structuring or layout information. Most visual elements let users interact with the page content. You create visual elements using a specific the Markdown syntax (see the Markdown class) or specific HTML tags (see the Html class).","title":"Introduction to Visual Elements"},{"location":"manuals/gui/user_viselements/#properties","text":"Every visual element that you can use in a page has a type and a set of properties. Beside those common properties, every control type has a specific set of properties that you can use, listed in the documentation page for that control type.","title":"Properties"},{"location":"manuals/gui/user_viselements/#property-value","text":"Every property value can be set to a given value, that depends on the property type, or a formatted string literal, also known as a f-string . This string may reference variable names defined in your code, and the evaluated string is used as the property value. The property value is also updated when your Python variable is modified.","title":"Property value"},{"location":"manuals/gui/user_viselements/#property-name","text":"Every control type has a default property name If you want to set the value for this property, you can use the short version of the control syntax.","title":"Property name"},{"location":"manuals/gui/user_viselements/#syntax","text":"Visual Elements are declared in your page content using the Markdown or the HTML syntax.","title":"Syntax"},{"location":"manuals/gui/user_viselements/#markdown","text":"Creating a visual element in Markdown text is just a matter of inserting a text fragment. <| control_type | property_name = property_value |...|> Note You can have as many property name-property value pairs as needed, and all the space characters of the property value part are significant. Default property All visual elements have a default property that can be used before the visual element type name type in order to shorten the definition of the element content: <|visual_element_type|default_property_name=default_property_value|> Is equivalent to <|default_property_value|visual_element_type|> Please refer to the section about Markdown syntax for all the details on the Taipy Markdown extension syntax.","title":"Markdown"},{"location":"manuals/gui/user_viselements/#html","text":"If you choose to embed Taipy visual elements into existing HTML pages, you can use the following syntax: < taipy:visual_element_type property_name = \"property_value\" ... > </ visual_element_type > The text element of the visual element tag can be used to indicate the default property value for this visual element: < taipy:visual_element_type default_property_name = \"default_property_value\" ... /> is equivalent to < taipy:visual_element_type > default_property_value </ taipy:visual_element_type > HTML syntax extensions The HTML text that is given to the HTML page renderer is not parsed as pure HTML. Instead, it is transformed before it is sent as HTML to be rendered. Therefore, Taipy was able to introduce a few changes to the pure HTML syntax that make it easier to use in the context of describing Taipy pages. Attribute names that be array elements. Some visual elements (such as the chart control) need indexed properties. An attribute name such as y[1] is valid in the Taipy context, where it would not be in raw HTML. Empty attribute value. In the HTML used by Taipy, you can mention an attribute with no value. It would be equivalent to setting it to True .","title":"HTML"},{"location":"manuals/gui/user_viselements/#generic-properties","text":"Every visual element type has the following properties: id : The identifier of the element, generated in the HTML component. class_name : An additional CSS class that is added to the generated HTML component. Note that all visual element are generated with the \"taipy- visual_element_type \" CSS class set (ie. the button control generates an HTML element that has the taipy-button CSS class). properties : The name of a variable that holds a dictionary where all property name/value pairs will be used by a given visual element declaration. All or most of the Taipy visual elements expose similar properties that can be used in a generic manner across your pages.","title":"Generic properties"},{"location":"manuals/gui/user_viselements/#the-id-property","text":"You can specify an identifier for a specific visual element. This identifier is used as the id attribute of the generated HTML component so you can use it in your CSS selectors. This identifier is also sent to the on_action function of the Gui instance, if this visual element can trigger actions.","title":"The id property"},{"location":"manuals/gui/user_viselements/#the-properties-property","text":"There are situations where your visual element may need a lot of different properties. This is typically the case for complex visual elements like the chart or the table controls. Instead of having to list all the properties with their appropriate value, potentially making the reading of the content difficult, you can create a Python dictionary, that contains all the required key-value pair, and use the name of the variable that holds that dictionary as the value of the properties property. Example Say your Markdown content needs the following control: <|dialog|title=Dialog Title|open={show_dialog}|page_id=page|validate_action=validate_action|cancel_action=cancel_action||validate_action_text=Validate|cancel_action_text=Cancel|> You can argue that this is pretty long, and could be improved. In this situation, you might prefer to declare a simple Python dictionary in your code: 1 2 3 4 5 6 7 8 dialog_props = { \"title\" : \"Dialog Title\" , \"page_id\" : \"page\" , \"validate_label\" : \"Validate\" , \"validate_action\" : \"validate_action\" , \"cancel_label\" : \"Cancel\" , \"cancel_action\" : \"cancel_action\" } Then shorten your Markdown text with the following syntax: <{show_dialog}|dialog|properties=dialog_props|>","title":"The properties property"},{"location":"manuals/gui/user_viselements/#the-propagate-property","text":"If the propagate property is set to True , then the application variable bound to a visual element is updated when the user modifies the value represented by the element. Info Note that if there is a function called on_change declared on the Gui instance, it will be invoked no matter what the propagate value is.\"","title":"The propagate property"},{"location":"manuals/gui/viselements/button/","text":"button \u00b6 A control that can trigger a function when pressed. Properties \u00b6 Name Type Default Description label (\u2605) dynamic(str) \"\" The label displayed in the button. on_action str Mandatory The name of a function that is triggered when the button is pressed. The parameters of that function are all optional: gui instance id action id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) label is the default property for this visual element. Usage \u00b6 Simple text \u00b6 The button label, which is the button control's default property, is simply displayed as the button text. Page content Markdown <|Button Label|button|> HTML < taipy:button > Button Label </ taipy:button > Specific action callback \u00b6 Button can be specified a specific callback function to be invoked when the button is pressed. Page content Markdown <|Button Label|button|on_action=button_action_function_name|> HTML < taipy:button on_action = \"button_action_function_name\" > Button Label </ taipy:button >","title":"`button`"},{"location":"manuals/gui/viselements/button/#button","text":"A control that can trigger a function when pressed.","title":"button"},{"location":"manuals/gui/viselements/button/#properties","text":"Name Type Default Description label (\u2605) dynamic(str) \"\" The label displayed in the button. on_action str Mandatory The name of a function that is triggered when the button is pressed. The parameters of that function are all optional: gui instance id action id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) label is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/button/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/button/#simple-text","text":"The button label, which is the button control's default property, is simply displayed as the button text. Page content Markdown <|Button Label|button|> HTML < taipy:button > Button Label </ taipy:button >","title":"Simple text"},{"location":"manuals/gui/viselements/button/#specific-action-callback","text":"Button can be specified a specific callback function to be invoked when the button is pressed. Page content Markdown <|Button Label|button|on_action=button_action_function_name|> HTML < taipy:button on_action = \"button_action_function_name\" > Button Label </ taipy:button >","title":"Specific action callback"},{"location":"manuals/gui/viselements/chart/","text":"chart \u00b6 Displays data sets in a chart or a group of charts. The chart control is based on the plotly.js graphs library. A chart control can hold several traces, that can display individual data sets. To indicate properties for a given trace, you will use the indexed properties (using the property_name[index] syntax, with the indices starting at index 1) to specify which trace you target. Indexed properties can have a default value (using the property_name syntax with no index) which is overridden by any specified indexed property. Properties \u00b6 Name Type Default Description value (\u2605) any Mandatory The data object bound to this chart control. title str None The title of this chart control. width str|int|float 100vw The width, in CSS units, of this element. height str|int|float 100vw The height, in CSS units, of this element. selected dynamic(list[int]|str) None List of the selected point indices. layout dict[str, any] None The plotly.js compatible layout object . range_change FunctionType? None Callback function called when the visible part of the x axis changes. The function receives three parameters: `id` (optional[str]): the identifier of the chart control. `action` (optional[str]): the name of the action that provoked the change. `payload` (dict[str, any]): all the event information, as emmitted by plotly columns str|List[str]|dict[str, dict[str, str]] _All columns_ List of column names *str*: ;-separated list of column names *List[str]*: list of names *dict*: {\"col_name\": {format: \"format\", index: 1}} if index is specified, it represents the display order of the columns. If not, the list order defines the index label indexed(str) None The label for the indicated trace. This is used when the mouse hovers over a trace. name indexed(str) None The name of the indicated trace. orientation indexed(str) None? The orientation of the indicated trace. x indexed(str) None Column name for the x axis. y indexed(str) None Column name for the y axis. z indexed(str) None Column name for the z axis. text indexed(str) None Column name for the text associated to the point for the indicated trace. This is meaningful only when mode has the text option. text_anchor indexed(str) None Position of the text relative to the point. Valid values are: top , bottom , left and right . mode indexed(str) lines+markers Chart mode. See the Plotly chart mode documentation for details. type indexed(str) ? Chart type. See the Plotly chart type documentation for details. color indexed(str) None? The color of the indicated trace. xaxis indexed(str) None? The x axis identifier for the indicated trace. yaxis indexed(str) None? The y axis identifier for the indicated trace. selected_color indexed(str) None? The color of the selected points for the indicated trace. marker indexed(dict[str, any] None? The type of markers used for the indicated trace. See marker for details. line indexed(str|dict[str, any] None? The configuration of the line used for the indicated trace. See line for details. if str then dash?? selected_marker indexed(dict[str, any] None? The type of markers used for selected points in the indicated trace. See selected marker for details. id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) value is the default property for this visual element. Usage \u00b6 Simple example \u00b6 If you want to create a chart that represents a dataframe stored in the Python variable data , where column \"Col1\" you can use the following content: Page content Markdown <|{data}|chart|x=xValues|y=yValues|> HTML < taipy:chart x = \"xValues\" y = \"yValues\" > {data} </ taipy:chart > Multiple charts \u00b6 You may want to plot different data sets in the same chart. In the following example, data holds a data frame where two sets of values are stored in columns y1 and y2 that you want to represent in a chart where the abscissa values can be found in column x . Labels for the charts can be found in columns l1 and l2 . Furthermore, we want the second dataset to be displayed in red. Page content Markdown <|{data}|chart|x=x|y[1]=y1|label[1]=l1|y[2]=y2|label[2]=l2|color[2]=red|xaxis[2]=x2|> Note how we refer to the different y value sources, using indices. HTML < taipy:chart x = \"x\" y [ 1 ]=\" y1 \" label [ 1 ]=\" l1 \" y [ 2 ]=\" y2 \" label [ 2 ]=\" l2 \" mode [ 2 ]=\" markers \" color [ 2 ]=\" red \" type [ 2 ]=\" scatter \" xaxis [ 2 ]=\" x2 \" > {data} </ taipy:chart > Tracking selection \u00b6 If points selection is enabled in the chart, you can keep track of which point indices are selected in a variable. Page content Markdown <|{data}|chart|selected={selected_indices}|...|> HTML < taipy:chart selected = \"selected_indices\" ... > {data} </ taipy:chart >","title":"`chart`"},{"location":"manuals/gui/viselements/chart/#chart","text":"Displays data sets in a chart or a group of charts. The chart control is based on the plotly.js graphs library. A chart control can hold several traces, that can display individual data sets. To indicate properties for a given trace, you will use the indexed properties (using the property_name[index] syntax, with the indices starting at index 1) to specify which trace you target. Indexed properties can have a default value (using the property_name syntax with no index) which is overridden by any specified indexed property.","title":"chart"},{"location":"manuals/gui/viselements/chart/#properties","text":"Name Type Default Description value (\u2605) any Mandatory The data object bound to this chart control. title str None The title of this chart control. width str|int|float 100vw The width, in CSS units, of this element. height str|int|float 100vw The height, in CSS units, of this element. selected dynamic(list[int]|str) None List of the selected point indices. layout dict[str, any] None The plotly.js compatible layout object . range_change FunctionType? None Callback function called when the visible part of the x axis changes. The function receives three parameters: `id` (optional[str]): the identifier of the chart control. `action` (optional[str]): the name of the action that provoked the change. `payload` (dict[str, any]): all the event information, as emmitted by plotly columns str|List[str]|dict[str, dict[str, str]] _All columns_ List of column names *str*: ;-separated list of column names *List[str]*: list of names *dict*: {\"col_name\": {format: \"format\", index: 1}} if index is specified, it represents the display order of the columns. If not, the list order defines the index label indexed(str) None The label for the indicated trace. This is used when the mouse hovers over a trace. name indexed(str) None The name of the indicated trace. orientation indexed(str) None? The orientation of the indicated trace. x indexed(str) None Column name for the x axis. y indexed(str) None Column name for the y axis. z indexed(str) None Column name for the z axis. text indexed(str) None Column name for the text associated to the point for the indicated trace. This is meaningful only when mode has the text option. text_anchor indexed(str) None Position of the text relative to the point. Valid values are: top , bottom , left and right . mode indexed(str) lines+markers Chart mode. See the Plotly chart mode documentation for details. type indexed(str) ? Chart type. See the Plotly chart type documentation for details. color indexed(str) None? The color of the indicated trace. xaxis indexed(str) None? The x axis identifier for the indicated trace. yaxis indexed(str) None? The y axis identifier for the indicated trace. selected_color indexed(str) None? The color of the selected points for the indicated trace. marker indexed(dict[str, any] None? The type of markers used for the indicated trace. See marker for details. line indexed(str|dict[str, any] None? The configuration of the line used for the indicated trace. See line for details. if str then dash?? selected_marker indexed(dict[str, any] None? The type of markers used for selected points in the indicated trace. See selected marker for details. id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) value is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/chart/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/chart/#simple-example","text":"If you want to create a chart that represents a dataframe stored in the Python variable data , where column \"Col1\" you can use the following content: Page content Markdown <|{data}|chart|x=xValues|y=yValues|> HTML < taipy:chart x = \"xValues\" y = \"yValues\" > {data} </ taipy:chart >","title":"Simple example"},{"location":"manuals/gui/viselements/chart/#multiple-charts","text":"You may want to plot different data sets in the same chart. In the following example, data holds a data frame where two sets of values are stored in columns y1 and y2 that you want to represent in a chart where the abscissa values can be found in column x . Labels for the charts can be found in columns l1 and l2 . Furthermore, we want the second dataset to be displayed in red. Page content Markdown <|{data}|chart|x=x|y[1]=y1|label[1]=l1|y[2]=y2|label[2]=l2|color[2]=red|xaxis[2]=x2|> Note how we refer to the different y value sources, using indices. HTML < taipy:chart x = \"x\" y [ 1 ]=\" y1 \" label [ 1 ]=\" l1 \" y [ 2 ]=\" y2 \" label [ 2 ]=\" l2 \" mode [ 2 ]=\" markers \" color [ 2 ]=\" red \" type [ 2 ]=\" scatter \" xaxis [ 2 ]=\" x2 \" > {data} </ taipy:chart >","title":"Multiple charts"},{"location":"manuals/gui/viselements/chart/#tracking-selection","text":"If points selection is enabled in the chart, you can keep track of which point indices are selected in a variable. Page content Markdown <|{data}|chart|selected={selected_indices}|...|> HTML < taipy:chart selected = \"selected_indices\" ... > {data} </ taipy:chart >","title":"Tracking selection"},{"location":"manuals/gui/viselements/date_selector/","text":"date_selector \u00b6 A control that can display and specified a formatted date, with or without time. Properties \u00b6 Name Type Default Description date (\u2605) dynamic(datetime) None The date that this control represents and can modify. It is typically bound to a datetime object. with_time bool False Whether or not to show the time part of the date. (\u2605) date is the default property for this visual element. Usage \u00b6 Using the full date and time \u00b6 Assuming a variable dt contains a Python datetime object, you can create a date selector that represents it: Page content Markdown <|{dt}|date_selector|> HTML < taipy:date_selector > {dt} </ taipy:date_selector > Using only the date \u00b6 If you don't need to use the date, you can do so: Page content Markdown <|{dt}|date_selector|not with_time|> HTML < taipy:date_selector with_time = \"false\" > {dt} </ taipy:date_selector >","title":"`date_selector`"},{"location":"manuals/gui/viselements/date_selector/#date_selector","text":"A control that can display and specified a formatted date, with or without time.","title":"date_selector"},{"location":"manuals/gui/viselements/date_selector/#properties","text":"Name Type Default Description date (\u2605) dynamic(datetime) None The date that this control represents and can modify. It is typically bound to a datetime object. with_time bool False Whether or not to show the time part of the date. (\u2605) date is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/date_selector/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/date_selector/#using-the-full-date-and-time","text":"Assuming a variable dt contains a Python datetime object, you can create a date selector that represents it: Page content Markdown <|{dt}|date_selector|> HTML < taipy:date_selector > {dt} </ taipy:date_selector >","title":"Using the full date and time"},{"location":"manuals/gui/viselements/date_selector/#using-only-the-date","text":"If you don't need to use the date, you can do so: Page content Markdown <|{dt}|date_selector|not with_time|> HTML < taipy:date_selector with_time = \"false\" > {dt} </ taipy:date_selector >","title":"Using only the date"},{"location":"manuals/gui/viselements/dialog/","text":"dialog \u00b6 A modal dialog. TODO: Complete Properties \u00b6 Name Type Default Description open (\u2605) bool False If True , the dialog is visible. If False , it is hidden. cancel_action str None Name of a function that is triggered hen the cancel button Is pressed. The parameters of that function are all optional: gui instance id action If cancel_action is empty, the button is not shown. cancel_label str \"cancel\" The text of the cancel button. validate_action str \"validate\" Name of a function that is triggered when the validate button is pressed. The parameters of that function are all optional: gui instance id action If cancel_action is empty, the button is not shown. validate_label str \"Validate\" The text of the validate button. partial Partial None A Partial object that holds the content of the dialog. This should be defined if page_id is set. page_id str None The page identifier to show as the content of the dialog. This should not be defined if partial is set. width str|int|float None The width, in CSS units, of this dialog. (CSS property) height str|int|float None The height, in CSS units, of this dialog. (CSS property) id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) open is the default property for this visual element. Usage \u00b6 Showing or hiding a dialog \u00b6 The default property, open , indicates whether the dialog is visible or not: Page content Markdown <|{show_dialog}|dialog|> HTML < taipy:dialog > {show_dialog} </ taipy:dialog > Specifying labels and actions \u00b6 Several properties let you specify which label should be used for which button, and what actions (callback functions) are triggered when buttons are pressed: Page content Markdown <|dialog|title=Dialog Title|open={show_dialog}|page_id=page1|validate_action=validate_action|cancel_action=cancel_action||validate_action_text=Validate|cancel_action_text=Cancel|> HTML < taipy:dialog title = \"Dialog Title\" page_id = \"page1\" validate_label = \"Validate\" validate_action = \"validate_action\" cancel_label = \"Cancel\" cancel_action = \"cancel_action\" > {show_dialog} </ taipy:dialog > <|dialog|title=Dialog Title|open={value}|page_id=page1|validate_action=validate_action|cancel_action=cancel_action||validate_action_text=Validate|cancel_action_text=Cancel|>","title":"`dialog`"},{"location":"manuals/gui/viselements/dialog/#dialog","text":"A modal dialog. TODO: Complete","title":"dialog"},{"location":"manuals/gui/viselements/dialog/#properties","text":"Name Type Default Description open (\u2605) bool False If True , the dialog is visible. If False , it is hidden. cancel_action str None Name of a function that is triggered hen the cancel button Is pressed. The parameters of that function are all optional: gui instance id action If cancel_action is empty, the button is not shown. cancel_label str \"cancel\" The text of the cancel button. validate_action str \"validate\" Name of a function that is triggered when the validate button is pressed. The parameters of that function are all optional: gui instance id action If cancel_action is empty, the button is not shown. validate_label str \"Validate\" The text of the validate button. partial Partial None A Partial object that holds the content of the dialog. This should be defined if page_id is set. page_id str None The page identifier to show as the content of the dialog. This should not be defined if partial is set. width str|int|float None The width, in CSS units, of this dialog. (CSS property) height str|int|float None The height, in CSS units, of this dialog. (CSS property) id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) open is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/dialog/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/dialog/#showing-or-hiding-a-dialog","text":"The default property, open , indicates whether the dialog is visible or not: Page content Markdown <|{show_dialog}|dialog|> HTML < taipy:dialog > {show_dialog} </ taipy:dialog >","title":"Showing or hiding a dialog"},{"location":"manuals/gui/viselements/dialog/#specifying-labels-and-actions","text":"Several properties let you specify which label should be used for which button, and what actions (callback functions) are triggered when buttons are pressed: Page content Markdown <|dialog|title=Dialog Title|open={show_dialog}|page_id=page1|validate_action=validate_action|cancel_action=cancel_action||validate_action_text=Validate|cancel_action_text=Cancel|> HTML < taipy:dialog title = \"Dialog Title\" page_id = \"page1\" validate_label = \"Validate\" validate_action = \"validate_action\" cancel_label = \"Cancel\" cancel_action = \"cancel_action\" > {show_dialog} </ taipy:dialog > <|dialog|title=Dialog Title|open={value}|page_id=page1|validate_action=validate_action|cancel_action=cancel_action||validate_action_text=Validate|cancel_action_text=Cancel|>","title":"Specifying labels and actions"},{"location":"manuals/gui/viselements/expandable/","text":"expandable \u00b6 Displays its child elements in a collapsable area. Properties \u00b6 Name Type Default Description value (\u2605) str None Title of this block element. expanded bool True If True , the block is expanded, and the content is displayed. If False , the block is collapsed and its content is hidden. id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) value is the default property for this visual element. Usage \u00b6 Simple \u00b6 <|title|expandable| ... |> Advanced \u00b6 <|{value}|expandable|expanded={False}| ... |> or with properties <|expandable|properties={properties}| ... |> or with closing tag <|expandable.start|...|> ... <|expandable.end|>","title":"`expandable`"},{"location":"manuals/gui/viselements/expandable/#expandable","text":"Displays its child elements in a collapsable area.","title":"expandable"},{"location":"manuals/gui/viselements/expandable/#properties","text":"Name Type Default Description value (\u2605) str None Title of this block element. expanded bool True If True , the block is expanded, and the content is displayed. If False , the block is collapsed and its content is hidden. id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) value is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/expandable/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/expandable/#simple","text":"<|title|expandable| ... |>","title":"Simple"},{"location":"manuals/gui/viselements/expandable/#advanced","text":"<|{value}|expandable|expanded={False}| ... |> or with properties <|expandable|properties={properties}| ... |> or with closing tag <|expandable.start|...|> ... <|expandable.end|>","title":"Advanced"},{"location":"manuals/gui/viselements/file_download/","text":"file_download \u00b6 A control that allows to download a file. The download can be triggered when clicking on a button, or can be performed automatically. Properties \u00b6 Name Type Default Description content (\u2605) dynamic(url | path | file) None The content of the file. label dynamic(str) None The label of the button. on_action str Mandatory The name of a function that is triggered when the download is initiated. All the parameters of that function are optional: gui instance id action auto bool False If True , the download starts as soon as the page is loaded. render dynamic(bool) True If True , the control is displayed. If False , the control is not displayed. bypass_preview bool True If False , allows the browser to try to show the content in a different tab. The file download is always performed. name str None A name proposition for the file to save, that the user can change. id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) content is the default property for this visual element. Usage \u00b6","title":"`file_download`"},{"location":"manuals/gui/viselements/file_download/#file_download","text":"A control that allows to download a file. The download can be triggered when clicking on a button, or can be performed automatically.","title":"file_download"},{"location":"manuals/gui/viselements/file_download/#properties","text":"Name Type Default Description content (\u2605) dynamic(url | path | file) None The content of the file. label dynamic(str) None The label of the button. on_action str Mandatory The name of a function that is triggered when the download is initiated. All the parameters of that function are optional: gui instance id action auto bool False If True , the download starts as soon as the page is loaded. render dynamic(bool) True If True , the control is displayed. If False , the control is not displayed. bypass_preview bool True If False , allows the browser to try to show the content in a different tab. The file download is always performed. name str None A name proposition for the file to save, that the user can change. id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) content is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/file_download/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/file_selector/","text":"file_selector \u00b6 A control that allows to upload files. The upload can be triggered by pressing a button, or drag-and-dropping a file on top of the control. Properties \u00b6 Name Type Default Description content (\u2605) dynamic(str) None The path or the list of paths of the uploaded files. label str None The label of the button. on_action str None The name of the function that will be triggered. All the parameters of that function are optional: gui instance id action multiple bool False If set to True , multiple files can be uploaded. extensions str \".csv,.xlsx\"?? The list of file extensions that can be uploaded. drop_message str \"Drop here to Upload\"?? The message that is displayed when the user drags a file above the button. id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) content is the default property for this visual element. Usage \u00b6","title":"`file_selector`"},{"location":"manuals/gui/viselements/file_selector/#file_selector","text":"A control that allows to upload files. The upload can be triggered by pressing a button, or drag-and-dropping a file on top of the control.","title":"file_selector"},{"location":"manuals/gui/viselements/file_selector/#properties","text":"Name Type Default Description content (\u2605) dynamic(str) None The path or the list of paths of the uploaded files. label str None The label of the button. on_action str None The name of the function that will be triggered. All the parameters of that function are optional: gui instance id action multiple bool False If set to True , multiple files can be uploaded. extensions str \".csv,.xlsx\"?? The list of file extensions that can be uploaded. drop_message str \"Drop here to Upload\"?? The message that is displayed when the user drags a file above the button. id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) content is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/file_selector/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/image/","text":"image \u00b6 A control that can display an image. You can indicate a function to be called when the user clicks on the image. Properties \u00b6 Name Type Default Description content (\u2605) dynamic(url | path | file) None The image source. label dynamic(str) None The label for this image. on_action str \"\" The name of a function that is triggered when the user clicks on the image. All the parameters of that function are optional: gui instance id action width str|int|float \"300px\" The width, in CSS units, of this element. height str|int|float None The height, in CSS units, of this element. id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) content is the default property for this visual element. Usage \u00b6 TODO","title":"`image`"},{"location":"manuals/gui/viselements/image/#image","text":"A control that can display an image. You can indicate a function to be called when the user clicks on the image.","title":"image"},{"location":"manuals/gui/viselements/image/#properties","text":"Name Type Default Description content (\u2605) dynamic(url | path | file) None The image source. label dynamic(str) None The label for this image. on_action str \"\" The name of a function that is triggered when the user clicks on the image. All the parameters of that function are optional: gui instance id action width str|int|float \"300px\" The width, in CSS units, of this element. height str|int|float None The height, in CSS units, of this element. id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) content is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/image/#usage","text":"TODO","title":"Usage"},{"location":"manuals/gui/viselements/indicator/","text":"indicator \u00b6 Displays a label on a red to green scale at a specific position. The min value can be greater than the max value. The value will be maintained between min and max. Properties \u00b6 Name Type Default Description display (\u2605) dynamic(any) None The label to be displayed. This can be formatted if it is a numerical value. value dynamic(int,float) _min_ The location of the label on the [ min , max ] range. min int|float 0 The minimum value of the range. max int|float 100 The maximum value of the range. format str? None The format to use when displaying the value. This uses the printf syntax. id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) display is the default property for this visual element. Usage \u00b6","title":"`indicator`"},{"location":"manuals/gui/viselements/indicator/#indicator","text":"Displays a label on a red to green scale at a specific position. The min value can be greater than the max value. The value will be maintained between min and max.","title":"indicator"},{"location":"manuals/gui/viselements/indicator/#properties","text":"Name Type Default Description display (\u2605) dynamic(any) None The label to be displayed. This can be formatted if it is a numerical value. value dynamic(int,float) _min_ The location of the label on the [ min , max ] range. min int|float 0 The minimum value of the range. max int|float 100 The maximum value of the range. format str? None The format to use when displaying the value. This uses the printf syntax. id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) display is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/indicator/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/input/","text":"input \u00b6 A control that displays some text that can potentially be edited. Properties \u00b6 Name Type Default Description value (\u2605) dynamic(any) None The value represented by this control. propagate bool App config Allows the control's main value to be automatically propagated. The default value is defined at the application configuration level. If True , any change to the control's value is immediately reflected in the bound application variable. active dynamic(bool) None Indicates if this component is active. An inactive component allows no user interaction. id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) value is the default property for this visual element. Usage \u00b6 Simple \u00b6 You can create an input field bound to a variable with the following content: Page content Markdown <|{value}|input|> HTML < taipy:input > {value} </ taipy:input >","title":"`input`"},{"location":"manuals/gui/viselements/input/#input","text":"A control that displays some text that can potentially be edited.","title":"input"},{"location":"manuals/gui/viselements/input/#properties","text":"Name Type Default Description value (\u2605) dynamic(any) None The value represented by this control. propagate bool App config Allows the control's main value to be automatically propagated. The default value is defined at the application configuration level. If True , any change to the control's value is immediately reflected in the bound application variable. active dynamic(bool) None Indicates if this component is active. An inactive component allows no user interaction. id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) value is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/input/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/input/#simple","text":"You can create an input field bound to a variable with the following content: Page content Markdown <|{value}|input|> HTML < taipy:input > {value} </ taipy:input >","title":"Simple"},{"location":"manuals/gui/viselements/layout/","text":"layout \u00b6 Organizes its children into cells in a regular grid. Properties \u00b6 Name Type Default Description columns (\u2605) str \"1 1\" The list of weights for each column. For example, `\"1 2\"` creates a grid which is 2 columns wide: 1fr 2fr columns[mobile] str \"1\" The list of weights for each column, when displayed on a mobile device. The syntax is the same as for columns . gap str \"0.5rem\" The size of the gap between the columns. id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) columns is the default property for this visual element. Usage \u00b6 Simple \u00b6 <|layout| ... |> Advanced \u00b6 <|layout|columns=1 1|gap=1rem| ... |> or with properties <|layout|properties={properties}| ... |> or with closing tag <|layout.start|...|> ... <|layout.end|>","title":"`layout`"},{"location":"manuals/gui/viselements/layout/#layout","text":"Organizes its children into cells in a regular grid.","title":"layout"},{"location":"manuals/gui/viselements/layout/#properties","text":"Name Type Default Description columns (\u2605) str \"1 1\" The list of weights for each column. For example, `\"1 2\"` creates a grid which is 2 columns wide: 1fr 2fr columns[mobile] str \"1\" The list of weights for each column, when displayed on a mobile device. The syntax is the same as for columns . gap str \"0.5rem\" The size of the gap between the columns. id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) columns is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/layout/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/layout/#simple","text":"<|layout| ... |>","title":"Simple"},{"location":"manuals/gui/viselements/layout/#advanced","text":"<|layout|columns=1 1|gap=1rem| ... |> or with properties <|layout|properties={properties}| ... |> or with closing tag <|layout.start|...|> ... <|layout.end|>","title":"Advanced"},{"location":"manuals/gui/viselements/menu/","text":"menu \u00b6 A menu control. This control is represented by a unique left-anchor and foldable vertical menu. Properties \u00b6 Name Type Default Description lov (\u2605) dynamic(str|List[str|TaipyImage|any]) None The list of menu option values. adapter FunctionType? `\"lambda x: str(x)\"` The function that transforms an element of lov into a tuple(id:str, label:str|TaipyImage) . type str Type(lov-element)?? Must be specified if `lov` contains a non specific type of data (ex: dict). value must be of that type, lov must be an iterable on this type, and the adapter function will receive an object of this type. label str None The title of the menu. width str \"15vw\" The width, in CSS units, of the menu when unfolded. Note that when running on a mobile device, the property width[active] is used instead. width[mobile] str \"85vw\" The width, in CSS units, of the menu when unfolded, on a mobile device. active dynamic(bool) True Indicates, when True , that this component is active. An inactive component allows no user interaction. on_action str \"on_menu_action\" The name of the function that will is triggered when a menu option is selected. All the parameters of that function are optional: gui instance id action payload with selected id (\u2605) lov is the default property for this visual element. Usage \u00b6 Simple \u00b6 <|menu|lov={[\"menu 1\", \"menu 2\"]}> Advanced \u00b6 <|menu|lov={lov}|label=a label|width=15vw|width[mobile]=85vw|inactiveIds={ids}|>","title":"`menu`"},{"location":"manuals/gui/viselements/menu/#menu","text":"A menu control. This control is represented by a unique left-anchor and foldable vertical menu.","title":"menu"},{"location":"manuals/gui/viselements/menu/#properties","text":"Name Type Default Description lov (\u2605) dynamic(str|List[str|TaipyImage|any]) None The list of menu option values. adapter FunctionType? `\"lambda x: str(x)\"` The function that transforms an element of lov into a tuple(id:str, label:str|TaipyImage) . type str Type(lov-element)?? Must be specified if `lov` contains a non specific type of data (ex: dict). value must be of that type, lov must be an iterable on this type, and the adapter function will receive an object of this type. label str None The title of the menu. width str \"15vw\" The width, in CSS units, of the menu when unfolded. Note that when running on a mobile device, the property width[active] is used instead. width[mobile] str \"85vw\" The width, in CSS units, of the menu when unfolded, on a mobile device. active dynamic(bool) True Indicates, when True , that this component is active. An inactive component allows no user interaction. on_action str \"on_menu_action\" The name of the function that will is triggered when a menu option is selected. All the parameters of that function are optional: gui instance id action payload with selected id (\u2605) lov is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/menu/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/menu/#simple","text":"<|menu|lov={[\"menu 1\", \"menu 2\"]}>","title":"Simple"},{"location":"manuals/gui/viselements/menu/#advanced","text":"<|menu|lov={lov}|label=a label|width=15vw|width[mobile]=85vw|inactiveIds={ids}|>","title":"Advanced"},{"location":"manuals/gui/viselements/navbar/","text":"navbar \u00b6 A navigation bar control. This control is implemented as a list of links. Properties \u00b6 Name Type Default Description value (\u2605) dynamic(any) Mandatory Bound to the selection value. lov dict[str, any] None The list of values. See [GLOBAL-LOV] for details. adapter FunctionType `lambda x: str(x)` The function that transforms an element of lov into a tuple(id:str, label:str|TaipyImage) . type str Type(lov-element)?? Must be specified if lov contains a non-specific type of data (ex: dict). value must be of that type, lov must be an iterable on this type, and the adapter function will receive an object of this type. (\u2605) value is the default property for this visual element. Usage \u00b6 Simple \u00b6 <|navbar|> Advanced \u00b6 <|navbar|lov={lov}|>","title":"`navbar`"},{"location":"manuals/gui/viselements/navbar/#navbar","text":"A navigation bar control. This control is implemented as a list of links.","title":"navbar"},{"location":"manuals/gui/viselements/navbar/#properties","text":"Name Type Default Description value (\u2605) dynamic(any) Mandatory Bound to the selection value. lov dict[str, any] None The list of values. See [GLOBAL-LOV] for details. adapter FunctionType `lambda x: str(x)` The function that transforms an element of lov into a tuple(id:str, label:str|TaipyImage) . type str Type(lov-element)?? Must be specified if lov contains a non-specific type of data (ex: dict). value must be of that type, lov must be an iterable on this type, and the adapter function will receive an object of this type. (\u2605) value is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/navbar/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/navbar/#simple","text":"<|navbar|>","title":"Simple"},{"location":"manuals/gui/viselements/navbar/#advanced","text":"<|navbar|lov={lov}|>","title":"Advanced"},{"location":"manuals/gui/viselements/number/","text":"number \u00b6 A kind of input that handles numbers. Properties \u00b6 Name Type Default Description value (\u2605) dynamic(any) None The numerical value represented by this control. (\u2605) value is the default property for this visual element. Usage \u00b6 Simple \u00b6 You can create an number field bound to a numerical variable with the following content: Page content Markdown <|{value}|number|> HTML < taipy:number > {value} </ taipy:number >","title":"`number`"},{"location":"manuals/gui/viselements/number/#number","text":"A kind of input that handles numbers.","title":"number"},{"location":"manuals/gui/viselements/number/#properties","text":"Name Type Default Description value (\u2605) dynamic(any) None The numerical value represented by this control. (\u2605) value is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/number/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/number/#simple","text":"You can create an number field bound to a numerical variable with the following content: Page content Markdown <|{value}|number|> HTML < taipy:number > {value} </ taipy:number >","title":"Simple"},{"location":"manuals/gui/viselements/pane/","text":"pane \u00b6 A side pane. TODO: Complete Properties \u00b6 Name Type Default Description open (\u2605) bool False If True , this pane is visible on the page. If False , the pane is hidden. close_action str None The name of a function that is be triggered when this pane is closed (if the user clicks outside of it or presses the Esc key). All parameters of that function are optional: gui instance id action If this property is set to None, no function is called when this pane is closed. partial Partial None A Partial object that holds the content of this pane. This should not be defined if page_id is set. page_id str None The page identifier to show as the content of this pane. This should not be defined if partial is set. anchor str \"left\" Anchor side of the pane. Valid values are \"left\", \"right\", \"top\" or \"bottom\". width str \"30vw\" Width, in CSS units, of this pane. This is used only if anchor is \"left\" or \"right\". height str \"30vh\" Height, in CSS units, of this pane. This is used only if anchor is \"top\" or \"bottom\". persistent bool False If True , the pane appears next to the page. If False , the pane covers the page where it appeared. id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) open is the default property for this visual element. Usage \u00b6 Simple \u00b6 <|{open}|pane| * * ... * |> Advanced \u00b6 <|pane|open={value}|page_id=page1|close_action=close_action|> or with properties <|{open}|pane|properties={properties}|partial={myPartial}|>","title":"`pane`"},{"location":"manuals/gui/viselements/pane/#pane","text":"A side pane. TODO: Complete","title":"pane"},{"location":"manuals/gui/viselements/pane/#properties","text":"Name Type Default Description open (\u2605) bool False If True , this pane is visible on the page. If False , the pane is hidden. close_action str None The name of a function that is be triggered when this pane is closed (if the user clicks outside of it or presses the Esc key). All parameters of that function are optional: gui instance id action If this property is set to None, no function is called when this pane is closed. partial Partial None A Partial object that holds the content of this pane. This should not be defined if page_id is set. page_id str None The page identifier to show as the content of this pane. This should not be defined if partial is set. anchor str \"left\" Anchor side of the pane. Valid values are \"left\", \"right\", \"top\" or \"bottom\". width str \"30vw\" Width, in CSS units, of this pane. This is used only if anchor is \"left\" or \"right\". height str \"30vh\" Height, in CSS units, of this pane. This is used only if anchor is \"top\" or \"bottom\". persistent bool False If True , the pane appears next to the page. If False , the pane covers the page where it appeared. id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) open is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/pane/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/pane/#simple","text":"<|{open}|pane| * * ... * |>","title":"Simple"},{"location":"manuals/gui/viselements/pane/#advanced","text":"<|pane|open={value}|page_id=page1|close_action=close_action|> or with properties <|{open}|pane|properties={properties}|partial={myPartial}|>","title":"Advanced"},{"location":"manuals/gui/viselements/part/","text":"part \u00b6 Displays its children in a block. Part controls can be simplified by specifying no component. TODO: explain. Properties \u00b6 Name Type Default Description render (\u2605) bool True If True , this part is visible on the page. If False , the part is hidden and all its content is not displayed. id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) render is the default property for this visual element. Usage \u00b6 Simple \u00b6 <| ... |> Advanced \u00b6 <|part|class_name=name|don't render| ... |> or with closing tag <|part.start|...|> ... <|part.end|>","title":"`part`"},{"location":"manuals/gui/viselements/part/#part","text":"Displays its children in a block. Part controls can be simplified by specifying no component. TODO: explain.","title":"part"},{"location":"manuals/gui/viselements/part/#properties","text":"Name Type Default Description render (\u2605) bool True If True , this part is visible on the page. If False , the part is hidden and all its content is not displayed. id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) render is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/part/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/part/#simple","text":"<| ... |>","title":"Simple"},{"location":"manuals/gui/viselements/part/#advanced","text":"<|part|class_name=name|don't render| ... |> or with closing tag <|part.start|...|> ... <|part.end|>","title":"Advanced"},{"location":"manuals/gui/viselements/selector/","text":"selector \u00b6 A control that allows for selecting items from a list of choices. Each item is represented by a string, an image or both. The selector can let the user select multiple items. A filtering feature is available to display only a subset of the items. You can use an arbitrary type for all the items (see the example ). Properties \u00b6 Name Type Default Description filter bool False If True , this control is combined with a filter input area. multiple bool False If True , the user can select multiple items. width str|int 360?? The width, in CSS units, of this element. height str|int None The height, in CSS units, of this element. dropdown bool False If True , the list of items is shown in a dropdown menu. You cannot use the filter in that situation. value (\u2605) dynamic(any) Mandatory Bound to the selection value. lov dict[str, any] None The list of values. See [GLOBAL-LOV] for details. adapter FunctionType `lambda x: str(x)` The function that transforms an element of lov into a tuple(id:str, label:str|TaipyImage) . type str Type(lov-element)?? Must be specified if lov contains a non-specific type of data (ex: dict). value must be of that type, lov must be an iterable on this type, and the adapter function will receive an object of this type. (\u2605) value is the default property for this visual element. Usage \u00b6 Simple \u00b6 You can create a selector on a series of strings: Page content Markdown <|{value}|selector|lov=Item 1;Item 2;Item 3|> HTML < taipy:selector lov = \"Item 1;Item 2;Item 3\" > {value} </ taipy:selector > Binding to a list of objects \u00b6 Assuming your Python code has created a list of object: class User : def __init__ ( self , id , name , birth_year ): self . id , self . name , self . birth_year = ( id , name , birth_year ) users = [ User ( 231 , \"Johanna\" , 1987 ), User ( 125 , \"John\" , 1979 ), User ( 4 , \"Peter\" , 1968 ), User ( 31 , \"Mary\" , 1974 ) ] If you want to create a selector control that lets you pick a specific user, you can use the following fragment. Page content Markdown <|{users}|selector|lov={users}|type=User|adapter=lambda u: (u.id, u.name)|> HTML < taipy:selector lov = \"{users}\" type = \"User\" adapter = \"lambda u: (u.id, u.name)\" > {users} </ taipy:selector > In this example, we are using the Python list users as the selector's list of values . Because the control needs a way to convert the list items (which are instances of the class User ) into a string that can be displayed, we are using an adapter : a function that converts an object, whose type must be provided to the type property, to a tuple. The first element of the tuple is used to reference the selection (therefore those elements should be unique among all the items) and the second element is the string that turns out to be displayed. Lambda parameter names The parameter u that is used in the lambda expression must be declared in your Python code in the same scope as the other variables. Otherwise Taipy will fail to recognize the construct as valid.","title":"`selector`"},{"location":"manuals/gui/viselements/selector/#selector","text":"A control that allows for selecting items from a list of choices. Each item is represented by a string, an image or both. The selector can let the user select multiple items. A filtering feature is available to display only a subset of the items. You can use an arbitrary type for all the items (see the example ).","title":"selector"},{"location":"manuals/gui/viselements/selector/#properties","text":"Name Type Default Description filter bool False If True , this control is combined with a filter input area. multiple bool False If True , the user can select multiple items. width str|int 360?? The width, in CSS units, of this element. height str|int None The height, in CSS units, of this element. dropdown bool False If True , the list of items is shown in a dropdown menu. You cannot use the filter in that situation. value (\u2605) dynamic(any) Mandatory Bound to the selection value. lov dict[str, any] None The list of values. See [GLOBAL-LOV] for details. adapter FunctionType `lambda x: str(x)` The function that transforms an element of lov into a tuple(id:str, label:str|TaipyImage) . type str Type(lov-element)?? Must be specified if lov contains a non-specific type of data (ex: dict). value must be of that type, lov must be an iterable on this type, and the adapter function will receive an object of this type. (\u2605) value is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/selector/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/selector/#simple","text":"You can create a selector on a series of strings: Page content Markdown <|{value}|selector|lov=Item 1;Item 2;Item 3|> HTML < taipy:selector lov = \"Item 1;Item 2;Item 3\" > {value} </ taipy:selector >","title":"Simple"},{"location":"manuals/gui/viselements/selector/#binding-to-a-list-of-objects","text":"Assuming your Python code has created a list of object: class User : def __init__ ( self , id , name , birth_year ): self . id , self . name , self . birth_year = ( id , name , birth_year ) users = [ User ( 231 , \"Johanna\" , 1987 ), User ( 125 , \"John\" , 1979 ), User ( 4 , \"Peter\" , 1968 ), User ( 31 , \"Mary\" , 1974 ) ] If you want to create a selector control that lets you pick a specific user, you can use the following fragment. Page content Markdown <|{users}|selector|lov={users}|type=User|adapter=lambda u: (u.id, u.name)|> HTML < taipy:selector lov = \"{users}\" type = \"User\" adapter = \"lambda u: (u.id, u.name)\" > {users} </ taipy:selector > In this example, we are using the Python list users as the selector's list of values . Because the control needs a way to convert the list items (which are instances of the class User ) into a string that can be displayed, we are using an adapter : a function that converts an object, whose type must be provided to the type property, to a tuple. The first element of the tuple is used to reference the selection (therefore those elements should be unique among all the items) and the second element is the string that turns out to be displayed. Lambda parameter names The parameter u that is used in the lambda expression must be declared in your Python code in the same scope as the other variables. Otherwise Taipy will fail to recognize the construct as valid.","title":"Binding to a list of objects"},{"location":"manuals/gui/viselements/slider/","text":"slider \u00b6 Displays and allows the user to set a value within a range. The range is set by the values min and max that must be integer values. If the lov property is used, then the slider can be used to select a value amoung the different choices. Properties \u00b6 Name Type Default Description value (\u2605) dynamic(int | float | str) None The value that is set for this slider. It would be a lov label if it is used. min int|float 1?? The minimum value. This is ignored when lov is defined. max int|float 100 The maximum value. This is ignored when lov is defined. text_anchor?? str \"bottom\" When the lov property is used, this property indicates the location of the label. Possible values are: bottom top left right none (no label is displayed) labels bool|dict None The labels for specific points of the slider. If set to True , this slider uses the labels of the lov if there are any. If set to a dictionary, the slider uses the dictionary keys as a lov key or index, and the associated value as the label. width str \"300px\" The width, in CSS units, of this element. height str None The height, in CSS units, of this element. It defaults to the width value when using the vertical orientation. orientation str \"horizontal\" The orientation of this slider. Valid values are \"horizontal\" or \"vertical\". value (\u2605) dynamic(any) Mandatory Bound to the selection value. lov dict[str, any] None The list of values. See [GLOBAL-LOV] for details. adapter FunctionType `lambda x: str(x)` The function that transforms an element of lov into a tuple(id:str, label:str|TaipyImage) . type str Type(lov-element)?? Must be specified if lov contains a non-specific type of data (ex: dict). value must be of that type, lov must be an iterable on this type, and the adapter function will receive an object of this type. (\u2605) value is the default property for this visual element. Usage \u00b6 Simple \u00b6 A numeric value can easily be represented and interacted with using the following content: Page content Markdown <|{value}|slider|> HTML < taipy:slider > {value} </ taipy:slider > Constraining values \u00b6 You can specify what bounds the value should be restrained to: Page content Markdown <|{value}|slider|min=1|max=100|propagate|> HTML < taipy:slider min = \"1\" max = \"100\" propagate = \"true\" > {value} </ taipy:slider >","title":"`slider`"},{"location":"manuals/gui/viselements/slider/#slider","text":"Displays and allows the user to set a value within a range. The range is set by the values min and max that must be integer values. If the lov property is used, then the slider can be used to select a value amoung the different choices.","title":"slider"},{"location":"manuals/gui/viselements/slider/#properties","text":"Name Type Default Description value (\u2605) dynamic(int | float | str) None The value that is set for this slider. It would be a lov label if it is used. min int|float 1?? The minimum value. This is ignored when lov is defined. max int|float 100 The maximum value. This is ignored when lov is defined. text_anchor?? str \"bottom\" When the lov property is used, this property indicates the location of the label. Possible values are: bottom top left right none (no label is displayed) labels bool|dict None The labels for specific points of the slider. If set to True , this slider uses the labels of the lov if there are any. If set to a dictionary, the slider uses the dictionary keys as a lov key or index, and the associated value as the label. width str \"300px\" The width, in CSS units, of this element. height str None The height, in CSS units, of this element. It defaults to the width value when using the vertical orientation. orientation str \"horizontal\" The orientation of this slider. Valid values are \"horizontal\" or \"vertical\". value (\u2605) dynamic(any) Mandatory Bound to the selection value. lov dict[str, any] None The list of values. See [GLOBAL-LOV] for details. adapter FunctionType `lambda x: str(x)` The function that transforms an element of lov into a tuple(id:str, label:str|TaipyImage) . type str Type(lov-element)?? Must be specified if lov contains a non-specific type of data (ex: dict). value must be of that type, lov must be an iterable on this type, and the adapter function will receive an object of this type. (\u2605) value is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/slider/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/slider/#simple","text":"A numeric value can easily be represented and interacted with using the following content: Page content Markdown <|{value}|slider|> HTML < taipy:slider > {value} </ taipy:slider >","title":"Simple"},{"location":"manuals/gui/viselements/slider/#constraining-values","text":"You can specify what bounds the value should be restrained to: Page content Markdown <|{value}|slider|min=1|max=100|propagate|> HTML < taipy:slider min = \"1\" max = \"100\" propagate = \"true\" > {value} </ taipy:slider >","title":"Constraining values"},{"location":"manuals/gui/viselements/status/","text":"status \u00b6 Displays a status or a list of statuses. Properties \u00b6 Name Type Default Description value (\u2605) dict|list[dict] None The different statuses to represent. See below. without_close bool False If True , the user cannot hide the child statuses. id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) value is the default property for this visual element. Usage \u00b6 value can be a list of ?? or a dictionary that must contain the keys - status - message Simple \u00b6 <|{value}|status|> Advanced \u00b6 <|{value}|status|> or with properties <|{value}|status|properties={properties}|>","title":"`status`"},{"location":"manuals/gui/viselements/status/#status","text":"Displays a status or a list of statuses.","title":"status"},{"location":"manuals/gui/viselements/status/#properties","text":"Name Type Default Description value (\u2605) dict|list[dict] None The different statuses to represent. See below. without_close bool False If True , the user cannot hide the child statuses. id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) value is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/status/#usage","text":"value can be a list of ?? or a dictionary that must contain the keys - status - message","title":"Usage"},{"location":"manuals/gui/viselements/status/#simple","text":"<|{value}|status|>","title":"Simple"},{"location":"manuals/gui/viselements/status/#advanced","text":"<|{value}|status|> or with properties <|{value}|status|properties={properties}|>","title":"Advanced"},{"location":"manuals/gui/viselements/table/","text":"table \u00b6 Displays a data set as tabular data. The table component supports 3 display modes: - paginated : you can choose the page size and page size options ( allow_all_rows adds an option to show a page with all rows). - unpaginated : all rows and no page are shown ( show_all = True ). - auto_loading : the pages are loaded on demand depending on the visible area. Properties \u00b6 Name Type Default Description value (\u2605) any None The data to be represented in this table. page_size int 100 nan allow_all_rows bool False nan show_all bool False nan auto_loading bool False data will be loaded on demand width[ col_name ] str None The width, in CSS units, of the indicated column. selected list[int]|str None The list of the selected indices. ?? page_size_options List[int]|str [50, 100, 500] The list of available page sizes that users can choose. columns str|List[str]|Dict[str, Dict[str, str|int]] \"All columns\"?? The list of the column names. str: separated list of column names. List[str] dict: {\"col name\": {format: \"format\", index: 1}} if index is specified, it represents the display order of the columns. If index is not specified, the list order defines the index date_format str \"MM/dd/yyyy\" The date format that is used for all date columns when format is not defined.?? number_format str None nan group_by[ col_name ] bool False Indicates, if True , that the given column can be aggregated. See [below](#aggregation) for details. apply[ col_name ] str \"first\" The name of the aggregation function to use. This is used only if group_by[column_name] is set to True . See [below](#aggregation) for details. style str None Allows the styling of table lines. See [below](#styling) for details. style[ col_name ] str None Allows the styling of table cells. See [below](#styling) for details. width str|int|float 100vw The width, in CSS units, of this table control. height str|int|float 100vw The height, in CSS units, of this table control. nan_value str \"\" The replacement text for NaN (not-a-number) values. nan_value[ col_name ] str \"\" The replacement text for NaN (not-a-number) values for the indicated column. id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) value is the default property for this visual element. Details \u00b6 Properties \u00b6 - `selected`: TODO describe Aggregation \u00b6 To get the aggregation functionality in your table, you must indicate which columns can be aggregated, and how to perform the aggregation. This is done using the group_by and apply properties. The group_by[column_name] property, when set to True indicates that the column column_name can be aggregated. The function provided in the apply[column_name] property indicates how to perform this aggregation. The value of this property, which is a string, can be: A built-in function. Available predefined functions are the following: count , sum , mean , median , min , max , std , first (the default value) and last . The name of a user-defined function, or a lambda function. This function receives a single parameter which is the series to aggregate, and it must return a scalar value which would be the result of the aggregation. [TODO: Add short example ie. sum or sum/average] Styling \u00b6 You can modify the style of entire rows or specific table cells. When Taipy creates the rows and the cells, it can add a specific CSS class that you would have set as the return value of the function set to the style property, for entire rows, or style[_column_name_] , for specific cells. The signature of this function depends on which style property you use: style : this applies to entire rows. The given function expects two parameters: index : the index of the row in this table _ row_ (optional?): all the values for this row style[_column_name_] : this applies to a specific cell. The given function expects four parameters: value : the value of the cell index (optional?): the index of the row of this cell column_name (optional?): the name of the column for this cell Based on these parameters, the function must return a string that defines a CSS class name that will be added to the CSS classes for this table row, or this specific cell. You can then add the definition of this class in your CSS file. [TODO: Add short example ie. odd/even lines] Usage \u00b6 Simple \u00b6 <|{value}|table|> Advanced \u00b6 <|{value}|table|page_size=10|page_size_options=10;30;100|columns=Col 1;Col 2;Col 3|date_format=eee dd MMM yyyy|not allow_all_rows|show_all=No|auto_loading=False|width=100vw|height=100vw|selected={selection}|> or with properties <|{value}|table|properties={properties}|selected={selection}|>","title":"`table`"},{"location":"manuals/gui/viselements/table/#table","text":"Displays a data set as tabular data. The table component supports 3 display modes: - paginated : you can choose the page size and page size options ( allow_all_rows adds an option to show a page with all rows). - unpaginated : all rows and no page are shown ( show_all = True ). - auto_loading : the pages are loaded on demand depending on the visible area.","title":"table"},{"location":"manuals/gui/viselements/table/#properties","text":"Name Type Default Description value (\u2605) any None The data to be represented in this table. page_size int 100 nan allow_all_rows bool False nan show_all bool False nan auto_loading bool False data will be loaded on demand width[ col_name ] str None The width, in CSS units, of the indicated column. selected list[int]|str None The list of the selected indices. ?? page_size_options List[int]|str [50, 100, 500] The list of available page sizes that users can choose. columns str|List[str]|Dict[str, Dict[str, str|int]] \"All columns\"?? The list of the column names. str: separated list of column names. List[str] dict: {\"col name\": {format: \"format\", index: 1}} if index is specified, it represents the display order of the columns. If index is not specified, the list order defines the index date_format str \"MM/dd/yyyy\" The date format that is used for all date columns when format is not defined.?? number_format str None nan group_by[ col_name ] bool False Indicates, if True , that the given column can be aggregated. See [below](#aggregation) for details. apply[ col_name ] str \"first\" The name of the aggregation function to use. This is used only if group_by[column_name] is set to True . See [below](#aggregation) for details. style str None Allows the styling of table lines. See [below](#styling) for details. style[ col_name ] str None Allows the styling of table cells. See [below](#styling) for details. width str|int|float 100vw The width, in CSS units, of this table control. height str|int|float 100vw The height, in CSS units, of this table control. nan_value str \"\" The replacement text for NaN (not-a-number) values. nan_value[ col_name ] str \"\" The replacement text for NaN (not-a-number) values for the indicated column. id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) value is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/table/#details","text":"","title":"Details"},{"location":"manuals/gui/viselements/table/#properties_1","text":"- `selected`: TODO describe","title":"Properties"},{"location":"manuals/gui/viselements/table/#aggregation","text":"To get the aggregation functionality in your table, you must indicate which columns can be aggregated, and how to perform the aggregation. This is done using the group_by and apply properties. The group_by[column_name] property, when set to True indicates that the column column_name can be aggregated. The function provided in the apply[column_name] property indicates how to perform this aggregation. The value of this property, which is a string, can be: A built-in function. Available predefined functions are the following: count , sum , mean , median , min , max , std , first (the default value) and last . The name of a user-defined function, or a lambda function. This function receives a single parameter which is the series to aggregate, and it must return a scalar value which would be the result of the aggregation. [TODO: Add short example ie. sum or sum/average]","title":"Aggregation"},{"location":"manuals/gui/viselements/table/#styling","text":"You can modify the style of entire rows or specific table cells. When Taipy creates the rows and the cells, it can add a specific CSS class that you would have set as the return value of the function set to the style property, for entire rows, or style[_column_name_] , for specific cells. The signature of this function depends on which style property you use: style : this applies to entire rows. The given function expects two parameters: index : the index of the row in this table _ row_ (optional?): all the values for this row style[_column_name_] : this applies to a specific cell. The given function expects four parameters: value : the value of the cell index (optional?): the index of the row of this cell column_name (optional?): the name of the column for this cell Based on these parameters, the function must return a string that defines a CSS class name that will be added to the CSS classes for this table row, or this specific cell. You can then add the definition of this class in your CSS file. [TODO: Add short example ie. odd/even lines]","title":"Styling"},{"location":"manuals/gui/viselements/table/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/table/#simple","text":"<|{value}|table|>","title":"Simple"},{"location":"manuals/gui/viselements/table/#advanced","text":"<|{value}|table|page_size=10|page_size_options=10;30;100|columns=Col 1;Col 2;Col 3|date_format=eee dd MMM yyyy|not allow_all_rows|show_all=No|auto_loading=False|width=100vw|height=100vw|selected={selection}|> or with properties <|{value}|table|properties={properties}|selected={selection}|>","title":"Advanced"},{"location":"manuals/gui/viselements/text/","text":"text \u00b6 Displays a value as a static text. Note that if order to create a text control, you don't need to specify the control name in the text template. See the documentation for Controls for more details. Properties \u00b6 Name Type Default Description value (\u2605) dynamic(Any) \"\" The value displayed as text by this control. format str Mandatory The format to apply to the value. See below. id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) value is the default property for this visual element. Details \u00b6 The format property uses a format string like the ones used by the string format() function of Python. If the value is a date or a datetime , then format can be set to a date/time formatting string. Usage \u00b6 Simple \u00b6 You can represent a variable value as a simple, static text: Page content Markdown <|{value}|> HTML < taipy:text > {value} </ taipy:text > Formatted output \u00b6 If your value is a floating point value, you can use the format property to indicate what the output format should be used. To display a floating point value with two decimal place: Page content Markdown <|{value}|text|format=%.2f|> HTML < taipy:text format = \"%.2f\" > {value} </ taipy:text >","title":"`text`"},{"location":"manuals/gui/viselements/text/#text","text":"Displays a value as a static text. Note that if order to create a text control, you don't need to specify the control name in the text template. See the documentation for Controls for more details.","title":"text"},{"location":"manuals/gui/viselements/text/#properties","text":"Name Type Default Description value (\u2605) dynamic(Any) \"\" The value displayed as text by this control. format str Mandatory The format to apply to the value. See below. id str \"\" The identifier that will be assigned to the rendered HTML component. properties dict[str, any] None Bound to a dictionary that contains additonnal properties for this element. class_name str None CSS class name that will be associated with the generated HTML Element. This class names will be added to the default taipy-<element_type> . (\u2605) value is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/text/#details","text":"The format property uses a format string like the ones used by the string format() function of Python. If the value is a date or a datetime , then format can be set to a date/time formatting string.","title":"Details"},{"location":"manuals/gui/viselements/text/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/text/#simple","text":"You can represent a variable value as a simple, static text: Page content Markdown <|{value}|> HTML < taipy:text > {value} </ taipy:text >","title":"Simple"},{"location":"manuals/gui/viselements/text/#formatted-output","text":"If your value is a floating point value, you can use the format property to indicate what the output format should be used. To display a floating point value with two decimal place: Page content Markdown <|{value}|text|format=%.2f|> HTML < taipy:text format = \"%.2f\" > {value} </ taipy:text >","title":"Formatted output"},{"location":"manuals/gui/viselements/toggle/","text":"toggle \u00b6 A series of toggle buttons that the user can select. Properties \u00b6 Name Type Default Description value (\u2605) dynamic(any) Mandatory Bound to the selection value. theme bool False If set, this toggle control acts as a way to set the application Theme (dark or light). lov dict[str, any] None The list of values. See [GLOBAL-LOV] for details. adapter FunctionType `lambda x: str(x)` The function that transforms an element of lov into a tuple(id:str, label:str|TaipyImage) . type str Type(lov-element)?? Must be specified if lov contains a non-specific type of data (ex: dict). value must be of that type, lov must be an iterable on this type, and the adapter function will receive an object of this type. (\u2605) value is the default property for this visual element. Details \u00b6 Toggle buttons can hold both some text and/or an image. Usage \u00b6 Simple \u00b6 <|{value}|toggle|lov=Item 1;Item 2;Item 3|> <|toggle|theme|> Advanced \u00b6 <|{value}|toggle|lov={lov}|type=myType|adapter=lambda x: (x.id, x.name)|> or with properties <|{value}|toggle|properties={properties}|lov={lov}|>","title":"`toggle`"},{"location":"manuals/gui/viselements/toggle/#toggle","text":"A series of toggle buttons that the user can select.","title":"toggle"},{"location":"manuals/gui/viselements/toggle/#properties","text":"Name Type Default Description value (\u2605) dynamic(any) Mandatory Bound to the selection value. theme bool False If set, this toggle control acts as a way to set the application Theme (dark or light). lov dict[str, any] None The list of values. See [GLOBAL-LOV] for details. adapter FunctionType `lambda x: str(x)` The function that transforms an element of lov into a tuple(id:str, label:str|TaipyImage) . type str Type(lov-element)?? Must be specified if lov contains a non-specific type of data (ex: dict). value must be of that type, lov must be an iterable on this type, and the adapter function will receive an object of this type. (\u2605) value is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/toggle/#details","text":"Toggle buttons can hold both some text and/or an image.","title":"Details"},{"location":"manuals/gui/viselements/toggle/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/toggle/#simple","text":"<|{value}|toggle|lov=Item 1;Item 2;Item 3|> <|toggle|theme|>","title":"Simple"},{"location":"manuals/gui/viselements/toggle/#advanced","text":"<|{value}|toggle|lov={lov}|type=myType|adapter=lambda x: (x.id, x.name)|> or with properties <|{value}|toggle|properties={properties}|lov={lov}|>","title":"Advanced"},{"location":"manuals/gui/viselements/tree/","text":"tree \u00b6 A control that allows multiple selection and filtering on label. Properties \u00b6 Name Type Default Description filter bool False If True , this control is combined with a filter input area. multiple bool False If True , the user can select multiple items. width str|int 360?? The width, in CSS units, of this element. height str|int None The height, in CSS units, of this element. dropdown bool False If True , the list of items is shown in a dropdown menu. You cannot use the filter in that situation. value (\u2605) dynamic(any) Mandatory Bound to the selection value. lov dict[str, any] None The list of values. See [GLOBAL-LOV] for details. adapter FunctionType `lambda x: str(x)` The function that transforms an element of lov into a tuple(id:str, label:str|TaipyImage) . type str Type(lov-element)?? Must be specified if lov contains a non-specific type of data (ex: dict). value must be of that type, lov must be an iterable on this type, and the adapter function will receive an object of this type. (\u2605) value is the default property for this visual element. Usage \u00b6 Simple \u00b6 <|{value}|tree|lov=Item 1;Item 2;Item 3|> Advanced \u00b6 <|{value}|tree|lov={lov}|no filter|not multiple|type=myType|adapter=lambda x: (x.id, x.name, x.children)|> or with properties code><|{value}|selector|properties={properties}|lov={lov}|>","title":"`tree`"},{"location":"manuals/gui/viselements/tree/#tree","text":"A control that allows multiple selection and filtering on label.","title":"tree"},{"location":"manuals/gui/viselements/tree/#properties","text":"Name Type Default Description filter bool False If True , this control is combined with a filter input area. multiple bool False If True , the user can select multiple items. width str|int 360?? The width, in CSS units, of this element. height str|int None The height, in CSS units, of this element. dropdown bool False If True , the list of items is shown in a dropdown menu. You cannot use the filter in that situation. value (\u2605) dynamic(any) Mandatory Bound to the selection value. lov dict[str, any] None The list of values. See [GLOBAL-LOV] for details. adapter FunctionType `lambda x: str(x)` The function that transforms an element of lov into a tuple(id:str, label:str|TaipyImage) . type str Type(lov-element)?? Must be specified if lov contains a non-specific type of data (ex: dict). value must be of that type, lov must be an iterable on this type, and the adapter function will receive an object of this type. (\u2605) value is the default property for this visual element.","title":"Properties"},{"location":"manuals/gui/viselements/tree/#usage","text":"","title":"Usage"},{"location":"manuals/gui/viselements/tree/#simple","text":"<|{value}|tree|lov=Item 1;Item 2;Item 3|>","title":"Simple"},{"location":"manuals/gui/viselements/tree/#advanced","text":"<|{value}|tree|lov={lov}|no filter|not multiple|type=myType|adapter=lambda x: (x.id, x.name, x.children)|> or with properties code><|{value}|selector|properties={properties}|lov={lov}|>","title":"Advanced"}]}